{"meta":{"title":"My Blog","subtitle":"我的小站","description":"学不见其长，但日有所增","author":"lkness","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-06-13T14:13:04.000Z","updated":"2018-06-14T02:26:59.879Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-06-13T14:08:29.000Z","updated":"2018-06-14T02:29:37.339Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"006time-heap","slug":"006time-heap/index","date":"2018-06-15T07:46:30.000Z","updated":"2018-06-15T07:49:05.635Z","comments":true,"path":"2018/06/15/006time-heap/index/","link":"","permalink":"http://yoursite.com/2018/06/15/006time-heap/index/","excerpt":"","text":"跟上一篇，这里写一下时间堆： 时间轮的滴答是固定以指定的槽间隔触发，而时间堆是以定时器堆中的最小到期时间做定时，也就是alarm(minTimeout)，一旦定时器被触发，那么就删除此定时器，更新时间堆，将新的最小到期时间定时器作为新的定时。 然后是时间堆的数据结构，这里用了二叉树，将二叉树的根节点作为最小最小到期时间，每次滴答就取根节点，并且是完全二叉树，因此比较容易理解，我也懒得画图了，截了书上的图： 从图中可以看到，对时间堆的关键操作其实就是上滤和下滤，上滤也就是简单的将完全二叉树待添加的定时器最为最后一个节点并与父节点比较，如果小于，则交换两节点位置，再将此节点与父节点比较，直到待插入节点值大于父节点值或者已经是根节点即停止；下滤就是触发一个定时器之后删除此定时器，然后取完全二叉树的深度最大一排的最后一个叶子节点作为根节点，然后用此根节点与两个儿子节点比较，若根节点值大于儿子节点中最大者，则交换这两个节点，再以这个节点做同样的下滤，如果对于任意完全二叉树，这样简单的下滤不能找出最小节点，但是配合定时器添加时的上滤操作后的完全二叉树，这样就可行。 下面贴自己改的代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;signal.h&gt; #include &lt;time.h&gt; typedef struct client_data { char buf[512]; time_t tt; void* data; } client_data; typedef struct heap_timer { //单个定时器设置绝对时间 time_t expire; //加的设置的定时器到时秒数 int timeout; //到时回调函数 void (*cb_func)( void* ); //回调函数参数 struct client_data* user_data; } heap_timer ; typedef struct h_t_manager { //定时器指针数组 struct heap_timer** array; //当前定时管理器支持的最大定时器个数 int capacity; //当前定时管理器上的定时器个数 int cur_size; } h_t_manager ; void cb_func( void* param ) { time_t tt = time(NULL); printf(&quot;\\n-----------------------------------------------\\n&quot;); printf(&quot;\\tontime,cur time - old time:%d\\n&quot;, (int)(tt - ((client_data*)param)-&gt;tt)); printf(&quot;\\toldtime:%s&quot;, ctime(&amp;(((client_data*)param)-&gt;tt))); printf(&quot;\\tcurtime:%s&quot;, ctime(&amp;tt)); printf(&quot;-----------------------------------------------\\n&quot;); } static void percolate_down( h_t_manager* tmanager, int hole ) { heap_timer* temp = tmanager-&gt;array[hole]; int flag = 0; int child = 0; for ( ; ((hole*2+1) &lt;= (tmanager-&gt;cur_size-1)); hole = child ) { flag = 0; child = hole * 2 + 1; //这里找出当前节点最小儿子节点 if ( (child &lt; (tmanager-&gt;cur_size-1)) &amp;&amp; (tmanager-&gt;array[child+1]-&gt;expire) &lt; tmanager-&gt;array[child]-&gt;expire ) { ++child; } //比较待删除节点和最小儿子节点，若大于就交换 if ( tmanager-&gt;array[child]-&gt;expire &lt; temp-&gt;expire ) { //这里的交换其实该用内存拷贝比较好 int tmp_expire = tmanager-&gt;array[hole]-&gt;expire; int tmp_timeout = tmanager-&gt;array[hole]-&gt;timeout; tmanager-&gt;array[hole]-&gt;expire = tmanager-&gt;array[child]-&gt;expire; tmanager-&gt;array[hole]-&gt;timeout = tmanager-&gt;array[child]-&gt;timeout; tmanager-&gt;array[child]-&gt;expire = tmp_expire; tmanager-&gt;array[child]-&gt;timeout = tmp_timeout; } else { break; } //新的下滤比较 temp = tmanager-&gt;array[child]; //tmanager-&gt;array[hole] = temp; } } //将堆数组的容量扩大1倍 static int resize( h_t_manager* tmanager ) { heap_timer** temp = (heap_timer**) malloc( 2 * tmanager-&gt;capacity * sizeof(h_t_manager) ); int i = 0; for ( ; i &lt; 2 * tmanager-&gt;capacity; ++i ) { temp[i] = NULL; } if ( !temp ) { return -1; } tmanager-&gt;capacity = 2 * tmanager-&gt;capacity; for ( i = 0; i &lt; tmanager-&gt;cur_size; ++i ) { temp[i] = tmanager-&gt;array[i]; free(tmanager-&gt;array[i]); tmanager-&gt;array[i] = NULL; } tmanager-&gt;array = temp; return 0; } int init_ht_manager_0( h_t_manager* tmanager, int cap ) { tmanager-&gt;capacity = cap; tmanager-&gt;cur_size = 0; tmanager-&gt;array = (heap_timer**)malloc(cap * sizeof(h_t_manager)); int i = 0; for ( ; i &lt; cap; ++i ) { tmanager-&gt;array[i] = NULL; } } //添加定时器 int add_timer( h_t_manager* tmanager, int timeout ) { if ( !tmanager || timeout &lt;= 0) { return -1; } if ( tmanager-&gt;cur_size &gt;= tmanager-&gt;capacity ) { resize( tmanager ); } int hole = tmanager-&gt;cur_size++; int parent = 0; heap_timer* timer = (heap_timer*)malloc(sizeof(heap_timer)); time_t tt = time(NULL); timer-&gt;expire = (int)tt + timeout; timer-&gt;timeout = timeout; timer-&gt;user_data = (client_data*)malloc(sizeof(client_data)); timer-&gt;user_data-&gt;tt = time(NULL); timer-&gt;cb_func = cb_func; for ( ; hole &gt; 0; hole = parent ) { parent = ( hole - 1 ) / 2; if ( tmanager-&gt;array[parent]-&gt;expire &lt;= timer-&gt;expire ) { break; } tmanager-&gt;array[hole] = tmanager-&gt;array[parent]; } tmanager-&gt;array[hole] = timer; return 0; } int del_timer( h_t_manager* tmanager, heap_timer* timer ) { if ( !tmanager || !timer ) { return -1; } timer-&gt;cb_func = NULL; } int empty( h_t_manager* tmanager ) { return tmanager-&gt;cur_size == 0; } heap_timer* top( h_t_manager* tmanager ) { if ( empty(tmanager) ) { printf(&quot;!!!!!!!top-&gt;empty cur size\\n&quot;); return NULL; } return tmanager-&gt;array[0]; } int pop_timer( h_t_manager* tmanager ) { if ( empty( tmanager ) ) { printf(&quot;!!!!!!!pop_timer-&gt;empty cur size\\n&quot;); return -1; } if ( tmanager-&gt;array[0] ) { free( tmanager-&gt;array[0] ); tmanager-&gt;array[0] = NULL; tmanager-&gt;array[0] = tmanager-&gt;array[--tmanager-&gt;cur_size]; percolate_down( tmanager, 0 ); } return 0; } void tick( h_t_manager* tmanager ) { heap_timer* tmp = tmanager-&gt;array[0]; time_t cur = time( NULL ); while ( !empty(tmanager) ) { if ( !tmp ) { break; } if ( tmp-&gt;expire &gt; cur ) { break; } if ( tmanager-&gt;array[0]-&gt;cb_func ) { printf(&quot;timer on time,heap:&quot;); int i = 0; for ( ; i &lt; 10; i++ ) { if ( tmanager-&gt;array[i] ) printf(&quot;%d:%d &quot;, i, tmanager-&gt;array[i]-&gt;timeout); } tmanager-&gt;array[0]-&gt;cb_func( tmanager-&gt;array[0]-&gt;user_data ); } pop_timer( tmanager ); tmp = tmanager-&gt;array[0]; printf(&quot;after timer on time,heap:&quot;); int i = 0; for ( ; i &lt; 10; i++ ) { if ( tmanager-&gt;array[i] ) printf(&quot;%d:%d &quot;, i, tmanager-&gt;array[i]-&gt;timeout); } printf(&quot;\\n&quot;); if ( tmanager-&gt;array[0] ) printf(&quot;the next alarm is:%d\\n&quot;, (int)(tmanager-&gt;array[0]-&gt;timeout)); printf(&quot;current timer count:%d\\n&quot;, tmanager-&gt;cur_size); } } h_t_manager tmanager; void alarm_handler( int sig ) { tick( &amp;tmanager ); alarm( tmanager.array[0]-&gt;expire - time(NULL) ); } int main() { printf(&quot;start timer 。。。。。。。\\n&quot;); init_ht_manager_0( &amp;tmanager, 20 ); add_timer( &amp;tmanager, 11 ); add_timer( &amp;tmanager, 5 ); add_timer( &amp;tmanager, 11 ); // add_timer( &amp;tmanager, 22 ); add_timer( &amp;tmanager, 6 ); add_timer( &amp;tmanager, 9 ); // add_timer( &amp;tmanager, 23 ); // add_timer( &amp;tmanager, 33 ); // add_timer( &amp;tmanager, 28 ); // add_timer( &amp;tmanager, 1 ); // add_timer( &amp;tmanager, 66 ); // add_timer( &amp;tmanager, 77 ); // add_timer( &amp;tmanager, 88 ); // add_timer( &amp;tmanager, 55 ); signal( SIGALRM, alarm_handler ); time_t tt = time(NULL); printf(&quot;current time:%s&quot;, ctime(&amp;tt)); alarm( tmanager.array[0]-&gt;expire - time(NULL) ); while(1) sleep(5); return 0; } 因为用的完全二叉树，比较简单，跟上一篇时间轮一样，存在注意某些使用问题，整理的时候发现时间堆代码的注释还没写，想着自己加一点，发现很久前写的代码了，有点忘了，加了点也困了，打完羽毛球回来又连撸两篇博客 ，还被蚊子咬，一挠还挠死个咬得比我写博客还专注的蚊子 ，醉了 ~","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"}]},{"title":"C时间轮","slug":"005time-wheel/index","date":"2018-06-15T07:41:11.000Z","updated":"2018-06-15T07:45:15.640Z","comments":true,"path":"2018/06/15/005time-wheel/index/","link":"","permalink":"http://yoursite.com/2018/06/15/005time-wheel/index/","excerpt":"","text":"看完了《linux高性能服务器编程》对里面的定时器很感兴趣。书中提到三种定时器，分别是：基于升序链表的定时器，基于时间轮的定时器，基于时间堆的定时器。三种定时器的实现书中均是给了C++代码，不过我对C++不太感兴趣，虽然现在在做C++开发，因此写了C版本的。书中定时器只给了封装的定时器类，没有给调用层代码，我是估摸着写了调用层代码。这里做个总结，以后可以翻翻： 基于升序链表的定时器没太大难度，因此也懒得总结了。 说一下时间轮，下面是截的书中的图片： 时间轮，像轮子一样滚动定时，每滚一个刻度，指针就走一个滴答，滚完一圈，就进入下一圈。因此有了这个概念，时间轮的结构也就出来了：1.齿轮（槽slot），用来标识一个滴答；2.槽间隔（slot interval ），当前槽经过多长时间到下一个槽；3.一圈的槽数量（N）；4.当前指针，走一个滴答加一，走完一圈又回到初始位置。 再深入一点，定时器以什么方式添加到槽上？可以看图，每一个槽其实就是一个链表头结点，定时器即添加到所属槽的链表后。这样我们可以对时间轮性能进行分析，SI越小，定时精度越高，如果SI=10s，那么我们指定的定时器只能是10s的倍数；如果N越大，定时器效率越高，这也很好理解，N越小，一圈槽数量越少，那么我们同样添加100个定时器，分配到每个头结点的定时器越多，每一次滴答到时，就遍历当前槽，遍历一次所花时间越多。 如何确定定时器位置？根据定时器到时时间可以计算，例如：定时器超时时间timeout=21s(即21s后触发定时器)，当前间隔SI=2s，一圈槽数量N=70，当前指针cur_slot指向第5个槽，我们可以计算出定时器放置的位置，这里需要两个变量，一个rotation指定定时器处于第几圈，一个slot指定定时器处于第几个槽，因此slot = ( cur_slot + timeout / SI ) % N = 15, rotation = timeout / SI / N = 0，即此定时器被放置于15槽的链表后，至于是链表头插还是尾插这个随意，指针滴答到了15槽即触发15槽到时，遍历15槽链表，若rotation=0的表示为当前该触发定时器，若rotation&gt;0的定时器对rotation–（其实很好理解，cur_slot在转当前轮，则不处理后面的轮，只对它的rotation减一就跳过，等到cur_slot转下一圈再判断此定时器）。根据这个计算，如果其它参数不变，现在有一个timeout=161s的定时器，cur_slot=5,我们可以计算出这个定时器的slot=15，rotation=1，正好处于第15槽，但是是下一转触发该触发。 也就是说，如果我们根据以上参数，同时添加一个15s和一个161s定时器，他们都会随时间轮轮转触发到，只不过指针第一次只想15槽时，判断15s的定时器rotation为0，则触发定时器，然后删除定时器，遍历到161s定时器时，rotation=1，执行减1，跳过继续轮转，当cur_slot=70的时候也就是时间轮走过652=130s时，时间轮转一圈，cur_slot=0，继续下一圈开始，再走过142=28s后，到达15槽，判断161s定时器，rotation=0，触发定时器。 有了这些分析，下面直接贴代码： #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;time.h&gt; #include &lt;unistd.h&gt; #include &lt;signal.h&gt; #include &lt;stdlib.h&gt; typedef struct client_data { int fd; time_t tt; char buf[512]; void* data; }client_data; typedef struct tw_timer { //处于时间轮第几转，即时间轮转多少转 //此定时器可以处于当前转，若再加上槽 //即可确定此定时器所处时间轮位置 int rotation; //处于当前时间轮转的第几个槽 int slot; //定时器到时执行的回调函数 void* (*cb_func)( void* param ); //用户数据，触发回调任务函数的参数 struct client_data c_data; //这里只需要单向不循环链表即可 //struct tw_timer* prev; struct tw_timer* next; }tw_timer; typedef struct timer_manager { //时间轮当前槽，每经过一个间隔时间，加一实现轮转动， //超过总槽数即归零表示当前轮转完 int cur_slot; //时间轮一转的总槽数，总槽数越大槽链表越短，效率越高 int slot_num_r; //相邻时间槽间隔时间，即时间轮转到下一个槽需要时间， //间隔时间越短，精度越高，例如10s，表示定时器支持10s //间隔定时器添加，最小支持1s int slot_interval; //每个时间槽链表头结点，即一个槽管理一条链表，链表 //添加相同槽数的结点，但转数可能不同 struct tw_timer* slots_head[512]; }timer_manager; timer_manager tmanager; void* ontime_func( void* param ) { client_data* data = (client_data*)param; time_t tt = time(NULL); printf(&quot;\\n----------------------------------------------------\\n&quot;); printf(&quot;\\tontime,interval:%d\\n&quot;, (int)(tt - data-&gt;tt)); printf(&quot;\\told time:%s&quot;, ctime(&amp;data-&gt;tt)); printf(&quot;\\t%s&quot;, data-&gt;buf); printf(&quot;\\tcur time:%s&quot;, ctime(&amp;tt)); //getchar(); printf(&quot;----------------------------------------------------\\n&quot;); return NULL; } int add_timer( timer_manager* tmanager, int timeout, client_data* c_data ) { if ( timeout &lt; 0 || !tmanager ) return -1; int tick = 0; //转动几个槽触发 int rotation = 0; //处于时间轮第几转 int slot = 0; //距离当前槽相差几个槽 if ( timeout &lt; tmanager-&gt;slot_interval ) tick = 0; else tick = timeout / tmanager-&gt;slot_interval; rotation = tick / tmanager-&gt;slot_num_r; slot = ( tmanager-&gt;cur_slot + tick % tmanager-&gt;slot_num_r ) % tmanager-&gt;slot_num_r - 1; printf(&quot;addtimer--&gt;timeout:%d, rotation:%d,slot:%d\\n&quot;, timeout, rotation, slot); tw_timer* tmp_t = (tw_timer*)malloc(sizeof(tw_timer)); tmp_t-&gt;rotation = rotation; char buf[100] = {0}; time_t tt = time(NULL) + timeout; sprintf( buf, &quot;set time:%s&quot;, ctime(&amp;tt)); memset( tmp_t-&gt;c_data.buf, 0, sizeof(tmp_t-&gt;c_data.buf)); strcpy( tmp_t-&gt;c_data.buf, buf ); tmp_t-&gt;slot = slot; tmp_t-&gt;c_data.tt = time(NULL); tmp_t-&gt;cb_func = ontime_func; if ( !tmanager-&gt;slots_head[slot] ) { tmanager-&gt;slots_head[slot] = tmp_t; tmp_t-&gt;next = NULL; //printf(&quot;[line]:%d\\n&quot;, __LINE__); return 0; } //printf(&quot;[line]:%d\\n&quot;, __LINE__); tmp_t-&gt;next = tmanager-&gt;slots_head[slot]-&gt;next; tmanager-&gt;slots_head[slot]-&gt;next = tmp_t; return 0; } int del_all_timer( timer_manager* tmanager ) { //清除、释放所有定时器，懒得写了 } int tick( timer_manager* tmanager ) { if ( !tmanager ) return -1; tw_timer* tmp = tmanager-&gt;slots_head[tmanager-&gt;cur_slot]; tw_timer* p_tmp; while ( tmp ) { //rotation减一，当前时间轮转不起作用 //假设这个tmp指向第0个槽的头，链中某个结点的rotaion为下一圈， //即rotation=1，所以这个定时器不起作用，而因为cur_slot不断 //走动，tmp在当前转不可能再指向这个定时器，下一圈cur_slot //为0时能继续判断这个定时器，故实现了定时器处于不同转的判断 if ( tmp-&gt;rotation &gt; 0 ) { tmp-&gt;rotation--; p_tmp = tmp; tmp = tmp-&gt;next; } else { //否则定时器到时，触发回调函数 tmp-&gt;cb_func( &amp;tmp-&gt;c_data ); //删除此定时器结点 //吃了没用双向链表的亏，写这么low if ( tmp == tmanager-&gt;slots_head[tmanager-&gt;cur_slot] ) { //printf(&quot;[line]:%d\\n&quot;, __LINE__); tmanager-&gt;slots_head[tmanager-&gt;cur_slot] = tmp-&gt;next; p_tmp = tmp; tmp = tmp-&gt;next; free( p_tmp ); p_tmp = NULL; p_tmp = tmp; //printf(&quot;[line]:%d\\n&quot;, __LINE__); } else { p_tmp-&gt;next = p_tmp-&gt;next-&gt;next; free( tmp ); tmp = NULL; tmp = p_tmp-&gt;next; } } } //更新时间轮，转动一个槽，转一圈又从开始转 tmanager-&gt;cur_slot = ++tmanager-&gt;cur_slot % tmanager-&gt;slot_num_r; return 0; } int init_t_manager( timer_manager* tmanager, int slot_num_r, int slot_interval ) { tmanager-&gt;cur_slot = 0; tmanager-&gt;slot_num_r = slot_num_r; tmanager-&gt;slot_interval = slot_interval; return 0; } //自己试着写的调用层代码 void alarm_handler( int sig ) { time_t tt = time(NULL); //printf(&quot;timer tick:%s&quot;, ctime(&amp;tt)); int ret = tick( &amp;tmanager ); if ( ret &lt; 0 ) printf(&quot;tick error\\n&quot;); alarm( tmanager.slot_interval ); } int main() { time_t tt = time(NULL); signal( SIGALRM, alarm_handler ); //init_t_manager( &amp;tmanager, 60, 10 ); init_t_manager( &amp;tmanager, 60, 1 ); add_timer( &amp;tmanager, 6, NULL ); add_timer( &amp;tmanager, 11, NULL ); add_timer( &amp;tmanager, 22, NULL ); add_timer( &amp;tmanager, 33, NULL ); add_timer( &amp;tmanager, 44, NULL ); add_timer( &amp;tmanager, 55, NULL ); add_timer( &amp;tmanager, 66, NULL ); add_timer( &amp;tmanager, 77, NULL ); add_timer( &amp;tmanager, 88, NULL ); add_timer( &amp;tmanager, 99, NULL ); add_timer( &amp;tmanager, 111, NULL ); add_timer( &amp;tmanager, 122, NULL ); add_timer( &amp;tmanager, 133, NULL ); add_timer( &amp;tmanager, 144, NULL ); printf(&quot;start time:%s\\n&quot;, ctime(&amp;tt)); alarm( tmanager.slot_interval ); while ( 1 ) sleep( 5 ); return 0; } 看以上代码，main函数开始即指定了SI=1s，N=60，并添加了很多定时器，然后开始以SI执行定时，每一次到时就触发滴答函数tick()，如此循环定时触发到时信号就实现了时间轮轮转。 关于代码的思考：这里用了SIGALRM信号，每一次到时，主线程暂停，去执行信号函数内容，如果信号SIGALRM的处理函数太庞大，会影响主线程的任务卡顿，虽然以上代码执行量不大，但为了扩展，我觉得可以将定时器触发执行的操作改为添加任务结点到任务链，这样配合线程池效率会高一点，线程池本身会从任务链取任务结点执行，如果我们的定时处理函数只是往任务链放任务，那性能会高很多，而不是往cb_func里执行具体业务逻辑。 下一篇上时间堆。","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"}]},{"title":"Linux daemon守护进程的创建","slug":"004deamon/index","date":"2018-06-14T13:31:50.000Z","updated":"2018-06-15T01:39:24.792Z","comments":true,"path":"2018/06/14/004deamon/index/","link":"","permalink":"http://yoursite.com/2018/06/14/004deamon/index/","excerpt":"","text":"今天在看《UNIX网络编程》的时候，看到了守护进程的创建，代码中fork了两次，并且第一次fork后对子进程调用setsid()，有些懵。当时搜了下setsid也是看得有点云里雾里。后来折腾了一下午，才算有点明白，这里把自己的一点分析心得写上来，以后忘了可以翻翻： 这里我用ssh登陆ubuntu，在终端用vim编写。 第一次fork我们先写一个简单的代码来fork并创建一个后台程序，代码如下： //testdaemon1.c #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;signal.h&gt; int main() { pid_t pid; if ( (pid = fork()) &lt; 0 ) return -1; else if ( pid ) exit( 0 ); signal( SIGHUP, SIG_IGN ); int i = 10; while ( i-- ) sleep( 5 ); return 0; } 编译gcc -o testdaemon1 testdaemon1.c运行./testdaemon1 然后我们用ps查看程序:ps axjf | grep testdaemon1 1 28511 28510 28168 pts/18 28168 S 0 0:00 ./testdaemon1 这里看第二列是进程id(28511)，第四列是sessionId(28168)，第五列是控制终端(pts/18)，代码中子进程fork而来，会默认继承父进程的控制终端以及会话组。而如果我们查看linux后台守护进程的话，会发现进程控制终端为“？”，因此这个代码距离标准的守护进程还有距离，后面逐一分析。 什么是会话session呢？我大概的理解就是linux下进程组织结构分很多会话，一个会话有很多进程，会话的首进程会有一个控制终端，一个会话只能有一个控制终端。而我们现在用ssh登陆ubuntu创建了一个会话，此会话首进程id号就是28168,如果我们运行ps aux | grep 28168会输出下面值: root 28168 0.0 0.4 6904 4640 pts/18 Ss+ 16:06 0:00 -bash 可以看到这个进程是 bash进程shell终端，其控制终端是pts/18，此后我们在此终端运行的进程都属于以这个首进程id为sessionId的会话组，我们可以运行一个后台的top程序:top &amp;ps axjf | grep top得到下面输出： 28168 28670 28670 28168 pts/18 28672 T 0 0:00 _ top 再看28168的会话组： ps axjf | grep 28168得到下面输出： 28141 28168 28168 28168 pts/18 28693 Ss 0 0:00 _ -bash 28168 28670 28670 28168 pts/18 28693 T 0 0:00 _ top 28168 28693 28693 28168 pts/18 28693 R+ 0 0:00 _ ps axjf 28168 28694 28693 28168 pts/18 28693 S+ 0 0:00 _ grep –color=auto 28168 1 28691 28690 28168 pts/18 28693 S 0 0:00 ./testdaemon1 可以看到运行的几个后台程序sid都是28168。 说了这么多，这个会话组有什么作用呢？我们就要提到SIGHUP信号了，SIGHUP信号会在终端关闭时或者会话首进程退出时发送给会话组的其它进程，当其它进程收到此信号时如果不捕获或者忽略信号的话，默认会退出。如果现在点击ssh窗口的×关闭终端界面或者kill -9 28618的话，下面所属的进程都会退出。 因此，我们在代码中要调用setsid()，将子进程与父进程会话分离、终端分离，我们加入setsis再编译执行： ./testdaemon1执行ps axjf | grep testdaemon1 1 28891 28891 28891 ? -1 Ss 0 0:00 ./testdaemon1 看到其所属会话组已经变成新的（它自己为首进程）会话组，而终端也变为？，这正是我们看linux下其他守护进程的状态。 第二次fork第一次fork还不够，因为我们setsid之后，第一子进程变为新会话首进程，它有权限重新申请打开一个终端，为了避免这种情况，可以通过使进程不再成为会话组长来禁止进程重新打开控制终端，这就需要第二次调用fork()函数 改变工作路径第二次fork之后，我们在第二子进程里可以进行一些守护进程属性设置了， 改变工作路径可以用chdir(“/”)，为什么要改变工作路径呢？《unix网络编程》中Stevens大神说得很清楚，这里搬过来“守护进程可能是在某个任意的文件系统中启动，如果仍然在其中，那么该文件系统就无法拆卸(unmounting)，除非使用潜在的破坏性的强制措施。” 关闭所有打开的文件描述符守护进程从执行它的进程(当前的shell)继承所有打开的描述符。但没有现成的函数提供来检测打开的文件描述符，Stevens大神的解决办法是关闭前64个，而我在网上找到的有用getdtablesize()，有用NOFILE宏(sys/param.h)的，我的ubuntu前者为1024，后者为256，也不想去深究了。 重定向stdin、stdout、stderr上一步关闭了0开始的描述符，而stdin stdout stderr分别对应0 1 2，因此关闭之后如果不进行重定向，守护进程分配文件描述符会从0开始，因此stevens大神打开/dev/null三次，分配了三次描述符，分别为012，都对应/dev/null #贴上整个代码吧（跟《UNIX网络编程》里代码有些出入，某些东西也懒得深究了）： #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;signal.h&gt; int main() { pid_t pid; //原代码的fork用的封装函数Fork，其实多了对fork查错 if ( (pid = fork()) &lt; 0 ) return -1; else if ( pid ) exit( 0 ); setsid(); //原代码用的封装函数Sianal，这里懒得写了 //父进程退出，会给所有子进程发一个SIGHUP信号，进程接收到此信号如果不做捕获处理默认会退出 signal( SIGHUP, SIG_IGN ); if ( (pid = fork()) &lt; 0 ) return -1; else if ( pid ) exit( 0 ); //daemon_proc = 1;//原代码有这句 chdir(&quot;/&quot;); int i = 0; for ( ; i &lt; 64; i++ ) close( i ); open(&quot;/dev/null&quot;, O_RDONLY); open(&quot;/dev/null&quot;, O_RDWR); open(&quot;/dev/null&quot;, O_RDWR); //原代码有这句，就是往syslog里写运行本程序的日志，加上进程id，输出等级为facilit(LOG_WARN这样子) //openlog(pname, LOG_PID, facility); return 0; }","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"编译60个小程序之makefile","slug":"003makefile/index","date":"2018-06-13T19:39:08.000Z","updated":"2018-06-14T07:42:09.756Z","comments":true,"path":"2018/06/14/003makefile/index/","link":"","permalink":"http://yoursite.com/2018/06/14/003makefile/index/","excerpt":"","text":"公司有个任务需要编译60个c语言小程序，工程目录结构为： src：放所有小程序源文件.c drv：所有小程序编译后都为对应.drv 其它头文件、库目录省略。 makefile不太熟，也很菜，我第一想法是用for循环进行循环编译，还用到了makefile自定义函数，贴代码： CC = arm-linux-gcc CFLAGS +=-Wall -O -D_REENTRANT -fpic -shared LDFLAGS += -L./lib -lutility -lcrc -lmxml -lserial -lsocket -lpthread ROOT_DIR = $(shell pwd) SRC_DIR = ./src DRV_DIR = ./drv #src/*.c SRC := $(wildcard ${SRC_DIR}/*.c) SRC1 := $(notdir $(SRC)) ALL_NAME := $(basename ${SRC1}) #自定义了一个compile_file函数 define compile_file $(CC) $(CFLAGS) -o $1 $2 $(LDFLAGS) endef default: for name in $(ALL_NAME); do \\ #这里调用自定义函数，传输两个参数:一个drv/xx.drv，一个src/xx.c ${call compile_file, $(DRV_DIR)/$$name.drv, $(SRC_DIR)/$$name.c}; done clean: rm -f $(DRV_DIR)/*.drv 编译的效果是将所有的小程序都编译一遍，不管有没有出错，不管是否为最新。我需要的效果是编译所有程序，编译到哪一个出错即停止，编译前还要检查目标文件和源文件的更新时间，因此这个makefile不好用，只是学习了一下makefile的循环和自定义函数。 然后又构思makefile该如何写，就在思考的过程中想起来了学裸机程序时工程有一个.S和一个.c文件的编译，再结合makefile的伪目标，结构就很清晰了，这里用一个变量ALL_NAME表示获取到的所有src目录下的.c文件的名字替换为.drv（去除src/目录名和.c后缀，再补上drv/和.drv后缀，形式为drv/xxx.drv），代码忘了拷，贴部分自己能记住的吧： .PHONY:default clean default:$(ALL_NAME) $(DRV_DIR)/%.drv:$(SRC_DIR)/%.c $(CC) $(CFLAGS) -o $@ $&lt; $(LDFLAGS) clean: rm $(DRV_DIR)/*.drv -r 这个makefile就能满足之前的要求了。通过两个makefile的编写，学习了makefile的函数、自定义函数、循环、伪目标、makefile规则与shell规则的混合问题。","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"}]},{"title":"v4l2capture","slug":"002v4l2capture/index","date":"2018-06-13T13:38:53.000Z","updated":"2018-06-14T02:34:33.267Z","comments":true,"path":"2018/06/13/002v4l2capture/index/","link":"","permalink":"http://yoursite.com/2018/06/13/002v4l2capture/index/","excerpt":"","text":"虽然网上很多了，还是贴一下吧，自己刚入门的时候也是找苦逼很久找代码，代码我也是总结的。 1.v4l2.cvoid get_cam_info(struct camera *cam) { if(ioctl(cam-&gt;fd, VIDIOC_QUERYCAP, &amp;cam-&gt;cap) &lt; 0) { perror(&quot;query camera information error.\\n&quot;); exit(0); } if(!(cam-&gt;cap.capabilities &amp; V4L2_CAP_VIDEO_CAPTURE)) { printf(&quot;device is not a capture device.\\n&quot;); exit(0); } printf(&quot;\\nCapability Informations:\\n&quot;); printf(&quot;Driver Name:%s\\nCard Name:%s\\nBus info:%s\\nDriver Version:%u.%u.%u\\nCapabilities: %d\\n&quot;, cam-&gt;cap.driver,cam-&gt;cap.card,cam-&gt;cap.bus_info, (cam-&gt;cap.version&gt;&gt;16)&amp;0XFF, (cam-&gt;cap.version&gt;&gt;8)&amp;0XFF,cam-&gt;cap.version&amp;0XFF, cam-&gt;cap.capabilities ); } void get_cam_fmtdesc(struct camera *cam) { cam-&gt;fmtdesc.index = 0; cam-&gt;fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; while ((ioctl(cam-&gt;fd, VIDIOC_ENUM_FMT, &amp;cam-&gt;fmtdesc)) == 0) { printf(&quot;\\t%d.\\n\\t{\\n\\tpixelformat = &apos;%c%c%c%c&apos;,\\n\\tdescription = &apos;%s&apos;\\n \\t}\\n&quot;, cam-&gt;fmtdesc.index+1, cam-&gt;fmtdesc.pixelformat &amp; 0xFF, (cam-&gt;fmtdesc.pixelformat &gt;&gt; 8) &amp; 0xFF, (cam-&gt;fmtdesc.pixelformat &gt;&gt; 16) &amp; 0xFF, (cam-&gt;fmtdesc.pixelformat &gt;&gt; 24) &amp; 0xFF, cam-&gt;fmtdesc.description); cam-&gt;fmtdesc.index++; } } void set_cap_format(struct camera *cam) { memset(&amp;cam-&gt;format, 0, sizeof(cam-&gt;format)); cam-&gt;format.fmt.pix.width = cam-&gt;width; cam-&gt;format.fmt.pix.height = cam-&gt;height; cam-&gt;format.fmt.pix.pixelformat = cam-&gt;cap_format; //cam-&gt;format.fmt.pix.field = V4L2_FIELD_INTERLACED; cam-&gt;format.fmt.pix.field = V4L2_FIELD_ANY; cam-&gt;format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; if(ioctl(cam-&gt;fd, VIDIOC_S_FMT, &amp;cam-&gt;format) &lt; 0) { perror(&quot;set capture format error.\\n&quot;); exit(0); } } void get_cap_format(struct camera *cam) { struct v4l2_format fmt; struct v4l2_fmtdesc fmtdesc; fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; if(ioctl(cam-&gt;fd, VIDIOC_G_FMT, &amp;fmt) &lt; 0) { perror(&quot;get_cap_format:error.\\n&quot;); exit(0); } printf(&quot;\\nCurrent data format information:\\n width:%d\\n height:%d\\n&quot;, fmt.fmt.pix.width,fmt.fmt.pix.height); fmtdesc.index = 0; fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; while(ioctl(cam-&gt;fd, VIDIOC_ENUM_FMT, &amp;fmtdesc) != -1) { if(fmtdesc.pixelformat == cam-&gt;format.fmt.pix.pixelformat) { printf(&quot; format:%s\\n&quot;,fmtdesc.description); break; } fmtdesc.index ++; } } void get_framerate(struct camera *cam) { int ret; memset(&amp;cam-&gt;setfps, 0, sizeof(struct v4l2_streamparm)); cam-&gt;setfps.type = V4L2_BUF_TYPE_VIDEO_CAPTURE ; cam-&gt;setfps.parm.capture.capability = V4L2_CAP_TIMEPERFRAME; ret = ioctl(cam-&gt;fd, VIDIOC_G_PARM, &amp;cam-&gt;setfps); if(ret &lt; 0) { perror(&quot;get fps error.\\n&quot;); } printf(&quot; fps:%d\\n&quot;,cam-&gt;setfps.parm.capture.timeperframe.denominator); } void set_framerate(struct camera *cam) { int ret ; memset(&amp;cam-&gt;setfps, 0, sizeof(struct v4l2_streamparm)); cam-&gt;setfps.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; cam-&gt;setfps.parm.capture.timeperframe.numerator = 1; cam-&gt;setfps.parm.capture.timeperframe.denominator = 25; ret = ioctl(cam-&gt;fd, VIDIOC_S_PARM, &amp;cam-&gt;setfps); if(ret &lt; 0) { perror(&quot;set fps error.\\n&quot;); } } void req_buffer(struct camera *cam) { memset(&amp;cam-&gt;reqbuf, 0, sizeof(cam-&gt;reqbuf)); cam-&gt;reqbuf.count = cam-&gt;buf_num; cam-&gt;reqbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; cam-&gt;reqbuf.memory = V4L2_MEMORY_MMAP; if(ioctl(cam-&gt;fd, VIDIOC_REQBUFS, &amp;cam-&gt;reqbuf) &lt; 0) { perror(&quot;reqbuf error.\\n&quot;); exit(0); } } void init_mmap(struct camera *cam) { unsigned int i; for(i=0; i&lt;cam-&gt;buf_num; i++) { //memset(&amp;cam-&gt;buf, 0, sizeof(cam-&gt;buf)); cam-&gt;buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; cam-&gt;buf.memory = V4L2_MEMORY_MMAP; cam-&gt;buf.index = i; if(-1 == ioctl(cam-&gt;fd, VIDIOC_QUERYBUF, &amp;cam-&gt;buf)) { perror(&quot;ioctl querybuf error.\\n&quot;); exit(0); } cam-&gt;buffers[i].length = cam-&gt;buf.length; cam-&gt;buffers[i].start = (unsigned char *)mmap(NULL, cam-&gt;buf.length, PROT_READ | PROT_WRITE, MAP_SHARED, cam-&gt;fd, cam-&gt;buf.m.offset); if(MAP_FAILED == cam-&gt;buffers[i].start) { perror(&quot;mmap error.\\n&quot;); exit(0); } } } void start_capture(struct camera *cam) { unsigned int i; for(i=0; i&lt;cam-&gt;buf_num; i++) { //memset(&amp;cam-&gt;buf, 0, sizeof(cam-&gt;buf)); cam-&gt;buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; cam-&gt;buf.memory = V4L2_MEMORY_MMAP; cam-&gt;buf.index = i; if(-1 == ioctl(cam-&gt;fd, VIDIOC_QBUF, &amp;cam-&gt;buf)) { perror(&quot;start capture:video ioctl qbuf error.\\n&quot;); exit(0); } } if(-1 == ioctl(cam-&gt;fd, VIDIOC_STREAMON, &amp;cam-&gt;buf.type)) { perror(&quot;start capture:video ioctl streamon error.\\n&quot;); exit(0); } } int isHaveData(int fd) { fd_set fds; struct timeval tv; int r; FD_ZERO (&amp;fds);//将指定的文件描述符集清空 FD_SET (fd, &amp;fds);//在文件描述符集合中增加一个新的文件描述符 tv.tv_sec = 2; tv.tv_usec = 0; for (;;) //这一段涉及到异步IO { r = select (fd + 1, &amp;fds, NULL, NULL, &amp;tv);//判断是否可读（即摄像头是否准备好），tv是定时 if (-1 == r) { if (EINTR == errno) { printf(&quot;select err\\n&quot;); continue; } } if (0 == r) { fprintf (stderr, &quot;select timeout：%d\\n&quot;,errno); return 0; } return 1; } } int get_one_frame_buf(struct camera * cam) { int index ; if(isHaveData(cam-&gt;fd)) { memset(&amp;cam-&gt;buf, 0, sizeof(cam-&gt;buf)); cam-&gt;buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; cam-&gt;buf.memory = V4L2_MEMORY_MMAP; if(ioctl(cam-&gt;fd, VIDIOC_DQBUF, &amp;cam-&gt;buf) &lt; 0) { perror(&quot;get one frame buffer:video ioctl dqbuf error.\\n&quot;); exit(0); } assert(cam-&gt;buf.index &lt; cam-&gt;buf_num); index = cam-&gt;buf.index; //starter = (unsigned char *)buffers[cam-&gt;buf.index].start; if(ioctl(cam-&gt;fd, VIDIOC_QBUF, &amp;cam-&gt;buf) &lt; 0) { perror(&quot;get one frame buffer:video ioctl qbuf error.\\n&quot;); exit(0); } return index; } else { printf(&quot;get one frame buffer error.\\n&quot;); exit(0); } } void stop_capture(struct camera *cam) { if(-1 == ioctl(cam-&gt;fd,VIDIOC_STREAMOFF,&amp;cam-&gt;fmtdesc.type)) { perror(&quot;stop capture error.\\n&quot;); exit(0); } close(cam-&gt;fd); printf(&quot;stop capture successfully!\\n&quot;); } void Munmap(int req_num, struct mmap_buffer *buffers) { unsigned int i; for (i = 0; i &lt; req_num; ++i) if (-1 == munmap(buffers[i].start, buffers[i].length)) free (buffers); } 2.v4l2.h这里的h4all.h包含的库函数,动手man一下吧 :-D #ifndef _V4L2_UVC_H #define _V4L2_UVC_H #include &quot;h4all.h&quot; struct mmap_buffer{ void *start; size_t length; }; typedef struct camera{ int fd; //摄像头文件描述符 int width; int height; int cap_format; int buf_num; struct v4l2_capability cap; struct v4l2_fmtdesc fmtdesc; struct v4l2_format format; struct v4l2_streamparm setfps; struct v4l2_requestbuffers reqbuf; struct v4l2_buffer buf; struct mmap_buffer buffers[4]; }Camera; void get_cam_info(struct camera *cam); void get_cam_fmtdesc(struct camera *cam); void set_cap_format(struct camera *cam); void get_cap_format(struct camera *cam); void get_framerate(struct camera *cam); void set_framerate(struct camera *cam); void req_buffer(struct camera *cam); void init_mmap(struct camera *cam); void start_capture(struct camera *cam); int get_one_frame_buf(struct camera * cam); void stop_capture(struct camera *cam); void Munmap(int req_num, struct mmap_buffer *buffers); void Init_v4l2(struct camera *cam); #endif 3.初始化：main.c#define DRIVER &quot;/dev/video2&quot; #define WIDTH 176 #define HEIGHT 144 #define CAP_FORMAT V4L2_PIX_FMT_YUYV #define REQ_BUFFER 4 Camera *cam; struct mmap_buffer buffers[REQ_BUFFER]; cam = (Camera *)malloc(sizeof(Camera)); void set_cam(Camera *cam, const char *driver_path, int width, int height, int format, int req_num) { cam-&gt;fd = Open(driver_path); cam-&gt;width = width; cam-&gt;height = height; cam-&gt;cap_format = format; cam-&gt;buf_num = req_num; } 4.获得数据调用v4l2_uvc.c的get_one_frame_buf(cam),用int型的index接收返回值，即是目前获得的底几个缓冲区的索引值，cam-&gt;buffers[index].start即是指向那段数据内存，cam-&gt;buffers[index].length即是大小 注：当然，还有什么设置伽马值、曝光度这些套路跟上面差不多，可以百度一下，作为函数补充进去","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"摄像头","slug":"摄像头","permalink":"http://yoursite.com/tags/摄像头/"}]},{"title":"yuv422转换为yuv420p","slug":"001yuv422toyuv420p/index","date":"2018-06-12T14:25:24.000Z","updated":"2018-06-14T02:34:33.271Z","comments":true,"path":"2018/06/12/001yuv422toyuv420p/index/","link":"","permalink":"http://yoursite.com/2018/06/12/001yuv422toyuv420p/index/","excerpt":"","text":"今天遇到一个问题，我的摄像头采集到的数据是yuyv格式(属于yuv422)，而X264在进行编码的时候需要标准的YUV（4：2：0）。所以有一个yuv422toyuv420的转换。在网上找了半天找到的方法拿过来转换了查看都很花。于是自己看了一下yuv格式的解释，准备写一个转换代码。以下许多解释都是按我的理解： 1.yuvyuv格式通常有两大类：打包(packed)和平面(planar)格式。前者在码流里是yuv挨一起，比如我的yuyv就是 Y0 U0 Y1 V1 Y2 U2 …. 每一个 Y对应一组UV分量。后者存储y u v分量是分开存储的，这种方式一般后面带P， 比如y uv420p就是Y0 Y1 Y2 … U0 U1 U2 … V0 V1 V2 … uv分量的多少根据格式来，yuv420也就是每四个 Y共用一组UV分量。 2.转换理解了yuyv即yuv422与yuv420p中分量的排布，就要进行转换了。网上查到的资料说yuv422-&gt;yuv420p时 丢弃偶数行的uv分量。 3.编码定义： unsignedchar *y = out; unsignedchar *u = out + width*height; unsigned char*v = out + width*height + width*height/4; y u v分别指向yuv420buf中存储y u v分量的数组，这里out的类型为char型数组，按yuv420p的定义，4个y共用一对uv，那么一个y对应1/4个uv，一个分量占一个byte，out的大小为：总共的y分量(widthheight) + 总共的u分量(widthheight/4) + 总共的v分量(widthheight/4) = widthheight*3/2。通过上面的转换也可以得到yuyv(yuv422)一个像素占用2个字节，yuv420p一个像素占1.5个字节，rgb24的话占用3个字节，还是节约了一点点空间的。。。 获取y分量并存储到yuv420buf中： for(i=0; i&lt;yuv422_length; i+=2){ *(y+y_index) = *(in+i); y_index++; } 这里的yuv422_length为width*height*2;y_index初始为0，存储一个y就自加一次。 获取uv分量并存储到yuv420buf中： for(i=0; i&lt;height; i+=2){ base_h = i*width*2; for(j=base_h+1;j&lt;base_h+width*2; j+=2){ if(is_u){ *(u+u_index)= *(in+j); u_index++; is_u = 0; } else{ *(v+v_index)= *(in+j); v_index++; is_u = 1; } } } 总结：初入视频图像，我还是一个菜鸟，对于很多理解也不深，这个代码应该还有很多没考虑，对于我可用了。当然以上都是废话，直接贴代码 int yuv422toyuv420(unsigned char *out, const unsigned char *in, unsigned int width, unsigned int height) { unsigned char *y = out; unsigned char *u = out + width*height; unsigned char *v = out + width*height + width*height/4; unsigned int i,j; unsigned int base_h; unsigned int is_y = 1, is_u = 1; unsigned int y_index = 0, u_index = 0, v_index = 0; unsigned long yuv422_length = 2 * width * height; //序列为YU YV YU YV，一个yuv422帧的长度 width * height * 2 个字节 //丢弃偶数行 u v for(i=0; i&lt;yuv422_length; i+=2){ *(y+y_index) = *(in+i); y_index++; } for(i=0; i&lt;height; i+=2){ base_h = i*width*2; for(j=base_h+1; j&lt;base_h+width*2; j+=2){ if(is_u){ *(u+u_index) = *(in+j); u_index++; is_u = 0; } else{ *(v+v_index) = *(in+j); v_index++; is_u = 1; } } } return 1; }","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"摄像头","slug":"摄像头","permalink":"http://yoursite.com/tags/摄像头/"}]}]}