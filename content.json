{"meta":{"title":"My Blog","subtitle":"我的小站","description":"学不见其长，但日有所增","author":"lkness","url":"http://lkness"},"pages":[{"title":"categories","date":"2018-06-13T14:13:04.000Z","updated":"2018-06-19T02:02:56.175Z","comments":false,"path":"categories/index.html","permalink":"http://lkness/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-06-13T14:08:29.000Z","updated":"2018-06-19T02:02:56.147Z","comments":false,"path":"tags/index.html","permalink":"http://lkness/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【从零开始构建erlang服务器】-01网络库","slug":"032build-erlang-server01/index","date":"2018-06-20T12:38:16.000Z","updated":"2018-06-20T12:45:02.351Z","comments":true,"path":"2018/06/20/032build-erlang-server01/index/","link":"","permalink":"http://lkness/2018/06/20/032build-erlang-server01/index/","excerpt":"","text":"简介 网络库是服务器的基础。有了网络库，服务器就能接收外界消息，提供服务。因此开始就从网络库入手。这里先构建基础的TCP通信网络库。至于UDP、WebSocket这些通信手段暂不说。 gen_tcp erlang的底层是c语言封装的，因此其socket通信在beam层也是经过封装的，更易使用。告别跟系统绑定的select/poll/epoll/iocp/kqueue的复杂操作，我们只需要根据gen_tcp的官方文档，就能构建简单好用的tcp服务器。 惊群效应 惊群效应就是多进程或多线程同时阻塞等待相同事件时，假如事件不阻塞而是返回结果了，那么所有阻塞的进程或线程就会唤醒，但是却只有一个进程或线程能获得这个时间的“控制权”，对该事件进行处理，而其它竞争失败的就只能重新休眠。这样多个进程或线程同时唤醒但大部分都做无用功，cpu上下文白切换。 比较典型的就是accept函数。 例如linux的socket监听套接字创建流程是： int socket(int domain, int type, int protocol) //指定协议版本(IPv4/IPv6)，指定通信类型(TCP/UDP/RAW) int bind(int socket, const struct sockaddr *address, socket_t address_len) // 将socket套接字绑定到一个网卡 int listen(int socket, int backlog) // 将socket套接字转变为连接套接字 int accept(int socket, struct sockaddr , socklen_t ) // 监听一个客户端的连接 第1、2步没什么好说，第3步的listen，需要指定一个backlog参数，何谓backlog？linux内核对于tcp三次握手，维护了两个队列，一个用于客户端请求握手的队列，一个用于完成了握手的队列。客户端完成了握手，就从第一个队列转移到第二个队列如果accept接受了请求，就将握手的客户端从第二个队列删除，那么backlog就指定第二个队列的长度。可见，如果客户端connect并发太多间隔太短，而accept的接受速度如果太慢，backlog到了最大长度，就会对新到来的客户端响应RST分节，可见的抓包握手消息就是（三次握手在第一步“你好在吗”就返回错误了）： client-&gt;server : SYN server-&gt;client : RST 个人猜测，未去证实： 因此可以增大backlog的数量，也可以多几个acceptor来做监听。才有了用多进程、多线程来做accept操作。不过linux2.6内核以后，就改善了accept的惊群问题，多个acceptor。 gen_tcp:accept/2gen_tcp的核心函数我觉得就是accept，正如官方文档上写的： The accept call does not have to be issued from the socket owner process. Using version 5.5.3 and higher of the emulator, multiple simultaneous accept calls can be issued from different processes, which allows for a pool of acceptor processes handling incoming connections. 文档明确说了可以用多个acceptor来针对同一个监听套接字做客户端监听。 （底层也只有一个OS线程做accept，可能给多个做accept的erlang轻进程做竞争，accept返回即选择一个轻进程分发clientfd，参见https://github.com/alibaba/erlang_multi_pollset) 简单tcp服务器代码官方文档的一个简单实现： start(Num,LPort) -&gt; case gen_tcp:listen(LPort,[{active, false},{packet,2}]) of {ok, ListenSock} -&gt; start_servers(Num,ListenSock), {ok, Port} = inet:port(ListenSock), Port; {error,Reason} -&gt; {error,Reason} end. start_servers(0,_) -&gt; ok; start_servers(Num,LS) -&gt; spawn(?MODULE,server,[LS]), start_servers(Num-1,LS). server(LS) -&gt; case gen_tcp:accept(LS) of {ok,S} -&gt; loop(S), server(LS); Other -&gt; io:format(&quot;accept returned ~w - goodbye!~n&quot;,[Other]), ok end. loop(S) -&gt; inet:setopts(S,[{active,once}]), receive {tcp,S,Data} -&gt; Answer = process(Data), % Not implemented in this example gen_tcp:send(S,Answer), loop(S); {tcp_closed,S} -&gt; io:format(&quot;Socket ~w closed [~w]~n&quot;,[S,self()]), ok end. 这个代码就是启动Num数量个acceptors来做客户端连接监听，但是这个代码效率不高，这里的acceptor即做accept工作，又做客户端任务处理的逻辑，既是acceptors pool，也是worker pool，如果客户端请求的服务器任务处理时间太长的话，当前处理进程的accept工作也一起阻塞在那里。 优化accept 这里要提到erlang socket套接字的归属权，初始时只有做accept的进程有权处理返回的socket消息，因此我们上面第四步才能直接在loop函数里receive {tcp, S, Data}处理，但也因此带来了阻塞acceptor的风险。 如果可以转让归属权，是不是我们就能解放acceptor的工作，它只需要做单一的accept工作，一旦有客户端连接，返回了客户端套接字，我们就将归属权转让给其它进程去处理今后所有客户端的请求服务器？ 是的。这个函数就是gen_tcp:controlling_process/2。有了这个函数，我们就可以解放acceptor的工作。将socketFd交给其它worker进程去处理。 tcp调参经过上面步骤，初步的监听框架有了，并且可以启动很多acceptors来做accept工作，beam以上的accept性能似乎已经没有问题了（只有beam虚拟机用单个OS thread做connect事件监听可能会影响速度，不过我们只需要做好我们代码能做到的就可以了，multi-pollset会在20.3之后某个版本发布）。 余下的工作就是tcp调参了。 众所周知，tcp是个全双工可靠通信，为了实现这个特性，tcp底层实现用了很多算法来支撑、优化tcp。 例如小块数据发送策略-Nagle算法、成块数据流发送策略-滑动窗口、慢启动、超时与重传、发送定时器、keepalive定时器、tcp状态转换等等。 因此，在os系统调用层就能优化很多操作，而beam又在系统api上面封装了socket操作，也会加一些erlang的tcp特性参数。 这里大概说一下重要的一些参数，其它的请参考官方文档： http://erlang.org/doc/search/?q=meck&amp;x=0&amp;y=0?q=meck&amp;x=0&amp;y=0 backlog上文有提到，是一个完成三次握手但还没有被应用层accept的客户端请求最大数量 nodelaytcp对待小块数据，是先缓存起来不立即发送（如果小块数据也默认发送，可能会造成广域网消息拥塞），等到数据量多一点再一起发，这个就是tcp的Nagle算法。而要不延迟发送的服务器可以设置为true，例如telnet客户端、ssh客户端等，按一个键盘按键就要发送一个按键字母。 active分为三种模式： true-非阻塞，tcp消息会以{tcp, Socket, Data}的进程普通消息发到socket套接字归属进程 false-阻塞，必须显式调用gen_tcp:recv/2来接收消息 once-半阻塞（官方推荐的方式），这种模式是非阻塞的接收一个消息，但是在收到一个消息后，必须再次调用inet:setopts(Socket, [{active, once}])来重新设置才能再接收到消息 （这个的作用是，单纯用true模式太粗暴，如果收速小于发速，beam要盲目接收外界消息 然后转换成进程消息，很容易被大量的数据撑爆进程邮箱，而如果用false模式阻塞接收， 进程必须自己做recv后的逻辑处理，处理完毕又自己做轮询recv，让消息处理变得复杂， 因此有了once模式，即有true模式的消息事件触发方式，又有false模式的消息限速安全性） reuseaddrTCP四次挥手过程中，先发起关闭连接的一方会进入TIME_WAIT状态。TIME_WAIT是指四次挥手中主动方最后一次接收到对方的关闭请求后，自己响应了ACK消息后等待2MSL(最大报文生存时间Maximum Segment Lifetime，一个MSL可能是30s 1m 2m)才能关闭本端。原因是：tcp作为全双工的管道，关闭时也要实现全双工，即双方明确知道都关闭了管道。因此在先发起关闭的一方最后一次响应ACK后要等待对方告诉自己它已经收到ACK消息，而不是说这个ACK消息在还没被对方收到就失去了，如果对方没有收到，就要重新发送ACK，这才是可靠关闭的实现。而这个2MSL期间，再想重新启动这个端口的监听模式是错误的。 举个例， 如果设置不能重用地址， 服务器程序打开了端口8888，这时候遇到一个错误，服务器宕了，监控程序立马检测到服务器宕了，执行重启服务器逻辑，却发现一直重启不了，直到2MSL过了。 编写网络库根据以上总结，我们可以容易编写一个简单网络库，支持大量连接，但一个工业强度网络库的诞生，必然伴随着大量测试的千锤百炼。 这里我实现了一个简单的网络库，还没有测过客户端异常关闭等等socket套接字管理问题：https://github.com/xlkness/erlnet 因此我们编写网络库，只是做一个学习作用，知道网络库的作用，如何并发连接，消息并发接收等等，因为网络库的重要性，有了网络库，才能进行接下来的协议层，才能针对客户端请求消息提供对应的服务，有了服务才会根据服务器进行更深的业务和方案选择。 真正的使用还是寻找一些开源的网络库，例如ranch： https://github.com/ninenines/ranch","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"Erlang","slug":"Erlang","permalink":"http://lkness/tags/Erlang/"}]},{"title":"paxos-simple","slug":"031paxos/index","date":"2018-06-20T12:25:06.000Z","updated":"2018-06-20T12:37:55.248Z","comments":true,"path":"2018/06/20/031paxos/index/","link":"","permalink":"http://lkness/2018/06/20/031paxos/index/","excerpt":"","text":"上周给组里分享课程，其中讲到了paxos，觉得没讲好，遂决定看看paxos论文，看的时候有的枯涩的地方就翻译到文本里记录，翻译得越来越多，索性都翻译了吧 … 1. 介绍在实现一个容错分布式系统时，人们认为Paxos算法理解起来很困难，大概对于很多读者来说最初的陈述是用的希腊语。事实上，它是分布式算法中最简单也最明显的一种。 它本质上是一个共识算法-the “synod” algorithm of。下一节叙述了这种共识算法几乎不可避免地遵循我们想让它满足的属性条件。最后一节解释了完整的Paxos算法：通过简单的状态机的共识程序来构建一个分布式系统-这应该是被广为人知的，因为它在分布式系统理论文章中被引用最多的。 2. 一致性算法2.1 问题假设有一些进程可以提议values。一个共识算法可以保证在这些提议的values中只有一个value被选中。如果没有提议任何value，那么也没有任何value被选中。 如果一个value被选中了，那么这些进程应该能够学习这个被选中value。协商一致的安全性要求如下： 只能发起提议的value能被选中 只能有一个值被选中 并且一个进程只能获取到真正被选中的value 我们不用尝试指定精确的要求。但是目标是保证一些被提议的value最终会被选中，并且当一个value被选中，那么某个进程最终都能获取到这个value。 在共识算法中我们使用三个角色由三个种类代理：proposers、acceptors、learners（提议者、接受者、结果学习者）。在一个具体实现中，单个进程可能同时扮演多种代理，，但是从从代理到进程的映射关系我们并不关心。 假设这些代理能够通过发送消息相互交流。我们使用异步、非拜占庭模型： 这些代理的执行是任意速度的，也可能发生故障而停止，也可能重启。因为所有的代理都可能在选中一个value后发生故障并且重启，因此这些代理必须持久化一些信息，即使发生故障和重启（也能恢复） 发送的消息可以是任意长度的、可能重复、可能丢失，但是不能被篡改。 2.2 选中一个value最简单的方法是使用单个acceptor代理来选中一个值。某个proposer发送一个提议给acceptor，acceptor选择它接收到的第一条消息的value。虽然简单，但是这种方法不能满足我们的要求，因为假如acceptor发生故障，就会导致接下来的步骤失败。 因此，让我们尝试其它的方式来选择一个value。现在用多个acceptor代理来代替单个acceptor。某个proposer给这些acceptor都发送一个提议value。某个acceptor可能会接受这个value。那么这个value当足够数量的acceptor都接受这个value时，就能通过选中这次value了。多大的数量才足够？为了保证仅仅只有一个value被选中，我们让超过半数的acceptor作为这个足够大的数量。因为对于一个acceptor集合，其中任意两个超过半数的子集合至少有一个公共的acceptor。如果一个acceptor只能选中至多一个值，那么这种方法就是可行的。 在没有故障发生和消息丢失的情况下，我们想要让一个value被选中，哪怕仅仅只有单个proposer发起一次提议value。这就需要满足以下要求： P1: An acceptormust accept the first proposal that it receives. （一个acceptor必须接受它第一个收到的提议的value） 但是这个要求又引起一个问题。多个values可能同时被好几个不同proposers提议，导致了一种情形：每个acceptor都接收到value，但是没有一个value是被超过半数的acceptor所选中。即使只提出了两个提议value，如果每个value各自都被半数acceptor选中，那么任意单个acceptor故障都可能让leaner获取哪一个value被选中变为不可能。 P1规约以及一个value只有被超过半数acceptor所接受才算被选中这两个条件意味着一个acceptor必须能够接受多个提议。我们给不同的提议指定一个编号来追踪这些提议，因此一个提议就由提议号（proposal number）和value组成。为了防止冲突，我们要求不同的提议用不同的提议号。这个不同的提议号如何实现，依赖具体的实现，当前我们先假设它（已经实现）。如果一个提议的value被超过半数的acceptor所接受，那么这个value就被选中。这种情况下，我们就说这个提议被选中。 我们可以允许多个提议被选中，但是我们必须保证这些被选中的提议都拥有相同的value。通过归纳提议号，就足以保证： P2: If a proposal with value v is chosen,then every higher-numbered pro-posal that is chosen has value v. （如果一个value为v的提议被选中，那么其后每一个更高提议号的提议value也要是v） 因为提议号都是有序的，条件P2保证了关键的安全性属性：仅仅只有一个value能被选中。 为了被选中，一个提议必须被至少一个acceptor所接受。因此，我们能通过满足以下条件来满足P2： P2a: If aproposal with value v is chosen, then every higher-numbered pro-posal accepted by any acceptor has value v. （如果一个value为v的提议被选中，那么每个被acceptor所接受的具有更高提议号的提议的value也要是v） 我们依然需要P1来保证有提议能被选中。因为交流是异步的，一个提议可能被一些特殊的acceptor c所选中，但是它们没有接受过其它任何提议。假设一个新的proposer“醒过来（重启或从故障中恢复）”，然后发送了一个带有更高提议号且不同value的提议。P1只要求c接受这个提议，但是却违背了P2a。为了同时满足P1和P2a，需要加强P2a： P2b: If a proposal with value v ischosen, then every higher-numbered pro-posal issued by any proposer has value v. （如果一个value为v的提议被选中，那么所有发送具有更高提议号的proposer的value也是v） 因为一个提议在被acceptor接受之前必须是proposer发出，P2b满足了P2a，也满足了P2。 为了明白如何满足P2b，让我们思考如何证明它。我们假设有一些提议号为m，value为v的提议已经被选中，然后我们证明以后的任何提议号n（n&gt;m）的提议，其value为v。我们可以归纳法到n来简化证明，在这种假设下，我们就证明所有发起的提议号为m..(n-1)的提议，其value都为v，其中i..j表示提议号范围为i-j。既然提议号为m的提议被选中，那么必然有一个超过半数acceptors的集合C接受了它。与归纳假设结合，假设提议m被选中可以推论出： Everyacceptor in C has accepted a proposal with number in m ..(n − 1),and every proposal with number in m ..(n − 1) accepted by any acceptor has value v. （超半数集合C中的每一个acceptor都接受了一个提议号从m..(n-1)的提议，且每一个提议被接受时，value都为v） 因为任意超半数的acceptor集合S中，至少有一个是C的成员，我们可以得出结论，通过确保以下的条件来保持提议n的value为v： P2c:For any v and n, if a proposal with value v and number n is issued,then there is a set S consisting of amajority of acceptors such thateither (a) no acceptor in S has acceptedany proposal numbered less than n, or (b) v is the value of the highest-numbered proposal among all proposals numbered less than n acceptedby the acceptors in S. （对于任意的提议n和value v，如果一个提议号为n，value为v的提议产生了，那么就存在一个包含了超过半数acceptor的集合S，这个集合中要么没有acceptor批准过任意比n小的提议，要么v就是S中的acceptor选中的提议号小于n的最大编号提议所具有的value） 我们可以因此满足P2c来满足P2b。 为了满足P2c，一个proposer想产生一个提议n，它就必须获取提议号小于n且已经或将要被超过半数acceptor接受的最大提议的value。获取已经被接受过的提议是很简单的，但是预测将要被接受的结果就很困难。不用预测未来，proposer只要承诺自己不会获得这样的接受情况就可以了。换句话说，proposer请求所有acceptor不要接受任何比（它自己提议号）n小的提议。这就推导出一下算法来生成提议： 一个proposer选择新的提议号n，然后发送请求给所有acceptor，询问它回复如下内容： (a). 承诺不再接受比n小的提议 (b). 如果接受了小于n的提议，就返回接受的提议内容 我们称这样的请求为带有提议号为n的prepare请求 如果proposer接受到超过半数的acceptor响应，接下来它就能发出value为v的提议n，value v要么是响应的消息中acceptor接受过的最大提议号的value，要么是所有acceptor都还没接受value时proposer自己提议的value。 一个proposer发送提议消息给一些acceptor集合，请求它们接受。（这个集合不一定就是初始请求后响应了的acceptor集合）让我们称它为accept请求。 这个描述的是proposer的算法。Acceptor的算法呢？acceptor能接受两种请求：prepare请求和accept请求。一个acceptor能够在不影响安全性的条件下忽略任何请求。所以，我们只需要讨论它可以回复（proposer）请求的情况。它通常都能够响应一个prepare请求。如果acceptor没有承诺不接受某种提议，那么它就能响应这种提议，并接受它。换句话说： P1a:An acceptor can accept a proposal numbered n if it has not responded to a prepare request having a numbergreater than n. （一个acceptor如果没有响应比n大的prepare请求，它就能接受提议n） 可以看到P1a包含P1。 现在我们已经有了一个完整的并能满足安全性的算法来选中一个value—假设使用的都是唯一的提议编号的情况。最终的算法通过一点点的小优化来实现。 假设一个acceptor接收到一个prepare请求n，但是它早已响应过了比n大的prepare请求，因此它承诺不会接受任何提议n。acceptor也没有任何理由响应这次prepare请求，因此它不会接受提议n。我们就让acceptor忽略这种prepare请求。同时我们也让acceptor忽略早就被接受过的prepare请求。 经过这种优化，acceptor仅仅只需要记住它曾接受过的最大编号的提议和它响应过的最大编号的prepare请求。P2c必须被满足哪怕发生了故障，因此acceptor也必须记住这些信息即使发生了故障和重启。注意proposer可以丢弃一个提议然后忘掉所有信息，只要它不会又发送相同编号的提议。 将proposer和acceptor放在一起，我们可以得到算法操作分下面两阶段： 阶段1： 某个proposer选择一个提议号n，然后用提议号n发送一个prepare请求给超过半数的acceptor； 如果一个acceptor接收到提议号为n的prepare请求，且提议号n比它曾经响应过的提议号更大，那么它就响应proposer，响应内容是：保证不会接受任何比n更小的提议以及它曾经接受过的最大编号提议的value（如果有的话） 阶段2 如果proposer接收到超过半数的acceptor对于提议n的响应，那么它就给每个响应了的acceptor发送一个accept请求，提议号还是n，且value要么是那些acceptor响应消息里带有接受过的最大提议号的value，要么那些acceptor都没有接受任何提议，那value就是proposer自己任选； 如果一个acceptor接收到提议号为n的accept请求，它就会接受这次accept请求（并选中请求带有的value）除非它之前又响应过比n更高的prepare请求。 一个proposer可以产生多个提议，只要它能满足算法的每个要求。它也可以在协议进行到任何阶段任何时间丢弃提议。（正确性是能保证的，哪怕某个提议请求或者其响应消息可能在很久之后才到达目的地，而这之前这个提议就被丢弃了。）当有其它proposer已经开始用更高的提议号尝试发起投票了，放弃此次提议是个好主意。因此，如果一个acceptor因为它已经接受过更高提议号的提议而忽略当前prepare或accept请求时，它应该通知那个proposer让它放弃这次提议。这是一个并不影响正确性的优化点。 2.3 获取一个被选中的值（learner）为了习得一个被选中的value，一个learner必须找出被大多数批准者接受的那次提议。明显的算法是让每个acceptor无论什么时候选中了一个提议，就给所有learner响应那次提议的信息。这可以让learners尽快知道选中的value，但是这种方法需要每个acceptor给每个learner发送大量的消息。 非拜占庭模型（non-Byzantine model）错误的假设下，某个learner能够容易地从其它learner那里知道被选中的value。我们可以让acceptor响应批准的投票信息给distinguished learner（主学习者），然后distinguished learner再轮流响应给其它learner。这种方法需要额外一轮操作来让所有learner发现被选中的value。它也是不可靠的，因为distinguished learner可能会发生异常。并且它也需要acceptor的数量加上learner的数量这么多消息响应。 更普遍的做法是，acceptors可以响应它们的批准信息给部分被选中distinguishedlearners，每一个distinguished learner又能通知所有learner。如果distinguished learners的数量很多，这可以保证更好地可靠性，但也带来了交流复杂性上的消耗。 由于分布式中消息可能出现丢失，就可能出现一个提议被选中了但是没有learner知道这次投票结果。learners可以询问acceptors哪一个提案被选中了，假设出现了一个acceptor不知道是哪次提案被选中了或者没有提案出现了超过半数的投票。在这种情况下，只有新的一次提案被选中了，learners才能知道哪一个value被选中。如果一个learner需要知道一个value是否被选中，它可以让一个proposer发起一次这个value的提议。 2.4 过程保证我们可以简单构建一种情形：两个proposer不断地用更高的序号发起投票，但是没有一次投票被选中（活锁）。proposer p用提议号n1完成了阶段1(Phase 1)。接着另一个proposer q又用大于n1的提议号n2完成了阶段1(Phase1)。接着p开始进行阶段2(Phase 2)（因为阶段1用n1收到的超过半数响应因此可以进行阶段2），但是发送的accept请求没有收到响应或者收到的都是拒绝消息，因为n1编号小于此时acceptors维护的编号n2。因此，p又用新的编号n3发起投票，并完成阶段1。再来看proposer q，它当前完成了阶段1，然后发起第二阶段消息请求，但是收到了拒绝的响应（因为n2&lt;n3了），它又用n4发起新投票……如此往复。 为了保证过程（正常进行），必须要选一个distinguished proposer来发起提案。如果这个distinguished proposer能成功地跟超过半数acceptors交流，并且每次都使用比曾经使用的提议编号大的编号，那么它就能成功发起一次提议并被acceptors接受。当distinguished proposer知道自己（发起提议）的编号太低时，通过放弃提议并且重新（用更高的编号）尝试，最终选择一个足够高的编号。 2.5 实现Paxos算法假定一个有多个进程的网络。在它的共识算法中，每个进程同时扮演proposer、acceptor和learner。通过算法选择一个leader来作为distinguished proposer和distinguished learner。Paxos一致性算法正是上面描述的消息和请求都作为普通消息发送的确切实现算法。（响应消息也一样被标记上一致的提议编号来防止混淆。）当异常发生时，稳定的存储用来持久化批准者必须记住的信息。响应proposer之前，acceptor在存储系统中记录它准备要响应的消息。 最后剩下要做的就是描述如何避免两个提议用了两个相同的提议编号。如果不同的proposer从不相交的数字集合里选择他们的提议编号，那么两个提议绝不会产生相同编号的提议。每个proposer持久化它用过的最高的提案编号，然后在开始Paxos一阶段时就使用一个比用过的最高的提案编号更高的编号。 3. 实现一个状态机实现一个分布式系统的简单方式是（将分布式系统的节点）当做一批客户端，都产生命令到一个中央服务器。这个中央服务器能被描述为按某种顺序来执行客户端命令的一个确定性状态机。这个状态机有一个当前状态；它执行一步可以看作：输入一个命令-&gt;产生一个输出结果-&gt;切换到新状态。举个例，分布式银行系统的客户端可能是出纳员，系统里的状态机维护的状态信息可能包含所有用户的账户余额。那么一次提款就能描述为：仅当余额比提款额大时，执行“减少账户余额”的状态机命令-&gt;产生一个包含旧余额和新余额的结果。 仅使用单个中央服务器的实现会面临单点失效问题。因此用一批服务器来代替一个中央服务器，每个服务器都是一个独立的状态机。因为这些状态机是确定性的，如果它们接收并执行的指令序列都是相同的话，那么它们也会产生相同状态和输出结果。一个客户端产生一个状态机命令时就能使用任意一个中央服务器的结果。 为了保证所有的中央服务器执行相同序列的状态机命令，我们实现了由Paxos共识算法的单独实例组成的序列：序列中第i个投票的值就作为第i个状态机命令。每个服务器都扮演所有角色（proposer、acceptor、learner）。现在，我假定一组中央服务器已经确定，因此所有一致性算法的实例都使用一样的集合。 正常操作时，在所有这个一致性算法实例中一个节点被选为leader（唯一的一个能产生提议的节点）。客户端发送多条命令给这个leader，leader来决定这些命令该放在实例集合中的位置。如果leader从这众多命令中决定了一个确切的客户端命令应该作为第135条命令，它就会尝试将这条命令作为这个共识算法的第135个实例。这个尝试通常会成功。以下情况可能会失败：leader出现异常情况、或者有一个其它节点服务器也坚信自己是leader并且对于哪条客户端命令作为第135条命令有不同看法。但是这个共识算法保证至多一个命令能被选择为第135条命令。 这个方法效率的关键是：在这个Paxos共识算法中，value只能到第二阶段(Phase 2)才能被批准。 回忆一下，proposer的算法在完成阶段1之后，要么proposer已经知道acceptor选中了一个value，要么所有acceptors还没有经历过阶段2并同意过任何值。 我现在要描述Paxos算法提到的状态机在正常操作中如何实现。稍后，我会讨论异常情况。我思考当前一个leader崩溃了而新leader被选出时会发生什么。（系统初始运行时还没有命令被投票产生，这是一种特殊情形。） 选出的新的leader也作为这个共识算法所有实例的learner，应该要知道大多数被选择的命令。假设它知道第1-134、138和139个命令，也就是这些实例1-134、138和139选择的value。（稍后我们会看到这种情况如何产生的。）leader接着开始执行第135-137实例的阶段1(Phase 1)以及所有比139大的实例。假设这次的执行结果决定了实例135和140选中的value，但是不影响其它实例。然后leader对实例135和140执行阶段2(Phase 2)，从而为135和140实例选中的客户端命令。 Leader服务器和其它所有服务器此时可以获取leader能够知道的所有命令，那么现在它们可以执行1-135实例的命令。然而，它们不能执行138-140，尽管138-140处于实例集合中能够知道它们的内容，因为命令136和137还没有选出。Leader可以将接下来的两条客户端命令请求作为命令136和137。但是我们不这样做，我们发起一个特殊的”no-op”命令的提议来作为136和137的内容，这样让状态机状态不改变并且也能填充命令实例集合的空缺。（通过执行共识算法实例136和137的阶段2）一旦这些”no-op”命令被选中，命令138-140就能被执行。 现在命令1-140已经选择完毕了。Leader也完成了共识算法中所有大于140的实例的阶段1，并且可以在这些实例的阶段2提议任何value。它将接下来的客户端请求赋值为141，然后提议这个客户端请求作为共识算法实例141在阶段2的value。它又继续提议接下来的客户端请求为142，如此循环往复。 Leader能够在还不清楚提议141是否被选中之前就提议命令142。可能提议141命令的所有消息都丢失了，也可能在命令141还没被任何learner知道被选为141命令之前，142命令就被选中。当leader没有接收到期望的关于141实例提议的阶段2响应消息，它就会重新发送这些消息。如果所有顺利进行，它的提议命令将会被选中。然而，它可能一开始就发生故障，使选择的命令序列出现了空缺。通常，假设一个leader能够提前获得α条命令，那也是说，在1-i的命令被选出的情况下，它能提议i+1-i+α的命令。因此空缺可能会有α-1那么大。 一个新的leader可以执行无数个共识算法实例的阶段1—即在上面的场景中，135-137以及所有大于139的实例。所有实例使用同一个提议号，leader可以给其它服务器发送单个合理的短消息。在阶段1，一个acceptor如果早已接收过其它proposer的阶段2的消息，那么（对于这条prepare请求）它就不仅仅回复个OK。（这种情况仅仅是场景中的135和140实例。）因此，一个服务器（扮演acceptor的）可以用单个合理的短消息响应所有实例。执行无数个阶段1的实例不会产生任何问题。 leader遭遇故障然后选择一个新的leader是小概率事件，因此执行状态机命令的消耗–即，实现共识算法的command/value—就是共识算法阶段2执行的消耗。可以看到Paxos一致性算法的阶段2在任何达成共识的算法中消耗最小的。因此，Paxos算法是最优的。 系统正常操作中总是假定有一个leader，除非当前leader发生故障并且正在选择一个新leader。在意外情况中，leader选举可能发生故障。如果没有服务器扮演leader，那么也就没有命令会被提议。如果有多个服务器认为他们是leaders，它们都能对一致性算法的同一实例的提议value，这会导致没有任何value被选中。然而安全性总是保留着—两个不同的服务器永远不会不同意一个value被选为第i个状态机命令。单个leader的选举仅仅是为了保证过程的进行。 如果服务器的集合可以改变，那么必须要有方法来确定哪些服务器实现了哪些一致性算法实例。最简单的办法就是让状态机自己来做。当前服务器的集合可以作为状态的一部分，并且可以被一般的状态机命令改变。在执行完第i条状态机命令后，我们通过让这个服务器集合执行一致性算法的i-i+α条实例来指定状态的方式，以允许leader提前获取α个命令。这点就可以完成一个任意复杂的重构算法的简单实现。","categories":[{"name":"译文","slug":"译文","permalink":"http://lkness/categories/译文/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"http://lkness/tags/分布式/"}]},{"title":"erlang底层c定时器设计-Erlang源码学习二","slug":"030erlang-timer/index","date":"2018-06-20T12:09:25.000Z","updated":"2018-06-20T12:18:22.090Z","comments":true,"path":"2018/06/20/030erlang-timer/index/","link":"","permalink":"http://lkness/2018/06/20/030erlang-timer/index/","excerpt":"","text":"Erlang底层的定时器实现位于源码的erts/emulator/beam/time.c文件，用时间轮的方式动态添加和删除定时器，结构体名为typedef struct ErtsTimerWheel_ ErtsTimerWheel，每一个定时器的结构体名为typedef struct erl_timer ErtsTWheelTimer，看结构体实现大体上可以知道定时器的设计。 定时器 ErtsTWheelTimertypedef struct erl_timer { struct erl_timer* next; /* next entry tiw slot or chain */ struct erl_timer* prev; /* prev entry tiw slot or chain */ union { struct { void (*timeout)(void*); /* called when timeout */ void (*cancel)(void*); /* called when cancel (may be NULL) */ void* arg; /* argument to timeout/cancel procs */ } func; ErtsThrPrgrLaterOp cleanup; } u; ErtsMonotonicTime timeout_pos; /* Timeout in absolute clock ticks */ int slot; } ErtsTWheelTimer; 每个定时器维护了前后向指针，有定时器到时作为回调的函数、取消定时器所调用的函数（可能做参数销毁用）和函数参数，还有定时器的到时点，以及此定时器位于时间轮的槽。 时间轮 ErtsTimerWheelstruct ErtsTimerWheel_ { ErtsTWheelTimer *w[ERTS_TIW_SIZE]; ErtsMonotonicTime pos; Uint nto; struct { ErtsTWheelTimer *head; ErtsTWheelTimer *tail; Uint nto; } at_once; int yield_slot; int yield_slots_left; int yield_start_pos; ErtsTWheelTimer sentinel; int true_next_timeout_time; ErtsMonotonicTime next_timeout_time; }; 时间轮维护了一个ERTS_TIW_SIZE大小的定时器指针数组，看头文件定义可以得到ERTS_TIW_SIZE在小内存机器上是 1&lt;&lt;13的大小，大内存机器为1&lt;&lt;16=2^16=2^6*1024=65535大小，这里只看大内存机器；接着有一个pos字段，类型为ErtsMonotonicTime，这是一个long long的别名，顾名思义就是erlang的monotonic时间，简单说就是一个精确到纳秒的单调递增时间；接着有一个at_once空间，有头head、尾tail指针，至于数据结构可能为链表，可能为数组实现的栈或队列等；然后的字段光看名字也无法推断了。进入时间轮操作函数。 # time.c的函数只有几个，先罗列简单的: ErtsTimerWheel * erts_create_timer_wheel(ErtsSchedulerData *esdp) { ErtsMonotonicTime mtime; int i; ErtsTimerWheel *tiw; tiw = erts_alloc_permanent_cache_aligned(ERTS_ALC_T_TIMER_WHEEL, sizeof(ErtsTimerWheel)); for(i = 0; i &lt; ERTS_TIW_SIZE; i++) tiw-&gt;w[i] = NULL; mtime = erts_get_monotonic_time(esdp); tiw-&gt;pos = ERTS_MONOTONIC_TO_CLKTCKS(mtime); tiw-&gt;nto = 0; tiw-&gt;at_once.head = NULL; tiw-&gt;at_once.tail = NULL; tiw-&gt;at_once.nto = 0; tiw-&gt;yield_slot = ERTS_TWHEEL_SLOT_INACTIVE; tiw-&gt;true_next_timeout_time = 0; tiw-&gt;next_timeout_time = mtime + ERTS_MONOTONIC_DAY; tiw-&gt;sentinel.next = &amp;tiw-&gt;sentinel; tiw-&gt;sentinel.prev = &amp;tiw-&gt;sentinel; tiw-&gt;sentinel.u.func.timeout = NULL; tiw-&gt;sentinel.u.func.cancel = NULL; tiw-&gt;sentinel.u.func.arg = NULL; return tiw; } 看操作是先分配内存，然后初始化w定时器指针数组为NULL，接着获取一次当前的monotonic时间，将它转换为时间轮滴答后赋给pos字段，monotonic时间是精确到纳秒，宏ERTS_MONOTONIC_TO_CLKTCKS将它除以了1000*1000，从这里我们可以知道时间轮每一次走动是1ms，即时间轮的粒度就是1ms了，接下来的操作就是常规的初始化了，到tiw-&gt;sentinel.next = $tiw-&gt;sentinel语句开始，是将一个sentinel（哨兵）变量变为一个指向自己的循环双向链表。 结论： 时间轮的pos字段初始值为创建时间轮时的monotonic时间，但时间轮的精度为ms，故需要将monotonic时间转换为ms（除以1000*1000），pos字段为时间轮的当前指针（想象成钟的分针）。 插入定时器 insert_timer_into_slotstatic ERTS_INLINE void insert_timer_into_slot(ErtsTimerWheel *tiw, int slot, ErtsTWheelTimer *p) { ERTS_TW_ASSERT(slot &gt;= 0); ERTS_TW_ASSERT(slot &lt; ERTS_TIW_SIZE); p-&gt;slot = slot; if (!tiw-&gt;w[slot]) { tiw-&gt;w[slot] = p; p-&gt;next = p; p-&gt;prev = p; } else { ErtsTWheelTimer *next, *prev; next = tiw-&gt;w[slot]; prev = next-&gt;prev; p-&gt;next = next; p-&gt;prev = prev; prev-&gt;next = p; next-&gt;prev = p; } } 先看插入的第1、2两句，断言slot要介于0-ERTS_TIW_SIZE之间：定时器要插到时间轮的槽上，因此必须介于这个范围。然后开始插入，先判断待插入的槽有没有定时器，如果没有，就直接将w[slot]指针指向这个定时器，并且赋值next、prev指针保证循环双向链表特性；如果槽上已经有了别的定时器，那么看else的操作是将待插入的定时器头插到链表中。 于是看完这个函数，知道了时间轮的主要逻辑如图： 结论： 时间轮的槽大小为65535；每个槽是一个定时器指针，指针又维护了一个定时器双向循环链表，跟链式散列表很像；定时器是头插。 去除定时器 remove_timerstatic ERTS_INLINE void remove_timer(ErtsTimerWheel *tiw, ErtsTWheelTimer *p) { int slot = p-&gt;slot; ERTS_TW_ASSERT(slot != ERTS_TWHEEL_SLOT_INACTIVE); if (slot &gt;= 0) { /* * Timer in wheel or in circular * list of timers currently beeing * triggered (referred by sentinel). */ ERTS_TW_ASSERT(slot &lt; ERTS_TIW_SIZE); if (p-&gt;next == p) { ERTS_TW_ASSERT(tiw-&gt;w[slot] == p); tiw-&gt;w[slot] = NULL; } else { if (tiw-&gt;w[slot] == p) tiw-&gt;w[slot] = p-&gt;next; p-&gt;prev-&gt;next = p-&gt;next; p-&gt;next-&gt;prev = p-&gt;prev; } } else { /* Timer in &quot;at once&quot; queue... */ ERTS_TW_ASSERT(slot == ERTS_TWHEEL_SLOT_AT_ONCE); if (p-&gt;prev) p-&gt;prev-&gt;next = p-&gt;next; else { ERTS_TW_ASSERT(tiw-&gt;at_once.head == p); tiw-&gt;at_once.head = p-&gt;next; } if (p-&gt;next) p-&gt;next-&gt;prev = p-&gt;prev; else { ERTS_TW_ASSERT(tiw-&gt;at_once.tail == p); tiw-&gt;at_once.tail = p-&gt;prev; } ERTS_TW_ASSERT(tiw-&gt;at_once.nto &gt; 0); tiw-&gt;at_once.nto--; } p-&gt;slot = ERTS_TWHEEL_SLOT_INACTIVE; tiw-&gt;nto--; } 先看第一个断言slot != ERTS_TWHEEL_SLOT_INACTIVE，这个宏值为-2，前面的函数知道槽数一定是介于0-65535之间，所以猜测如果槽数为-2了，表示定时器未激活。 往后看，如果槽存在，又分两种情况，一种是这个定时器所处的槽只有它一个定时器，那么需要将槽指针w[slot]置为空，另一种是槽上还有很多定时器，则从循环双向链表中取下一个结点。如果槽不存在，且看else的slot为宏值ERTS_TWHEEL_SLOT_AT_ONCE，那么就从at_once队列中去除定时器，并且nto字段减1。 将定时器的slot字段置为ERTS_TWHEEL_SLOT_INACTIVE，时间轮的nto字段减1。 结论： 定时器有三种状态分别为正常、at_once、未激活；at_once队列实则为不循环双向链表；at_once的nto字段记录这个队列上的定时器个数；tiw的nto字段记录所有定时器包括at_once队列上的定时器个数。 定时器到时回调 timeout_timer回调就很简单，将定时器的slot字段设置为未激活，然后调用回调函数 取消定时器 erts_twheel_cancel_timer逻辑与4的到时回调差不多，判断了定时器的slot不能为未激活状态，然后调用remove去除定时器，接着调用定时器的cancel回调函数 创建定时器 erts_twheel_set_timervoid erts_twheel_set_timer(ErtsTimerWheel *tiw, ErtsTWheelTimer *p, ErlTimeoutProc timeout, ErlCancelProc cancel, void *arg, ErtsMonotonicTime timeout_pos) { ErtsMonotonicTime timeout_time; ERTS_MSACC_PUSH_AND_SET_STATE_M_X(ERTS_MSACC_STATE_TIMERS); p-&gt;u.func.timeout = timeout; p-&gt;u.func.cancel = cancel; p-&gt;u.func.arg = arg; ERTS_TW_ASSERT(p-&gt;slot == ERTS_TWHEEL_SLOT_INACTIVE); if (timeout_pos &lt;= tiw-&gt;pos) { tiw-&gt;nto++; tiw-&gt;at_once.nto++; p-&gt;next = NULL; p-&gt;prev = tiw-&gt;at_once.tail; if (tiw-&gt;at_once.tail) { ERTS_TW_ASSERT(tiw-&gt;at_once.head); tiw-&gt;at_once.tail-&gt;next = p; } else { ERTS_TW_ASSERT(!tiw-&gt;at_once.head); tiw-&gt;at_once.head = p; } tiw-&gt;at_once.tail = p; p-&gt;timeout_pos = tiw-&gt;pos; p-&gt;slot = ERTS_TWHEEL_SLOT_AT_ONCE; timeout_time = ERTS_CLKTCKS_TO_MONOTONIC(tiw-&gt;pos); } else { int slot; /* calculate slot */ slot = (int) (timeout_pos &amp; (ERTS_TIW_SIZE-1)); insert_timer_into_slot(tiw, slot, p); tiw-&gt;nto++; timeout_time = ERTS_CLKTCKS_TO_MONOTONIC(timeout_pos); p-&gt;timeout_pos = timeout_pos; } if (timeout_time &lt; tiw-&gt;next_timeout_time) { tiw-&gt;true_next_timeout_time = 1; tiw-&gt;next_timeout_time = timeout_time; } ERTS_MSACC_POP_STATE_M_X(); } 逻辑很清楚：传入一个时间轮、定时器、以及定时器要用的相关函数、时间轮上的超时位置（monotonic time / 1000*1000）。 然后判断超时位置是否小于等于时间轮当前的指针pos，如果是，就把它加入到at_once链表，pos的精度为ms，这个at_once的意思就是加入的定时器差1ms就要到时，而针对这种定时器，再把它插入到槽里做管理和到时是没有意义的，因为马上就到时了。 正常的定时器则可以插入到槽里了，槽的计算是用到时位置与槽总大小做与运算，举个例子：当前monotonic时间为10,000,000,000，表示开始或者erlang虚拟机开启了10s， 此时创建了一个时间轮，它的pos就该为10,000，然后插入一个5,000,000,000纳秒后到时的定时器，因为时间轮精度为ms，顾折算为(10,000,000,000 + 5,000,000,000)/1000*1000=15,000，即timeout_pos就为15000，那么timeout_pos &amp; ERTS_TIW_SIZE = 15000，那么槽就是15000位置，此时槽还在10000位置，要走5000个滴答才到，同理，如果插入一个距现在65536ms后到时的定时器，则65536超出了65535，但与运算，又变为了0，实现了定时器的循环相加。 相应nto计数加一，然后判断加入的定时器的到时时间是否小于等于时间轮的下一次到时时间，如果是，就更新时间轮的相应到时值。 总结： 定时器如果马上（差1ms）到时的，会加入到at_once队列，否则加入到时间槽里做管理；定时器的到时时间为一个精度为ms的值，然后用这个值跟ERTS_TIW_SIZE做与运算，保证了槽的循环；时间轮还有字段用来表示下一次最近的到时时间，true_next_timeout_time为1表示存在这个时间（即槽上至少存在一个激活的定时器还没到时）。 寻找下一个最近到时时间 find_next_timeoutstatic ERTS_INLINE ErtsMonotonicTime find_next_timeout(ErtsSchedulerData *esdp, ErtsTimerWheel *tiw, int search_all, ErtsMonotonicTime curr_time, /* When !search_all */ ErtsMonotonicTime max_search_time) /* When !search_all */ { int start_ix, tiw_pos_ix; ErtsTWheelTimer *p; int true_min_timeout = 0; ErtsMonotonicTime min_timeout, min_timeout_pos, slot_timeout_pos; if (tiw-&gt;nto == 0) { /* no timeouts in wheel */ if (!search_all) min_timeout_pos = tiw-&gt;pos; else { curr_time = erts_get_monotonic_time(esdp); tiw-&gt;pos = min_timeout_pos = ERTS_MONOTONIC_TO_CLKTCKS(curr_time); } min_timeout_pos += ERTS_MONOTONIC_TO_CLKTCKS(ERTS_MONOTONIC_DAY); goto found_next; } slot_timeout_pos = min_timeout_pos = tiw-&gt;pos; if (search_all) min_timeout_pos += ERTS_MONOTONIC_TO_CLKTCKS(ERTS_MONOTONIC_DAY); else min_timeout_pos = ERTS_MONOTONIC_TO_CLKTCKS(curr_time + max_search_time); start_ix = tiw_pos_ix = (int) (tiw-&gt;pos &amp; (ERTS_TIW_SIZE-1)); do { if (++slot_timeout_pos &gt;= min_timeout_pos) break; p = tiw-&gt;w[tiw_pos_ix]; if (p) { ErtsTWheelTimer *end = p; do { ErtsMonotonicTime timeout_pos; timeout_pos = p-&gt;timeout_pos; if (min_timeout_pos &gt; timeout_pos) { true_min_timeout = 1; min_timeout_pos = timeout_pos; if (min_timeout_pos &lt;= slot_timeout_pos) goto found_next; } p = p-&gt;next; } while (p != end); } tiw_pos_ix++; if (tiw_pos_ix == ERTS_TIW_SIZE) tiw_pos_ix = 0; } while (start_ix != tiw_pos_ix); found_next: min_timeout = ERTS_CLKTCKS_TO_MONOTONIC(min_timeout_pos); tiw-&gt;next_timeout_time = min_timeout; tiw-&gt;true_next_timeout_time = true_min_timeout; return min_timeout; } 函数作用是寻找时间轮所处指针到当前时间curr_time之间最近的一个定时器到时时间。 函数逻辑分两种情况，一种是时间轮上没有定时器，则判断search_all的值是否要将时间轮的指针拨到当前时间点，然后最小超时时间就为明天的这个时候（因为没有定时器，自然不存在下一个到时的定时器时间）；另一种是时间轮上有定时器，则判断search_all的值是，如果为1，寻找的间隔就是一天(246060*1000)，否则间隔就是时间轮当前指针到curr_time+max_search_time的距离，然后从时间轮当前指针处开始循环判断每个槽链表，有无定时器的到时时间小于curr_time+max_search_time，如果找了一圈（即走过的距离为ERTS_TIW_SIZE）没找到，就退出，并设置时间轮的下一次到时时间。 结论： 时间轮维护了一个下一次到时时间，避免了一段连续的槽上都没有定时器，而在做到时判断时空循环破坏效率。 时间轮嘀嗒 erts_bump_timersvoid erts_bump_timers(ErtsTimerWheel *tiw, ErtsMonotonicTime curr_time) { int tiw_pos_ix, slots, yielded_slot_restarted, yield_count; ErtsMonotonicTime bump_to, tmp_slots, old_pos; ERTS_MSACC_PUSH_AND_SET_STATE_M_X(ERTS_MSACC_STATE_TIMERS); yield_count = ERTS_TWHEEL_BUMP_YIELD_LIMIT; /* * In order to be fair we always continue with work * where we left off when restarting after a yield. */ if (tiw-&gt;yield_slot &gt;= 0) { yielded_slot_restarted = 1; tiw_pos_ix = tiw-&gt;yield_slot; slots = tiw-&gt;yield_slots_left; bump_to = tiw-&gt;pos; old_pos = tiw-&gt;yield_start_pos; goto restart_yielded_slot; } do { yielded_slot_restarted = 0; bump_to = ERTS_MONOTONIC_TO_CLKTCKS(curr_time); while (1) { ErtsTWheelTimer *p; old_pos = tiw-&gt;pos; if (tiw-&gt;nto == 0) { empty_wheel: ERTS_DBG_CHK_SAFE_TO_SKIP_TO(tiw, bump_to); tiw-&gt;true_next_timeout_time = 0; tiw-&gt;next_timeout_time = curr_time + ERTS_MONOTONIC_DAY; tiw-&gt;pos = bump_to; tiw-&gt;yield_slot = ERTS_TWHEEL_SLOT_INACTIVE; ERTS_MSACC_POP_STATE_M_X(); return; } p = tiw-&gt;at_once.head; while (p) { if (--yield_count &lt;= 0) { ERTS_TW_ASSERT(tiw-&gt;nto &gt; 0); ERTS_TW_ASSERT(tiw-&gt;at_once.nto &gt; 0); tiw-&gt;yield_slot = ERTS_TWHEEL_SLOT_AT_ONCE; tiw-&gt;true_next_timeout_time = 1; tiw-&gt;next_timeout_time = ERTS_CLKTCKS_TO_MONOTONIC(old_pos); ERTS_MSACC_POP_STATE_M_X(); return; } ERTS_TW_ASSERT(tiw-&gt;nto &gt; 0); ERTS_TW_ASSERT(tiw-&gt;at_once.nto &gt; 0); tiw-&gt;nto--; tiw-&gt;at_once.nto--; tiw-&gt;at_once.head = p-&gt;next; if (p-&gt;next) p-&gt;next-&gt;prev = NULL; else tiw-&gt;at_once.tail = NULL; timeout_timer(p); p = tiw-&gt;at_once.head; } if (tiw-&gt;pos &gt;= bump_to) { ERTS_MSACC_POP_STATE_M_X(); break; } if (tiw-&gt;nto == 0) goto empty_wheel; if (tiw-&gt;true_next_timeout_time) { ErtsMonotonicTime skip_until_pos; /* * No need inspecting slots where we know no timeouts * to trigger should reside. */ skip_until_pos = ERTS_MONOTONIC_TO_CLKTCKS(tiw-&gt;next_timeout_time); if (skip_until_pos &gt; bump_to) skip_until_pos = bump_to; skip_until_pos--; if (skip_until_pos &gt; tiw-&gt;pos) { ERTS_DBG_CHK_SAFE_TO_SKIP_TO(tiw, skip_until_pos); tiw-&gt;pos = skip_until_pos; } } tiw_pos_ix = (int) ((tiw-&gt;pos+1) &amp; (ERTS_TIW_SIZE-1)); tmp_slots = (bump_to - tiw-&gt;pos); if (tmp_slots &lt; (ErtsMonotonicTime) ERTS_TIW_SIZE) slots = (int) tmp_slots; else slots = ERTS_TIW_SIZE; tiw-&gt;pos = bump_to; while (slots &gt; 0) { p = tiw-&gt;w[tiw_pos_ix]; if (p) { if (p-&gt;next == p) { ERTS_TW_ASSERT(tiw-&gt;sentinel.next == &amp;tiw-&gt;sentinel); ERTS_TW_ASSERT(tiw-&gt;sentinel.prev == &amp;tiw-&gt;sentinel); } else { tiw-&gt;sentinel.next = p-&gt;next; tiw-&gt;sentinel.prev = p-&gt;prev; tiw-&gt;sentinel.next-&gt;prev = &amp;tiw-&gt;sentinel; tiw-&gt;sentinel.prev-&gt;next = &amp;tiw-&gt;sentinel; } tiw-&gt;w[tiw_pos_ix] = NULL; while (1) { if (p-&gt;timeout_pos &gt; bump_to) { /* Very unusual case... */ ++yield_count; insert_timer_into_slot(tiw, tiw_pos_ix, p); } else { /* Normal case... */ timeout_timer(p); tiw-&gt;nto--; } restart_yielded_slot: p = tiw-&gt;sentinel.next; if (p == &amp;tiw-&gt;sentinel) { ERTS_TW_ASSERT(tiw-&gt;sentinel.prev == &amp;tiw-&gt;sentinel); break; } if (--yield_count &lt;= 0) { tiw-&gt;true_next_timeout_time = 1; tiw-&gt;next_timeout_time = ERTS_CLKTCKS_TO_MONOTONIC(old_pos); tiw-&gt;yield_slot = tiw_pos_ix; tiw-&gt;yield_slots_left = slots; tiw-&gt;yield_start_pos = old_pos; ERTS_MSACC_POP_STATE_M_X(); return; /* Yield! */ } tiw-&gt;sentinel.next = p-&gt;next; p-&gt;next-&gt;prev = &amp;tiw-&gt;sentinel; } } tiw_pos_ix++; if (tiw_pos_ix == ERTS_TIW_SIZE) tiw_pos_ix = 0; slots--; } } } while (yielded_slot_restarted); tiw-&gt;yield_slot = ERTS_TWHEEL_SLOT_INACTIVE; tiw-&gt;true_next_timeout_time = 0; tiw-&gt;next_timeout_time = curr_time + ERTS_MONOTONIC_DAY; /* Search at most two seconds ahead... */ (void) find_next_timeout(NULL, tiw, 0, curr_time, ERTS_SEC_TO_MONOTONIC(2)); ERTS_MSACC_POP_STATE_M_X(); } 这是最重要的一个函数，erlang虚拟机启动后，有一个线程做周期性调用，来检测有无定时器到时。 函数接收一个curr_time形参，将时间轮上小于等于此时间的定时器都视为到时，所以估计是1ms调用一次。 函数定义了yield_count=100，如果at_once或者某个槽上大于100个定时器，就丢弃多的。 这个函数写得很恶心，又是do while{}，又是while(1)，又是while，但剥离开，真正的逻辑就一段：循环将at_once链表的定时器全部到时，则at_once链表清空了；开始判断时间槽，先利用下一个最近的到时时间next_timeout_time跳过一段槽，然后开始遍历从时间轮的当前指针pos到curr_time之间的间隔槽，再遍历每个槽上的链表，对每个结点判断是否大于等于curr_time，即判断是否到时，如果到时就可以去掉定时器，并执行回调任务。 以上步骤就做完了到时任务，调用一下find_next_timeout寻找一次最近到时时间。 # 在看erts_bump_timers函数时候看到一段goto的代码形如： goto test_label: int a = 0; test_label: a = 1; 当时很诧异，a不是没定义吗？激动得不行，摩拳擦掌准备提bug，抱着谨慎的态度还是查了一下，这种用法是可以的，真是菜得不行 …… 自己猜想一下可能是编译期已经将a加入了符号表，goto只影响运行时。","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"Erlang","slug":"Erlang","permalink":"http://lkness/tags/Erlang/"}]},{"title":"erlang:now()与os:timestamp()-Erlang源码学习一","slug":"029erlang-time/index","date":"2018-06-20T11:44:02.000Z","updated":"2018-06-20T12:04:28.254Z","comments":true,"path":"2018/06/20/029erlang-time/index/","link":"","permalink":"http://lkness/2018/06/20/029erlang-time/index/","excerpt":"","text":"erlang中，关于erlang:now()与os:timestamp()两个接口，查看官方文档的解释： 按官方文档上说erlang:now/0是废弃了的，它可以获取一个持续递增的唯一时间戳。除此也没说讲到更多。 再看erlang:now/0文档给的时间和时间修正，里面详细描述了erlang对于时间的处理，暂不看。 直接跳到c源码看吧，在这之前可以看看linux内核时间的管理，明白什么是墙上时间(wall time)、单调递增时间(monotonic time)等。 erlang:now/0erlang:now/0的bif函数对应erlang源码:erts/emulator/beam/bif.c now_0()的获取时间调用get_now()函数，位于erts/emulator/beam/erl_time_sup.c 获取时间主要用一个回调get_time()，而获取时间之后会与上一次调用产生的值比较，并产生一个新的保证单调递增的唯一值，并加锁修改旧值。关于get_time()的初始化要在同文件的erlang_init_time_sup()函数 可以看到有一个条件编译宏 ERTS_HAVE_OS_MONOTONIC_TIME_SUPPORT，在没有配置erlang源码时，这些宏都未定义，但如果在源码根目录执行了./configure配置后，会在emulator目录生成一个文件夹（我的是x86_64-unknown-linux-gnu），里面放有config.h配置文件，里面根据操作系统类型做了对应宏定义，对应宏ERTS_HAVE_OS_MONOTONIC_TIME_SUPPORT就是在config.h里，表示这个操作系统有单调递增时间(monotonic time)，那么这里可以看到get_time回调指向了get_os_grift_corrected_time()，此函数直接返回read_corrected_time()函数结果： 可以看到read_corrected_time()函数主要执行了erts_os_monitonic_time()和calc_corrected_erl_mtime()来获取操作系统的monitonic_time以及修正时间。erts_os_monitonic_time()直接调用posix_clock_gettime()函数，参数为MONOTONIC_CLOCK_ID，获取monotonic time： 获取时间的函数实则调用了linux的系统函数clock_gettime()，可以man手册看一看；calc_corrected_erl_time()函数： 将获取的当前操作系统monitonic time与最近一次更新的操作系统monitonic time做一个差值计算，然后根据erlang时间的设计来计算一个新的erlang monitonic time。 os:timestamp/0os:timestamp()函数代码： 代码里调用了erts_os_system_time()函数来获取操作系统的时间： 又是熟悉的posix_clock_gettime()，并且参数为WALL_CLOCK_ID获取墙上时间。 总结erlang:now/0获取的是erlang系统的monotonic time，它从操作系统获取后还要用erlang时间处理的方式在调整为erlang monotonic time，期间几次会对全局变量加锁，故效率会有损耗，而每一次获取时间值后会与上一次获取的值做一个对比，并加一来保证获取值的严格单调递增，所以可以用来作为唯一名(unique name)的生成，但是，erts7.0之后就不建议用这个函数了，可以用erlang:timestamp/0替代，如果要生成唯一名可以用erlang:unique_integer/0等等。 而os:timestamp/0则是获取操作系统的墙上时间(wall time)，并做调整变为erlang system time。 erlang:now/0获取时间的文件为erl_time_sup.c，所有的erlang关于时间处理方式的逻辑都定义在里面，包括维护全局变量来处理操作系统转变为erlang规则的内部时间、注册定时器周期检查erlang时间与os时间对比的偏移量等；os:timestamp/0获取时间的文件为sys_time.c，是对os获取时间的库函数的封装、以及对获取的时间进行简单调整的文件，比较轻量级。 后记：看了erlang时间的处理，感觉很有趣，后面学习一下erlang源码中对时间的管理代码。","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"Erlang","slug":"Erlang","permalink":"http://lkness/tags/Erlang/"}]},{"title":"图的简单表示-算法学习笔记十七","slug":"028graph/index","date":"2018-06-20T04:49:36.000Z","updated":"2018-06-20T04:50:55.817Z","comments":true,"path":"2018/06/20/028graph/index/","link":"","permalink":"http://lkness/2018/06/20/028graph/index/","excerpt":"","text":"基于邻接矩阵和邻接链表的图表示法，以及各自的深度优先遍历和广度优先遍历，但图的表示中没有加带权的边，只是简单写一写，学习一下，底层链表和队列用了通用链表 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #define PRINT(format, arg...) \\ do{ \\ printf(&quot;[%s/%d]:&quot;, __func__, __LINE__); \\ printf(format, ##arg); \\ printf(&quot;\\n&quot;); \\ }while(0) /*****************************图********************************/ #define MAX_VERTEX_NUM 100 typedef struct init_array { int start_v; int end_v; } init_array; /**************邻接矩阵表示****************/ typedef struct matrix_graph { int vertex[MAX_VERTEX_NUM]; // 存放顶点信息 int v_num; // 顶点数 int e_num; // 边数 int matrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM]; } matrix_graph; matrix_graph *init_matrix_graph( int v_num, int e_num ) { int i = 0, j = 0; matrix_graph *graph = NULL; graph = ( matrix_graph * )malloc( sizeof(matrix_graph) ); graph-&gt;v_num = v_num; graph-&gt;e_num = e_num; for ( i = 0; i &lt; MAX_VERTEX_NUM; i++ ) { if ( i &lt; v_num ) graph-&gt;vertex[i] = i; else graph-&gt;vertex[i] = -1; for ( j = 0; j &lt; MAX_VERTEX_NUM; j++ ) { graph-&gt;matrix[i][j] = 0; } } return graph; } matrix_graph *create_matrix_graph( init_array *i_arr, int arr_size, int v_num ) { int i = 0; matrix_graph *graph = NULL; graph = init_matrix_graph( v_num, arr_size ); for ( i = 0; i &lt; arr_size; i++ ) { graph-&gt;matrix[i_arr[i].start_v][i_arr[i].end_v] = 1; } return graph; } int visited[MAX_VERTEX_NUM] = {0}; // 深度优先遍历 void dfs_matrix_graph1( matrix_graph *g, int v ) { visited[v] = 1; printf(&quot;%d &quot;, v); // 搜索此结点的下一个结点 int i = 0; for ( i; i &lt; g-&gt;v_num; i++ ) { if ( g-&gt;matrix[v][i] &amp;&amp; !visited[i] ) dfs_matrix_graph1( g, i ); } } void dfs_matrix_graph( matrix_graph *g ) { int i = 0; for ( i; i &lt; g-&gt;v_num; i++ ) visited[i] = 0; printf(&quot;deep first visit:\\n\\t&quot;); for ( i = 0; i &lt; g-&gt;v_num; i++ ) { if ( !visited[i] ) dfs_matrix_graph1( g, i ); } printf(&quot;\\n&quot;); } // 广度优先搜索 void bfs_matrix_graph( matrix_graph *g ) { int i = 0; // 栈结点数据域，需要void * int tmp_vertex[MAX_VERTEX_NUM] = {0}; queue *q = create_queue(); for ( i = 0; i &lt; g-&gt;v_num; i++ ) visited[i] = 0; printf(&quot;broad first visit:\\n\\t&quot;); for ( i = 0; i &lt; g-&gt;v_num; i++ ) { if ( !visited[i] ) { tmp_vertex[i] = i; q-&gt;enqueue(q-&gt;this, &amp;tmp_vertex[i]); while ( q-&gt;size(q-&gt;this) != 0 ) { int tmp = *( int * )q-&gt;dequeue( q-&gt;this ); if ( !visited[tmp] ) printf(&quot;%d &quot;, tmp); visited[tmp] = 1; int j = 0; for ( j = 0; j &lt; g-&gt;v_num; j++ ) { if ( g-&gt;matrix[tmp][j] &amp;&amp; !visited[j] ) { tmp_vertex[j] = j; q-&gt;enqueue( q-&gt;this, &amp;tmp_vertex[j] ); } } } } } q-&gt;free( q-&gt;this ); printf(&quot;\\n&quot;); } void free_matrix_graph( matrix_graph *g ) { free( g ); } #undef DEBUG_MATRIX_GRAPH #ifdef DEBUG_MATRIX_GRAPH int main() { init_array i_arr[20] = { {0, 4}, {0, 9}, {1, 5}, {2, 1}, {2, 6}, {3, 2}, {3, 6}, {4, 7}, {4, 8}, {5, 2}, {6, 5}, {7, 6}, {7, 3}, {8, 7}, {8, 4}, {9, 8}, }; matrix_graph *g = create_matrix_graph( i_arr, 16, 10 ); dfs_matrix_graph( g ); bfs_matrix_graph( g ); free_matrix_graph( g ); } #endif /********************************************/ /**************图的邻接链表*******************/ typedef struct link_list_graph { int vertex[MAX_VERTEX_NUM]; int v_num; int e_num; link_list v_list[MAX_VERTEX_NUM]; } link_list_graph; // 链表数据域，需要void * int tmp_vertex[MAX_VERTEX_NUM] = {0}; link_list_graph *create_link_list_graph( init_array *i_arr, int arr_size, int v_num ) { int i = 0; link_list_graph *graph = NULL; graph = ( link_list_graph * )malloc( sizeof(link_list_graph) ); graph-&gt;e_num = arr_size; graph-&gt;v_num = v_num; for ( i = 0; i &lt; v_num; i++ ) { tmp_vertex[i] = i; //定制链表操作 graph-&gt;v_list[i].size = 0; graph-&gt;v_list[i].insert = insert_tail; graph-&gt;v_list[i].get_first = get_head; graph-&gt;v_list[i].get_last = get_tail; graph-&gt;v_list[i].del = del_tail; graph-&gt;v_list[i].insert( &amp;graph-&gt;v_list[i], &amp;tmp_vertex[i]); } for ( i = 0; i &lt; arr_size; i++ ) { int start = i_arr[i].start_v; int end = i_arr[i].end_v; graph-&gt;v_list[start].insert( &amp;graph-&gt;v_list[start], &amp;tmp_vertex[end]); printf(&quot;start:%d-&gt;end:%d, size:%d\\n&quot;, start, end, graph-&gt;v_list[start].size); } return graph; } void dfs_link_list_graph1( link_list_graph *g, int v ) { link_list_node *p = g-&gt;v_list[v].head; if ( !visited[*(int *)(p-&gt;data)] ) { printf(&quot;%d &quot;, *(int *)(p-&gt;data)); visited[v] = 1; while ( 1 ) { p = p-&gt;next; if ( p == g-&gt;v_list[v].head ) break; if ( !visited[*(int *)(p-&gt;data)] ) { dfs_link_list_graph1( g, *(int *)(p-&gt;data) ); } } } } void dfs_link_list_graph( link_list_graph *g ) { int i = 0; printf(&quot;深度优先遍历：\\n\\t&quot;); for ( i = 0; i &lt; g-&gt;v_num; i++ ) visited[i] = 0; for ( i = 0; i &lt; g-&gt;v_num; i++ ) { if ( g-&gt;v_list[i].size &gt; 0 &amp;&amp; !visited[i] ) dfs_link_list_graph1( g, i ); } printf(&quot;\\n&quot;); } void bfs_link_list_graph( link_list_graph *g ) { int i = 0; // 栈结点数据域，需要void * int tmp_vertex[MAX_VERTEX_NUM] = {0}; queue *q = create_queue(); for ( i = 0; i &lt; g-&gt;v_num; i++ ){ tmp_vertex[i] = i; visited[i] = 0; } printf(&quot;广度优先遍历:\\n\\t&quot;); for ( i = 0; i &lt; g-&gt;v_num; i++ ) { if ( !visited[i] ) { tmp_vertex[i] = i; q-&gt;enqueue(q-&gt;this, &amp;tmp_vertex[i]); while ( q-&gt;size(q-&gt;this) != 0 ) { int tmp = *( int * )q-&gt;dequeue( q-&gt;this ); if ( !visited[tmp] ) printf(&quot;%d &quot;, tmp); visited[tmp] = 1; int j = 0; link_list_node *p = g-&gt;v_list[tmp].head-&gt;next; while ( p != g-&gt;v_list[tmp].head ) { if ( !visited[*(int *)p-&gt;data] ) { q-&gt;enqueue( q-&gt;this, &amp;tmp_vertex[*(int *)p-&gt;data] ); } p = p-&gt;next; } } } } q-&gt;free( q-&gt;this ); printf(&quot;\\n&quot;); } void free_link_list_graph( link_list_graph *g ) { int i = 0; for ( i = 0; i &lt; g-&gt;v_num; ++i ) { del_list( &amp;g-&gt;v_list[i] ); } free( g ); } #define DEBUG_LINK_LIST_GRAPH #ifdef DEBUG_LINK_LIST_GRAPH int main() { init_array i_arr[20] = { {0, 4}, {0, 9}, {1, 5}, {2, 1}, {2, 6}, {3, 2}, {3, 6}, {4, 7}, {4, 8}, {5, 2}, {6, 5}, {7, 6}, {7, 3}, {8, 7}, {8, 4}, {9, 8}, }; link_list_graph *g = create_link_list_graph( i_arr, 16, 10 ); dfs_link_list_graph( g ); bfs_link_list_graph( g ); free_link_list_graph( g ); } #endif /********************************************/ /***************************************************************/","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://lkness/tags/数据结构-算法/"}]},{"title":"通用链表/栈/队列-算法学习笔记十六","slug":"027list-stack-queue/index","date":"2018-06-20T04:47:44.000Z","updated":"2018-06-20T04:49:04.717Z","comments":true,"path":"2018/06/20/027list-stack-queue/index/","link":"","permalink":"http://lkness/2018/06/20/027list-stack-queue/index/","excerpt":"","text":"今天准备学习数据结构-图，会用到栈和队列，因此写了下代码，底层用了通用链表，为循环双向结构，结点数据域为void *；通用链表层之上封装了栈和队列，比较简单，但是代码行数有点多，单独摘出： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;time.h&gt; #define MAX_VERTEX_NUM 1000 #define PRINT(format, arg...) \\ do{ \\ printf(&quot;[%s/%d]:&quot;, __func__, __LINE__); \\ printf(format, ##arg); \\ printf(&quot;\\n&quot;); \\ }while(0) /*****************************底层链表***************************/ // 循环双向链表 typedef struct link_list_node { void *data; struct link_list_node *pre; struct link_list_node *next; } link_list_node; typedef struct link_list { int size; //链表插入函数 void (*insert)( struct link_list *list, void *data ); //链表取第一个结点 void *(*get_first)( struct link_list *list ); //链表取最后一个结点 void *(*get_last)( struct link_list *list ); //链表删除第一个结点 void *(*del)( struct link_list *list ); struct link_list_node *head; } link_list; link_list_node *create_link_list_node( void *data ) { link_list_node *node = NULL; node = ( link_list_node * )malloc( sizeof(link_list_node) ); node-&gt;data = data; node-&gt;pre = NULL; node-&gt;next = NULL; return node; } //头插 void insert_head( link_list *list, void *data ) { if ( !list ) { PRINT(&quot;list is null.&quot;); return; } link_list_node *node = create_link_list_node( data ); if ( !list-&gt;head ) { node-&gt;next = node; node-&gt;pre = node; list-&gt;head = node; list-&gt;size = 1; return; } node-&gt;next = list-&gt;head; node-&gt;pre = list-&gt;head-&gt;pre; list-&gt;head-&gt;pre-&gt;next = node; list-&gt;head-&gt;pre = node; list-&gt;head = node; list-&gt;size += 1; } //尾插，栈/队列的插入 void insert_tail ( link_list *list, void *data ) { if ( !list ) { return; } link_list_node *node = create_link_list_node( data ); if ( !list-&gt;head ) { node-&gt;next = node; node-&gt;pre = node; list-&gt;head = node; list-&gt;size = 1; return; } node-&gt;pre = list-&gt;head-&gt;pre; node-&gt;next = list-&gt;head; list-&gt;head-&gt;pre-&gt;next = node; list-&gt;head-&gt;pre = node; list-&gt;size += 1; } //获取链表头数据 void *get_head( link_list *list ) { if ( !list || !list-&gt;head ) { PRINT(&quot;list is null.&quot;); return NULL; } return list-&gt;head-&gt;data; } //获取链表尾数据 void *get_tail( link_list *list ) { if ( !list || !list-&gt;head ){ PRINT(&quot;list is null.&quot;); return NULL; } return list-&gt;head-&gt;pre-&gt;data; } //删除链表头，并返回删除结点的数据 void *del_head( link_list *list ) { if ( !list || !list-&gt;head ) { return NULL; } if ( list-&gt;size == 1 ) { void *data = list-&gt;head-&gt;data; free( list-&gt;head ); list-&gt;head = NULL; list-&gt;size = 0; return data; } link_list_node *p = list-&gt;head; void *data = p-&gt;data; list-&gt;head-&gt;pre-&gt;next = list-&gt;head-&gt;next; list-&gt;head-&gt;next-&gt;pre = list-&gt;head-&gt;pre; list-&gt;head = list-&gt;head-&gt;next; list-&gt;size -= 1; free( p ); return data; } //删除链表尾，并返回删除结点的数据 void *del_tail( link_list *list ) { if ( !list || !list-&gt;head ) { PRINT(&quot;list is null.&quot;); return NULL; } if ( list-&gt;size == 1 ) { void *data = list-&gt;head-&gt;data; free( list-&gt;head ); list-&gt;head = NULL; list-&gt;size = 0; return data; } link_list_node *p = list-&gt;head-&gt;pre; void *data = p-&gt;data; list-&gt;head-&gt;pre-&gt;pre-&gt;next = list-&gt;head; list-&gt;head-&gt;pre = list-&gt;head-&gt;pre-&gt;pre; list-&gt;size -= 1; free( p ); return data; } /******************************************************************/ /********************************队列***********************************/ typedef struct queue { void *(*first)( struct queue *this ); void *(*last)( struct queue *this ); void (*enqueue)( struct queue *this, void *data ); void *(*dequeue)( struct queue *this ); int (*size)( struct queue *this ); void (*free)( struct queue *this ); struct link_list *list; struct queue *this; } queue; void *queue_get_first( queue *q ) { if ( !q || !q-&gt;list ) return NULL; return q-&gt;list-&gt;get_first( q-&gt;list ); } void *queue_get_last( queue *q ) { if ( !q || !q-&gt;list ) return NULL; return q-&gt;list-&gt;get_last( q-&gt;list ); } void enqueue( queue *q, void *data ) { if ( !q || !q-&gt;list ) return ; q-&gt;list-&gt;insert( q-&gt;list, data ); } void *dequeue( queue *q ) { if ( !q || !q-&gt;list ) return NULL; q-&gt;list-&gt;del( q-&gt;list ); } int queue_size( queue *q ) { if ( !q || !q-&gt;list) return 0; return q-&gt;list-&gt;size; } void queue_free( queue *q ) { if ( !q ) return ; if ( !q-&gt;list ) { free( q ); return; } while ( q-&gt;dequeue( q-&gt;this ) ); free( q-&gt;list ); free( q ); } queue *create_queue() { queue *q = NULL; q = ( queue * )malloc( sizeof(queue) ); q-&gt;first = queue_get_first; q-&gt;last = queue_get_last; q-&gt;enqueue = enqueue; q-&gt;dequeue = dequeue; q-&gt;size = queue_size; q-&gt;free = queue_free; q-&gt;list = ( link_list * )malloc( sizeof(link_list) ); q-&gt;list-&gt;size = 0; q-&gt;list-&gt;insert = insert_tail; q-&gt;list-&gt;get_first = get_head; q-&gt;list-&gt;get_last = get_tail; q-&gt;list-&gt;del = del_head; q-&gt;this = q; } #undef DEBUG_QUEUE #ifdef DEBUG_QUEUE void test_queue() { queue *q = create_queue(); int data1 = 5; int data2 = 6; int data3 = 7; q-&gt;enqueue(q-&gt;this, (void *)&amp;data1); PRINT(&quot;q-&gt;last:%d&quot;, *(int *)q-&gt;last(q-&gt;this)); q-&gt;enqueue(q-&gt;this, (void *)&amp;data2); PRINT(&quot;q-&gt;last:%d&quot;, *(int *)q-&gt;last(q-&gt;this)); q-&gt;enqueue(q-&gt;this, (void *)&amp;data3); PRINT(&quot;q-&gt;last:%d\\n&quot;, *(int *)q-&gt;last(q-&gt;this)); PRINT(&quot;q-&gt;size:%d\\n&quot;, q-&gt;size(q-&gt;this)); PRINT(&quot;q-&gt;first:%d&quot;, (int)*(int *)(q-&gt;first(q-&gt;this))); PRINT(&quot;q-&gt;last:%d\\n&quot;, (int)*(int *)(q-&gt;last(q-&gt;this))); PRINT(&quot;q-&gt;dequeue:%d&quot;, (int)*(int *)(q-&gt;dequeue(q-&gt;this))); PRINT(&quot;q-&gt;first:%d&quot;, (int)*(int *)(q-&gt;first(q-&gt;this))); PRINT(&quot;q-&gt;size:%d\\n&quot;, q-&gt;size(q-&gt;this)); PRINT(&quot;q-&gt;dequeue:%d&quot;, (int)*(int *)(q-&gt;dequeue(q-&gt;this))); PRINT(&quot;q-&gt;first:%d&quot;, (int)*(int *)(q-&gt;first(q-&gt;this))); PRINT(&quot;q-&gt;size:%d\\n&quot;, q-&gt;size(q-&gt;this)); PRINT(&quot;q-&gt;dequeue the last element&quot;); q-&gt;dequeue(q-&gt;this); PRINT(&quot;q-&gt;size:%d\\n&quot;, q-&gt;size(q-&gt;this)); q-&gt;free( q-&gt;this ); } int main() { test_queue(); return 0; } #endif /*****************************************************************/ /*****************************栈********************************/ typedef struct stack { void *(*first)( struct stack *this ); void *(*last)( struct stack *this ); void (*push)( struct stack *this, void *data ); void *(*pop)( struct stack *this ); int (*size)( struct stack *this ); void (*free)( struct stack *this ); struct link_list *list; struct stack *this; } stack; void *stack_get_first( stack *s ) { if ( !s || !s-&gt;list ) return NULL; return s-&gt;list-&gt;get_first( s-&gt;list ); } void *stack_get_last( stack *s ) { if ( !s || !s-&gt;list ) return NULL; return s-&gt;list-&gt;get_last( s-&gt;list ); } void stack_push( stack *s, void *data ) { if ( !s || !s-&gt;list ) return ; s-&gt;list-&gt;insert( s-&gt;list, data ); } void *stack_pop( stack *s ) { if ( !s || !s-&gt;list ) return NULL; s-&gt;list-&gt;del( s-&gt;list ); } int stack_size( stack *s ) { if ( !s || !s-&gt;list) return 0; return s-&gt;list-&gt;size; } void stack_free( stack *s ) { if ( !s ) return ; if ( !s-&gt;list ) { free( s ); return; } while ( s-&gt;pop( s-&gt;this ) ); free( s-&gt;list ); free( s ); } stack *create_stack() { stack *s = NULL; s = ( stack * )malloc( sizeof(stack) ); s-&gt;first = stack_get_first; s-&gt;last = stack_get_last; s-&gt;push = stack_push; s-&gt;pop = stack_pop; s-&gt;size = stack_size; s-&gt;free = stack_free; s-&gt;list = ( link_list * )malloc( sizeof(link_list) ); s-&gt;list-&gt;size = 0; s-&gt;list-&gt;insert = insert_tail; s-&gt;list-&gt;get_first = get_tail; s-&gt;list-&gt;get_last = get_head; s-&gt;list-&gt;del = del_tail; s-&gt;this = s; } #define DEBUG_STACK #ifdef DEBUG_STACK void test_stack() { stack *s = create_stack(); int data1 = 5; int data2 = 6; int data3 = 7; s-&gt;push(s-&gt;this, (void *)&amp;data1); PRINT(&quot;s-&gt;first:%d&quot;, *(int *)s-&gt;first(s-&gt;this)); s-&gt;push(s-&gt;this, (void *)&amp;data2); PRINT(&quot;s-&gt;first:%d&quot;, *(int *)s-&gt;first(s-&gt;this)); s-&gt;push(s-&gt;this, (void *)&amp;data3); PRINT(&quot;s-&gt;first:%d\\n&quot;, *(int *)s-&gt;first(s-&gt;this)); PRINT(&quot;s-&gt;size:%d\\n&quot;, s-&gt;size(s-&gt;this)); PRINT(&quot;s-&gt;last:%d&quot;, (int)*(int *)(s-&gt;last(s-&gt;this))); PRINT(&quot;s-&gt;first:%d\\n&quot;, (int)*(int *)(s-&gt;first(s-&gt;this))); PRINT(&quot;s-&gt;pop:%d&quot;, (int)*(int *)(s-&gt;pop(s-&gt;this))); PRINT(&quot;s-&gt;first:%d&quot;, (int)*(int *)(s-&gt;first(s-&gt;this))); PRINT(&quot;s-&gt;size:%d\\n&quot;, s-&gt;size(s-&gt;this)); PRINT(&quot;s-&gt;pop:%d&quot;, (int)*(int *)(s-&gt;pop(s-&gt;this))); PRINT(&quot;s-&gt;first:%d&quot;, (int)*(int *)(s-&gt;first(s-&gt;this))); PRINT(&quot;s-&gt;size:%d\\n&quot;, s-&gt;size(s-&gt;this)); PRINT(&quot;s-&gt;pop the first element&quot;); s-&gt;pop(s-&gt;this); PRINT(&quot;s-&gt;size:%d\\n&quot;, s-&gt;size(s-&gt;this)); s-&gt;free( s-&gt;this ); } int main() { test_stack(); return 0; } #endif","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://lkness/tags/数据结构-算法/"}]},{"title":"外排序多路归并+败者树-算法学习笔记十五","slug":"026out-sort/index","date":"2018-06-20T04:40:53.000Z","updated":"2018-06-20T04:46:12.233Z","comments":true,"path":"2018/06/20/026out-sort/index/","link":"","permalink":"http://lkness/2018/06/20/026out-sort/index/","excerpt":"","text":"问题：一个文件有大量的数，现要对文件排序，但内存无法一次读取完全，而磁盘空间足够，要如何排序。 学习了几篇博客： july大神的海量数据排序(他的其他博客都很值得看) 对july大神的算法进行改进不用选择法而是败者树的博客 以及另一篇但不知道是否为原创的博客 还有生成不重复乱序m-n的数的博客(先生成m-n的数，然后洗牌算法) #以上几篇博客写得很完全了，看懂了思路，自己临摹写一个简单的测试 ….先用生成随机数的代码生成data.txt待排序大文件: //生成随机的不重复的测试数据 #include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;assert.h&gt; #include &lt;stdlib.h&gt; // RAND_MAX using namespace std; //产生[i,u]区间的随机数 int randint(int l, int u) { int a = RAND_MAX * rand(); int b = rand(); //取低31位 int c = ( a + b ) &amp; (0x7fffffff) % ( u - l + 1 ); int d = l + c; return d; } const int size = 10000000; // const int size = 10; int num[size]; int main() { srand((int)time(NULL)); int i, j; FILE *fp = fopen(&quot;data.txt&quot;, &quot;w&quot;); assert(fp); for (i = 0; i &lt; size; i++) num[i] = i+1; // printf(&quot;rand_max:%d\\n&quot;, RAND_MAX); for (i = 0; i &lt; size; i++) { j = randint(i, size-1); // printf(&quot;%d &quot;, j); fflush(stdout); int t = num[i]; num[i] = num[j]; num[j] = t; //swap(num[i], num[j]); } // printf(&quot;\\n&quot;); for (i = 0; i &lt; size; i++) fprintf(fp, &quot;%d\\n&quot;, num[i]); fclose(fp); return 0; } 对data.txt文件开始外排序: #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt; #include &lt;time.h&gt; #define TEMP_PREFIX &quot;ftemp_&quot; #define OUTPUT_FILE &quot;out_data.txt&quot; #define MAX_WAYS 100 // 无穷大，用于某一路文件或缓冲区读到尾了 // 败者树产生一个注定失败的结点 #define INFINITY 1000000000 int *buf; int lst[MAX_WAYS]; void read_data(FILE *fp, int *buf) { if ( fscanf(fp, &quot;%d &quot;, buf) == EOF ) *buf = INFINITY; } int partition( int *arr, int p, int r ) { int x = arr[r]; int i = p - 1; int j = 0, temp; for ( j = p; j &lt;= r - 1; j++ ) { if ( arr[j] &lt;= x ) { i += 1; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } temp = arr[i + 1]; arr[i + 1] = arr[r]; arr[r] = temp; return i + 1; } void quick_sort( int *arr, int p, int r ) { if ( p &lt; r ) { int q = partition( arr, p, r ); quick_sort( arr, p, q - 1 ); quick_sort( arr, q + 1, r ); } } void adjust( int k, int s ) { // t为结点s在败者树数组的父结点， // 例如64路归并，输入63/62，他们 // 的父结点均为 63 int t = ( k + s ) / 2; while ( t &gt; 0 ) { if ( s == -1 ) { break; } // 第一趟，输入一个叶子结点s，让s与父结点的值比较 // （这里父结点一定保存上一次比较的较大者），如果s // 大于父结点的值，表示s为新的败者，将表示s结点的 // 索引放到父结点处，胜者（父结点）继续到更上层的 // 父结点进行比较，这样比较完后，顶点一定放置的最 // 小的值 // 将败者树想象为一场淘汰赛，假如有8个参赛者入口， // 8个参赛者编号1-8，第一轮（即初始化败者树），假 // 设产生了2/4/6/8四强败者，放置到8个入口上一层（ // 即父结点），然后再产生两强败者5/7，放置到更上一 // 层的结点，然后产生最后的失败者1，而剩余的8就是最 // 终的胜者，这样一棵败者树就初始化好了， // 8个入口，之后我们可以随便哪个入口加入一个参赛者， // 这个参赛者只需要与父结点进行比较，败者留下，胜者 // 可以往更高的父结点去参加比赛....这样每一轮进入一 // 个参赛者，每次能得到一个新的冠军(最小值)，然后写入 // 文件末尾 // 这里的8其实就是8路归并，这个入口的参赛者每次就去 // 读取8个排好序的文件或缓冲区 if ( buf[s] &gt; buf[lst[t]] ) { int temp = s; s = lst[t]; lst[t] = temp; } t &gt;&gt;= 1; } // 以2^n次方来算，顶层败者编号为1，所以败者树数组lst[0]一定 // 没存东西，可以用来存放最后的冠军 lst[0] = s; } void create_loser_tree(int k) { int i = 0; for( i; i &lt; k; i++ ) { lst[i] = -1; } for( i = k - 1; i &gt;= 0; i-- ) { adjust(k, i); } } void k_merge( int k ) { int i = 0; FILE **ftemp = ( FILE * )malloc( sizeof(FILE *) * k ); FILE *fout = NULL; // 归并路数大小的数组，每个数组值存放每一个归并路文件读取的 // 一个值，某一个索引的值写入输出文件，又读取对应文件下一个 // 值补充 buf = ( int * )malloc( sizeof(int) * k ); fout = fopen( OUTPUT_FILE, &quot;w+&quot; ); for ( i; i &lt; k; i++ ) { char file_name[20] = {0}; snprintf( file_name, sizeof(file_name), TEMP_PREFIX&quot;%d&quot;, i ); ftemp[i] = fopen( file_name, &quot;r&quot; ); // 读取每个排序好的临时文件第一个数 fscanf( ( FILE * )ftemp[i], &quot;%d &quot;, buf + i ); } // 以排好序文件第一个数的数组来创建败者树， // 树结点产生败者，这样以后的每轮比较只需要 // 去文件或缓冲区读取下一个值加入败者树入口即可 create_loser_tree( k ); // 开始归并， 哪一个入口产生的冠军，先把冠军写入输出文件， // 然后冠军所属的文件或缓冲区再读入一个数进行比赛，如果某一路 // 文件或缓冲区读到尾了，那么这个入口的参赛者为无限大，这样 // 与之共有一个父结点的兄弟结点每次读取的值都能成为胜者，参加 // 父结点以上的比较，到所有节点都读完时，最终败者结点，即lst[1] // 为无穷大，再加入一个参赛者，lst[0]也为无穷大了， while ( buf[lst[0]] != INFINITY ) { // 读取冠军的值 int q = lst[0]; // 将冠军写入输出文件 fprintf(fout, &quot;%d\\n&quot;, buf[q]); // 读取冠军所属队列（文件或缓冲区）的下一个值 read_data(ftemp[q], &amp;buf[q]); // 加入了一个新参赛者，调整败者树 adjust(k, q); } // 清理 free( buf ); for ( i = 0; i &lt; k; i++ ) { fclose(ftemp[i]); } } void memory_sort_small_file( FILE *fp, int num, // 待排序数的数量 int k ) { int i = 0; int num_per_ways = num / k; // 每一路多少个数 int *buf = NULL; FILE **ftemp = ( FILE * )malloc( sizeof(FILE *) * k ); buf = ( int * )malloc( sizeof(int) * num_per_ways + 1000 ); // for ( i = 0; i &lt; k; i++ ) { // char temp_buf[20] = {0}; // snprintf( temp_buf, sizeof(temp_buf), TEMP_PREFIX&quot;%d&quot;, i); // ftemp[i] = fopen( temp_buf, &quot;w+&quot; ); // if ( ftemp[i] == NULL ) { // printf(&quot;[%s:%d],error occured!!(%s)\\n&quot;, __func__, __LINE__, strerror(errno)); // exit( 0 ); // } // } // 先不处理最后一个，可能总数/k路带余数，多余的 // 留到最后一个文件处理 k--; while ( k &gt; 0 ) { char temp_buf[20] = {0}; snprintf( temp_buf, sizeof(temp_buf), TEMP_PREFIX&quot;%d&quot;, k); ftemp[k] = fopen( temp_buf, &quot;w+&quot; ); if ( ftemp[k] == NULL ) { printf(&quot;[%s:%d],error occured!!(%s)\\n&quot;, __func__, __LINE__, strerror(errno)); exit( 0 ); } i = 0; memset( buf, 0, sizeof(buf) ); for ( i; i &lt; num_per_ways; i++ ) { fscanf(fp, &quot;%d &quot;, &amp;buf[i]); } printf(&quot;%s:%d, K:%d\\n&quot;, __func__, __LINE__, k); quick_sort( buf, 0, num_per_ways - 1 ); for ( i = 0; i &lt; num_per_ways; i++ ) { fprintf(ftemp[k], &quot;%d &quot;, buf[i]); } fclose( ftemp[k] ); k--; } // 处理剩余的最后一个待排序文件 char temp_buf[20] = {0}; snprintf( temp_buf, sizeof(temp_buf), TEMP_PREFIX&quot;%d&quot;, 0); ftemp[0] = fopen( temp_buf, &quot;w+&quot; ); if ( ftemp[0] == NULL ) { printf(&quot;[%s:%d],error occured!!(%s)\\n&quot;, __func__, __LINE__, strerror(errno)); exit( 0 ); } i = 0; while ( fscanf(fp, &quot;%d &quot;, &amp;buf[i]) != EOF ) i++; printf(&quot;%s:%d, K:%d\\n&quot;, __func__, __LINE__, 0); quick_sort( buf, 0, i ); int j = 0; for ( j = 0; j &lt;= i; j++ ) { fprintf(ftemp[0], &quot;%d &quot;, buf[j]); } free( buf ); fclose( ftemp[0] ); } int main( int argc, char **argv ) { if ( argc != 3 ) { printf(&quot;usage:\\n\\t./xxx file_name k ways to merge\\n&quot;); exit( 0 ); } int k = atoi( argv[2] ); char *file_name = argv[1]; FILE *fp = fopen(file_name, &quot;r&quot;); if ( fp == NULL ) { printf(&quot;[%s:%d],error occured!!(%s)\\n&quot;, __func__, __LINE__, strerror(errno)); exit( 0 ); } time_t t1 = time(NULL), t2, t3; memory_sort_small_file( fp, 10000000, k ); t2 = time(NULL); k_merge( k ); t3 = time(NULL); printf(&quot;---------------------------finish-----------------------------\\n&quot;); printf(&quot;\\tmemory sort &amp; ouput to temp file cost: %ds\\n&quot;, (int)(t2 - t1)); printf(&quot;\\tk_merge &amp; ouput to file cost: %ds\\n&quot;, (int)(t3 - t2)); printf(&quot;\\ttotal cost time: %ds\\n&quot;, (int)(t3 - t1)); printf(&quot;--------------------------------------------------------------\\n&quot;); fclose( fp ); return 0; } 64路归并排序1000w个数用时： 生成文件： 排序后的文件头和尾： 代码注释写了很多了，以后忘了回头看看也能记起来 …..","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://lkness/tags/数据结构-算法/"}]},{"title":"trie树-《算法导论》学习笔记十四","slug":"025trie-tree/index","date":"2018-06-20T04:34:50.000Z","updated":"2018-06-20T04:38:29.448Z","comments":true,"path":"2018/06/20/025trie-tree/index/","link":"","permalink":"http://lkness/2018/06/20/025trie-tree/index/","excerpt":"","text":"引用一下百度百科的话吧：Trie树，又称单词查找树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。 这里构建了一棵字典树，每个结点有52个孩子指针，对应26个小写字母和26个大写字母，根节点不存储数据，一个单词从第一个字母开始经由根结点走对应分支进行插入和统计。 trie树结点卫星数据包含了字母、出现次数、是否构成一个单词，孩子指针就是一个52大小的trie树结点指针数组。 实现了几个操作： 插入单词 遍历每个字母，从根结点出发，如果结点对应字母的孩子结点为空，就创建结点，出现次数为1，如果存在这个结点，出现次数就+1，并且如果单词结束，结束处的结点是否构成一个单词字段标识为构成 遍历树，并打印所有单词和每个单词出现次数统计树，按给定的数字统计出现次数前几的单词 树统计，与遍历类似，用尾递归，并传入一个大于单词最大长度的数组来存储每个分支的单词，如果遇到结点能构成一个单词，就判断你单词个数，并以插入排序的方式插入创建的统计链表（类似打扑克的插排序）； 统计链表有更新操作，根据输入的统计前几的数字来维护这个链表该去掉哪些结点，该更新哪些结点的顺序等 ##获取单词来源为编写的一个简单单词随机生成代码，写入一个文件中，可指定单词最大长度，全大写/全小写/大小写均有，单词个数，单词范围（只支持a-或A-，例如5，就是生成a-e/A-E的单词）贴代码：随机生成单词 #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;time.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; int word_len = 0; int upper_low = 65; int lowwer_low = 97; // if letter_size = 5 // it will generate a-e or A-E letter. int letter_size = 0; int random_letter() { return rand() % letter_size; } int random_word( char *word, int opt ) { // minimum word&apos;length is 3. int true_word_len = rand() % word_len + 3; int true_word_len1 = true_word_len; while ( true_word_len-- ) { char letter = 0; if ( opt == 0 ) { letter = random_letter() + lowwer_low; } else if ( opt == 1 ) { letter = random_letter() + upper_low; } else { int opt_case = rand() % 2; if ( opt_case == 0 ) letter = random_letter() + lowwer_low; else letter = random_letter() + upper_low; } word[true_word_len] = letter; } return true_word_len1; } void gen_word( int fd, int word_num, int opt ) { char word[20] = {0}; int true_word_len = 0; while ( word_num-- ) { memset( word, 0, 20); true_word_len = random_word( word, opt ); word[true_word_len] = &apos;\\n&apos;; write( fd, word, true_word_len + 1 ); } } int main( int argc, char **argv ) { srand((int)time(NULL)); if ( argc != 5 ) { printf(&quot;please input &quot; &quot;word&apos;s length &amp; &quot; &quot;words&apos; number &amp; &quot; &quot;word&apos;s range &amp; &quot; &quot;gen_case(0:lowwer case,1:upper case,other:both\\n&quot;); exit( 0 ); } word_len = atoi( argv[1] ); int word_num = atoi( argv[2] ); letter_size = atoi( argv[3] ); int opt = atoi( argv[4] ); int fd = open(&quot;word.txt&quot;, O_RDWR | O_TRUNC, 0777); gen_word( fd, word_num, opt ); close( fd ); return 0; } trie树 #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;errno.h&gt; #define MAX_CHILD_NUM 52 #define UPPER_LOW 65 #define UPPER_UP 90 #define LOWER_LOW 97 #define LOWER_UP 122 #define PRINT(format, arg...) \\ do { \\ printf(&quot;[%s/%d]:&quot;, __func__, __LINE__); \\ printf(format, ##arg); \\ printf(&quot;\\n&quot;); \\ }while(0) typedef struct trieTreeNode { char letter; int count; int is_word; struct trieTreeNode *next[MAX_CHILD_NUM]; } trieTreeNode; typedef struct trieTree { trieTreeNode *root; } trieTree; typedef struct count_data { int order; int count; char string[20]; struct count_data *next; } count_data; int trans_letter_2_index( char letter ) { int index = -1; if ( letter &gt;= LOWER_LOW &amp;&amp; letter &lt;= LOWER_UP ) { index = letter - LOWER_LOW + 26; } else if ( letter &gt;= UPPER_LOW &amp;&amp; letter &lt;= UPPER_UP ) { index = letter - UPPER_LOW; } else { PRINT(&quot;error letter input:%c&quot;, letter); exit( 0 ); } return index; } trieTreeNode *create_node( char letter ) { trieTreeNode *node = ( trieTreeNode * )calloc( 1, sizeof(trieTreeNode) ); node-&gt;letter = letter; node-&gt;count = 0; node-&gt;is_word = 0; } void insert( trieTreeNode *root, char *word ) { if ( root == NULL ) { PRINT(&quot;root node is null.&quot;); return; } int i = 0; trieTreeNode *cur = root; for ( i; word[i] != &apos;\\0&apos;; i++ ) { int next_index = trans_letter_2_index(word[i]); //PRINT(&quot;letter:%c, index:%d&quot;, word[i], next_index); if ( cur-&gt;next[next_index] == NULL ) { cur-&gt;next[next_index] = create_node( word[i] ); } else { //cur-&gt;next[next_index]-&gt;count += 1; } if ( word[i+1] == &apos;\\0&apos; ) { cur-&gt;next[next_index]-&gt;count += 1; cur-&gt;next[next_index]-&gt;is_word = 1; } cur = cur-&gt;next[next_index]; } } // 删除链表所有结点 void delete_list_all_node( count_data *node ) { count_data *p = NULL; while ( node ) { p = node; node = node-&gt;next; free( p ); } } void print_list_all_node( count_data *node ) { printf(&quot;\\n&quot;); node = node-&gt;next; while ( node ) { printf(&quot;[%d],count:%d\\tword:%s\\n&quot;, node-&gt;order, node-&gt;count, node-&gt;string); node = node-&gt;next; } printf(&quot;\\n&quot;); } void update_insert_node( count_data *insert_node ) { if ( !insert_node-&gt;next ) return; count_data *print_p = insert_node; if ( insert_node-&gt;order == 1 ) { delete_list_all_node( insert_node-&gt;next ); insert_node-&gt;next = NULL; } else if ( insert_node-&gt;order &lt; 1 ) { PRINT(&quot;ERROR!!!!!&quot;); exit( 0 ); } else { count_data *p = insert_node; insert_node = insert_node-&gt;next; while ( insert_node ) { if ( insert_node-&gt;count &lt; p-&gt;count ) { insert_node-&gt;order = p-&gt;order - 1; } else if ( insert_node-&gt;count &gt; p-&gt;count ) { PRINT(&quot;ERROR!!!cur-&gt;count:%d, pre-&gt;count:%d&quot;, insert_node-&gt;count, p-&gt;count); exit( 0 ); } else { insert_node-&gt;order = p-&gt;order; } if ( insert_node-&gt;order &lt; 1 ) { delete_list_all_node( insert_node ); p-&gt;next = NULL; break; } p = insert_node; insert_node = insert_node-&gt;next; } } } void list_insert( char *tmp_word, int cur_count, int tail, count_data *head, int top_num ) { tmp_word[tail] = &apos;\\0&apos;; count_data *new_data = ( count_data * )malloc( sizeof(count_data) ); new_data-&gt;count = cur_count; memcpy( new_data-&gt;string, tmp_word, tail + 1 ); new_data-&gt;next = NULL; //PRINT(&quot;count:%d\\ttmp_word:%s, string:%s&quot;, cur_count, tmp_word, new_data-&gt;string); if ( head-&gt;next == NULL ) { head-&gt;next = new_data; new_data-&gt;order = top_num; } else if ( cur_count &gt; head-&gt;next-&gt;count ) { new_data-&gt;order = head-&gt;next-&gt;order; new_data-&gt;next = head-&gt;next; head-&gt;next = new_data; update_insert_node( new_data ); } else { while ( 1 ) { head = head-&gt;next; if ( head-&gt;next == NULL ) { if ( head-&gt;order &gt; 1 ) { head-&gt;next = new_data; if ( head-&gt;count == new_data-&gt;count ) new_data-&gt;order = head-&gt;order; else new_data-&gt;order = head-&gt;order - 1; head-&gt;next = new_data; } else if ( head-&gt;count &gt; new_data-&gt;count ) { // 不插入 free( new_data ); } else if ( head-&gt;count == new_data-&gt;count ) { head-&gt;next = new_data; new_data-&gt;order = head-&gt;order; } else if ( head-&gt;count &lt; new_data-&gt;count ) { // 此种情况只有求出现次数最多的前1个单词时有 head-&gt;count = new_data-&gt;count; free( new_data ); } break; } else if ( head-&gt;count &gt;= cur_count &amp;&amp; head-&gt;next-&gt;count &lt; cur_count ) { new_data-&gt;next = head-&gt;next; head-&gt;next = new_data; new_data-&gt;order = head-&gt;order; update_insert_node( new_data ); break; } } } } void find_top_count1( trieTreeNode *root, char *tmp_word, int tail, count_data *head, int top_num ) { if ( !root ) return; tmp_word[tail] = root-&gt;letter; tail++; if ( root-&gt;is_word ) { /* printf(&quot;\\n--------------before delete------------------\\n&quot;); print_list_all_node( head ); printf(&quot;\\n--------------------------------------------\\n&quot;); */ list_insert( tmp_word, root-&gt;count, tail, head, top_num ); /* printf(&quot;\\n--------------------after delete----------------------------\\n&quot;); print_list_all_node( head ); printf(&quot;\\n-----------------------------------------------------------\\n&quot;); */ } int i = 0; for ( i; i &lt; MAX_CHILD_NUM; i++ ) { find_top_count1( root-&gt;next[i], tmp_word, tail, head, top_num ); } } void find_top_count( trieTreeNode *root, int top_num ) { if ( !root ) return; int i = 0; count_data *head = ( count_data * )malloc( sizeof(count_data) ); for ( i; i &lt; MAX_CHILD_NUM; i++ ) { char tmp_word[20] = {0}; find_top_count1( root-&gt;next[i], tmp_word, 0, head, top_num ); } printf(&quot;出现次数最大前%d次的单词:\\n&quot;, top_num); count_data *p = head-&gt;next; count_data *free_p = NULL; while ( p != NULL ) { free_p = p; printf(&quot;前%d,count:%d\\t%s\\n&quot;, p-&gt;order, p-&gt;count, p-&gt;string); p = p-&gt;next; free( free_p ); } free( head ); } void tree_walk1( trieTreeNode *root, char *tmp_word, int tail ) { if ( !root ) return; tmp_word[tail] = root-&gt;letter; tail++; //printf(&quot;%c\\n&quot;, root-&gt;letter); if ( root-&gt;is_word ) { int j = 0; printf(&quot;count:%d\\t&quot;, root-&gt;count); for ( j; j &lt; tail; j++ ) { printf(&quot;%c&quot;, tmp_word[j]); } printf(&quot;\\n&quot;); } int i = 0; for ( i; i &lt; MAX_CHILD_NUM; i++ ) { tree_walk1( root-&gt;next[i], tmp_word, tail ); } } void tree_walk( trieTreeNode *root ) { if ( !root ) return; int i = 0; for ( i; i &lt; MAX_CHILD_NUM; i++ ) { char tmp_word[20] = {0}; tree_walk1( root-&gt;next[i], tmp_word, 0 ); } } int main( int argc, char **argv ) { if ( argc != 3 ) { PRINT(&quot;USAGE: please input words file &amp; top number&quot;); exit( 0 ); } char *file_name = argv[1]; int top_num = atoi( argv[2] ); trieTree *tree = ( trieTree * )malloc( sizeof(trieTree) ); tree-&gt;root = create_node( -1 ); int fd = open(file_name, O_RDONLY); if ( fd &lt; 0 ) { PRINT(&quot;OPEN FILE %s ERROR!!!(%s)&quot;, file_name, (char *)strerror(errno)); exit( 0 ); } // 每次读取文件的缓冲区 char buf[1024 * 10] = {0}; // 每次读取的大小 int read_len = 1024; // 读取的返回值 int read_bytes = 0; // 从读取的缓冲区每次提取&apos;\\n&apos; - &apos;\\n&apos;之间的单词 char tmp_word[20] = {0}; // 读取文件缓冲区如果出现单词隔断，剩余部分在下一次 // read才能读到，这个index做单词继续拼接 int tmp_index = 0; while ( 1 ) { memset( buf, 0, read_len ); read_bytes = read( fd, buf, read_len ); if ( read_bytes &lt;= 0 ) break; //printf(&quot;readbytes:%d------\\n%s\\n&quot;, read_bytes, buf); int cur = 0; while ( cur &lt; read_bytes ) { // 单词文件最后一个单词末尾一定要有&apos;\\n&apos; if ( buf[cur] == &apos;\\n&apos; ) { tmp_word[tmp_index] = &apos;\\0&apos;; //printf(&quot;insert word:%s\\n&quot;, tmp_word); insert( tree-&gt;root, tmp_word ); memset( tmp_word, 0, 20 ); tmp_index = 0; } else { tmp_word[tmp_index] = buf[cur]; tmp_index++; } cur++; } } printf(&quot;\\n========================================\\n&quot;); tree_walk( tree-&gt;root ); find_top_count( tree-&gt;root, top_num ); close( fd ); return 0; } trie树的代码使用：./xxx word.txt 10即统计出现次数前10的单词，并打印单词和次数 例如对生成了10000个单词的word.txt文件，统计前5：./xxx word.txt 5","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://lkness/tags/数据结构-算法/"}]},{"title":"avl树-《算法导论》学习笔记十三","slug":"024avl-tree/index","date":"2018-06-20T02:55:19.000Z","updated":"2018-06-20T04:39:26.707Z","comments":true,"path":"2018/06/20/024avl-tree/index/","link":"","permalink":"http://lkness/2018/06/20/024avl-tree/index/","excerpt":"","text":"（引用算法导论）AVL树是一种高度平衡的二叉搜索树：对每一个结点x，y的左子树与右子树的高度至多为1。AVL树相比二叉搜索树，每个结点维护一个额外的属性：结点的高度。 AVL树实现了几个操作： 树结点创建遍历 递归的前序、中序、后序遍历，以及基于层序遍历的简单图形打印 后序遍历释放树结点搜索寻找结点子树最小关键字结点、寻找结点子树最大关键字结点求结点高度左旋右旋插入 先以普通二叉搜索树的方式插入结点； 插入结点后可能影响平衡（一个子树高度-另一子树高度等于2），具体的不平衡的情况分四种： 结点左子树高度-右子树高度=2，且结点左孩子的左子树更高 结点左子树高度-右子树高度=2，且结点右孩子的右子树更高 结点右子树高度-左子树高度=2，且结点右孩子的右子树更高 结点右子树高度-左子树高度=2，且结点右孩子的左子树更高 对于情况1，只需对结点进行右旋即可重新平衡； 对于情况3，只需对结点进行左旋即可重新平衡； 对于情况2，需要先对结点的左孩子进行左旋，然后对结点进行右旋即可平衡； 对于情况4，需要先对结点的右孩子进行右旋，然后对结点进行左旋即可平衡； 旋转之后，结点的左子树与右子树达到平衡，但结点父结点的树可能不平衡， 需要循环向根节点判断结点高度有无平衡，直至根节点。 删除 先查询相同的key的结点； 找到待删除结点，如果待删除结点的左孩子与右孩子都不为空，则判断左右孩子的树高： 若左子树更高，则将左子树的最大关键字结点的关键字替换掉待删除结点的关键字，然后再删除那个左子树最大关键字结点 若右子树与左子树同高或更高，则将右子树的最小关键字结点的关键字替换掉待删除节点的关键字，然后再删除那个右子树最小关键字结点 删除结点后，会影响树平衡，具体不平衡情况与插入时相同，依然进行相同操作来重新平衡树 # 代码: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;time.h&gt; #include &lt;math.h&gt; #define MAX(a, b) ((a &gt; b) ? (a) : (b)) typedef struct avlTreeNode { int key; int height; //这里有父结点，有了父结点多很多代码， //大部分的调试都是父结点的值没注意， //可取消这个字段 struct avlTreeNode *parent; struct avlTreeNode *left; struct avlTreeNode *right; }avlTreeNode; typedef struct avlTree { int node_num; avlTreeNode *root; }avlTree; // 随机基数尽量大，代码不支持key值相同的 // 树节点，但不影响插入，删除会出错，所以 // 尽量保证不同 int random_num() { int a = 1; int b = 10000; return rand() % ( b - a ) + a; } avlTreeNode *tree_create_node( int key, avlTreeNode *parent, avlTreeNode *left, avlTreeNode *right ) { avlTreeNode *node = ( avlTreeNode * )malloc( sizeof(avlTreeNode) ); node-&gt;height = 1; node-&gt;key = key; node-&gt;parent = parent; node-&gt;left = left; node-&gt;right = right; return node; } //后续遍历释放树结点 void postorder_tree_free( avlTreeNode *root ) { if ( root != NULL ) { postorder_tree_free( root-&gt;left ); postorder_tree_free( root-&gt;right ); printf(&quot;%d &quot;, root-&gt;key); free( root ); } } void inorder_tree_walk( avlTreeNode *root ) { if ( root != NULL ) { inorder_tree_walk( root-&gt;left ); printf(&quot;%d(%d) &quot;, root-&gt;key, root-&gt;height); inorder_tree_walk( root-&gt;right ); } } void preorder_tree_walk( avlTreeNode *root ) { if ( root != NULL ) { printf(&quot;%d(%d) &quot;, root-&gt;key, root-&gt;height); preorder_tree_walk( root-&gt;left ); preorder_tree_walk( root-&gt;right ); } } void postorder_tree_walk( avlTreeNode *root ) { if ( root != NULL ) { postorder_tree_walk( root-&gt;left ); postorder_tree_walk( root-&gt;right ); printf(&quot;%d(%d) &quot;, root-&gt;key, root-&gt;height); } } //层序遍历，支持简单的树形打印 //为了调试代码，而不用中序和前序 //去推算树 int queue_pre = -1; int queue_post = 0; avlTreeNode *node_queue[1000] = {NULL}; int factor( int n ) { if ( n == 1 ) return 1; return (pow(2,n-1) + factor( n - 1 )); } void graph_tree_walk( avlTreeNode *root, int height, int root_height ) { if ( queue_pre == factor( root_height ) - 1 ) return ; queue_pre++; if ( root == NULL ) { printf(&quot;* &quot;); node_queue[queue_post] = NULL; queue_post++; node_queue[queue_post] = NULL; queue_post++; } else { node_queue[queue_post] = root-&gt;left; queue_post++; node_queue[queue_post] = root-&gt;right; queue_post++; printf(&quot;%d &quot;, root-&gt;key); } int new_height = height; if ( queue_pre == factor( height ) - 1 ) { printf(&quot;\\n&quot;); new_height = height + 1; } graph_tree_walk( node_queue[queue_pre], new_height, root_height ); } void print_tree( avlTree *tree ) { printf(&quot;中序:&quot;); inorder_tree_walk( tree-&gt;root ); printf(&quot;\\n&quot;); printf(&quot;前序:&quot;); preorder_tree_walk( tree-&gt;root ); printf(&quot;\\n&quot;); printf(&quot;后序:&quot;); postorder_tree_walk( tree-&gt;root ); printf(&quot;\\n&quot;); printf(&quot;图形:\\n&quot;); graph_tree_walk( tree-&gt;root, 1, tree-&gt;root-&gt;height ); queue_pre = -1; queue_post = 0; int i = 999; for ( i ; i &gt;=0; i-- ) node_queue[i] = NULL; printf(&quot;\\n\\n&quot;); } //检查avl树的树高是否差2以内 int check_is_avltree( avlTreeNode *root ) { if ( root == NULL ) return 0; int left_height = check_is_avltree( root-&gt;left ); int right_height = check_is_avltree( root-&gt;right ); if ( left_height - right_height &gt;= 2 || right_height - left_height &gt;= 2 ) printf(&quot;it&apos;s not a avl tree!!!! l:%d, r:%d\\n&quot;, left_height, right_height); else //printf(&quot;left:%d,right:%d\\n&quot;, left_height, right_height); return (left_height &gt; right_height ? left_height : right_height ) + 1; } avlTreeNode *tree_search_recursion( avlTreeNode *root, int key ) { if ( root == NULL || key == root-&gt;key ) { return root; } if ( key &lt; root-&gt;key ) return tree_search_recursion( root-&gt;left, key ); else return tree_search_recursion( root-&gt;right, key ); } avlTreeNode *tree_search( avlTreeNode *root, int key ) { while ( root != NULL &amp;&amp; key != root-&gt;key ) { if ( key &lt; root-&gt;key ) root = root-&gt;left; else root = root-&gt;right; } return root; } avlTreeNode *tree_minimum( avlTreeNode *root ) { while ( root-&gt;left != NULL ) { root = root-&gt;left; } return root; } avlTreeNode *tree_maximum( avlTreeNode *root ) { while ( root-&gt;right != NULL ) { root = root-&gt;right; } return root; } int node_height( avlTreeNode *node ) { if ( node == NULL ) return 0; return node-&gt;height; } int tree_height( avlTree *tree ) { return node_height( tree-&gt;root ); } avlTreeNode *left_rotate( avlTreeNode *node ) { if ( node != NULL &amp;&amp; node-&gt;right != NULL ) { avlTreeNode *p = node-&gt;right-&gt;left; if ( node-&gt;parent == NULL ) { node-&gt;right-&gt;parent = NULL; } else if ( node == node-&gt;parent-&gt;left ) { node-&gt;parent-&gt;left = node-&gt;right; node-&gt;right-&gt;parent = node-&gt;parent; } else { node-&gt;parent-&gt;right = node-&gt;right; node-&gt;right-&gt;parent = node-&gt;parent; } node-&gt;parent = node-&gt;right; node-&gt;right-&gt;left = node; node-&gt;right = p; if ( p != NULL ) p-&gt;parent = node; node-&gt;height = MAX( node_height(node-&gt;left), node_height(node-&gt;right) ) + 1; node-&gt;parent-&gt;height = MAX( node_height(node-&gt;parent-&gt;left), node_height(node-&gt;parent-&gt;right) ) + 1; return node-&gt;parent; } return node; } avlTreeNode *right_rotate( avlTreeNode *node ) { if ( node != NULL &amp;&amp; node-&gt;left != NULL ) { avlTreeNode *p = node-&gt;left-&gt;right; if ( node-&gt;parent == NULL ) { node-&gt;left-&gt;parent = NULL; } else if ( node == node-&gt;parent-&gt;left ) { node-&gt;parent-&gt;left = node-&gt;left; node-&gt;left-&gt;parent = node-&gt;parent; } else { node-&gt;parent-&gt;right = node-&gt;left; node-&gt;left-&gt;parent = node-&gt;parent; } node-&gt;parent = node-&gt;left; node-&gt;left-&gt;right = node; node-&gt;left = p; if ( p != NULL ) p-&gt;parent = node; node-&gt;height = MAX( node_height(node-&gt;left), node_height(node-&gt;right) ) + 1; node-&gt;parent-&gt;height = MAX( node_height(node-&gt;parent-&gt;right), node_height(node-&gt;parent-&gt;left) ) + 1; return node-&gt;parent; } return node; } avlTreeNode *tree_insert1( avlTreeNode *root, avlTreeNode *node ) { if ( root == NULL ) { node-&gt;height = 1; return node; } else if ( node-&gt;key &lt; root-&gt;key ) { root-&gt;left = tree_insert1( root-&gt;left, node ); root-&gt;left-&gt;parent = root; if ( node_height( root-&gt;left ) - node_height( root-&gt;right ) == 2 ) { if ( node-&gt;key &lt; root-&gt;left-&gt;key ) { // right rotate; root = right_rotate( root ); } else { // left right rotate; root-&gt;left = left_rotate( root-&gt;left ); root = right_rotate( root ); } } root-&gt;height = MAX( node_height(root-&gt;left), node_height(root-&gt;right) ) + 1; } else { root-&gt;right = tree_insert1( root-&gt;right, node ); root-&gt;right-&gt;parent = root; if ( node_height( root-&gt;right ) - node_height( root-&gt;left ) == 2 ) { if ( node-&gt;key &gt;= root-&gt;right-&gt;key ) { root = left_rotate( root ); } else { root-&gt;right = right_rotate( root-&gt;right ); root = left_rotate( root ); } } root-&gt;height = MAX( node_height(root-&gt;right), node_height(root-&gt;left) ) + 1; } return root; } void tree_insert( avlTree *tree, int key ) { avlTreeNode *node = tree_create_node( key, NULL, NULL, NULL ); if ( tree-&gt;root == NULL ) { tree-&gt;root = node; } else { tree-&gt;root = tree_insert1( tree-&gt;root, node ); } } avlTreeNode *tree_delete1( avlTreeNode *root, int key ) { if ( root == NULL ) return NULL; if ( key &lt; root-&gt;key ) { root-&gt;left = tree_delete1( root-&gt;left, key ); if ( node_height(root-&gt;right) - node_height(root-&gt;left) == 2 ) { if ( node_height(root-&gt;right-&gt;left) &gt; node_height(root-&gt;right-&gt;right) ) { root-&gt;right = right_rotate( root-&gt;right ); root = left_rotate( root ); } else { root = left_rotate( root ); } } } else if ( key &gt; root-&gt;key ) { root-&gt;right = tree_delete1( root-&gt;right, key ); if ( node_height(root-&gt;left) - node_height(root-&gt;right) == 2 ) { if ( node_height(root-&gt;left-&gt;right) &gt; node_height(root-&gt;left-&gt;left) ) { root-&gt;left = left_rotate( root-&gt;left ); root = right_rotate( root ); } else { root = right_rotate( root ); } } } else { if ( root-&gt;left != NULL &amp;&amp; root-&gt;right != NULL ) { avlTreeNode *replace = NULL; // 这里做了替换后要删除最大值结点，但匹配无法确认同key值的不同结点 // ，因此树不能有相同key值的结点，但插入没有这个问题 if ( node_height(root-&gt;left) &gt; node_height(root-&gt;right) ) { replace = tree_maximum( root-&gt;left ); root-&gt;key = replace-&gt;key; root-&gt;left = tree_delete1( root-&gt;left, replace-&gt;key ); } else { replace = tree_minimum( root-&gt;right ); root-&gt;key = replace-&gt;key; root-&gt;right = tree_delete1( root-&gt;right, replace-&gt;key ); } } else { avlTreeNode *delete = root; if ( root-&gt;left ) { root-&gt;left-&gt;parent = root-&gt;parent; root = delete-&gt;left; } else if ( root-&gt;right ) { root-&gt;right-&gt;parent = root-&gt;parent; root = delete-&gt;right; } else { root = NULL; } free( delete ); } } if ( root != NULL ) root-&gt;height = MAX( node_height(root-&gt;left), node_height(root-&gt;right) ) + 1; return root; } void tree_delete( avlTree *tree, int key ) { if ( tree-&gt;root != NULL ) { tree-&gt;root = tree_delete1( tree-&gt;root, key ); } } void free_tree( avlTree *tree ) { printf(&quot;\\ndelete tree node...\\n&quot;); postorder_tree_free( tree-&gt;root ); tree-&gt;root = NULL; printf(&quot;\\ndelete tree...\\n&quot;); free( tree ); printf(&quot;free tree over!\\n&quot;); } int main( int argc, char **argv ) { srand((int)time(NULL)); int i = 10; int len = 20; int arr[10] = {10,4,15,14,5, 2,8,13,1,19}; avlTree *tree = ( avlTree * )malloc( sizeof(avlTree) ); int delete_key_a, delete_key_b, delete_key_c; for ( i = 0; i &lt; len; i++ ) { //tree_insert( tree, arr[i] ); int randomnum = random_num(); if ( i == 2 ) delete_key_a = randomnum; if ( i == 5 ) delete_key_b = randomnum; if ( i == 9 ) delete_key_c = randomnum; //printf(&quot;randon num:%d\\n&quot;, randomnum); tree_insert( tree, randomnum ); } print_tree( tree ); check_is_avltree( tree-&gt;root ); printf(&quot;删除结点%d\\n&quot;, delete_key_a); tree_delete( tree, delete_key_a ); print_tree( tree ); check_is_avltree( tree-&gt;root ); tree_delete( tree, delete_key_b ); printf(&quot;删除结点%d\\n&quot;, delete_key_b ); print_tree( tree ); check_is_avltree( tree-&gt;root ); tree_delete( tree, delete_key_c ); printf(&quot;删除结点%d\\n&quot;, delete_key_c ); print_tree( tree ); check_is_avltree( tree-&gt;root ); printf(&quot;\\n===========================================free================================================\\n&quot;); free_tree( tree ); return 0; }","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://lkness/tags/数据结构-算法/"}]},{"title":"红黑树-《算法导论》学习笔记十二","slug":"023red-black-tree/index","date":"2018-06-19T12:38:53.000Z","updated":"2018-06-20T04:39:52.623Z","comments":true,"path":"2018/06/19/023red-black-tree/index/","link":"","permalink":"http://lkness/2018/06/19/023red-black-tree/index/","excerpt":"","text":"红黑树是一种二叉搜索树，它在每个结点上增加了一个存储为来表示结点的颜色，或红或黑，通过从根到叶子的简单路径上各个结点的颜色进行约束，红黑树确保没有一条路径会比其它路径长出2倍，近似平衡的。 树种每个结点包含5个属性：color、key、left、right、parent，如果一个结点没有子结点或父结点，则该结点相应指针属性值指向空（这里的空不是空指针，而是定义一个空结点，结点颜色为黑色），一颗红黑树是满足几个特殊性质的二叉搜索树： 每个结点或是红色的，或是黑色的 根结点是黑色的 每个叶结点（亦即空结点）为黑色的 如果一个结点是红色的，则它的两个子结点都是黑色的 对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点（经过的黑色结点数为黑高） 与二叉搜索树相似，红黑树也有一些操作接口： 遍历 寻找结点中序遍历的后继:tree_minimum 寻找结点中序遍历的前驱:tree_maximum 结点左右旋转（红黑树不同于二叉搜索树的操作），用来平衡黑高 左旋：结点的父结点的左孩子指向结点的右孩子，右孩子的左孩子变为结点的右孩子，右孩子变为它的父结点 右旋：结点的父结点的右孩子指向结点的左孩子，做孩子的右孩子变为结点的左孩子，左孩子变为它的父结点* 插入，插入一个新结点时，考虑如果插入黑色结点，破坏了原树的红黑性质（黑高），要进行重新平衡 删除，删除了一个结点后，考虑如果删除的是黑色结点，或删除了结点，后继提升到删除节点的位置后，平衡红黑性质 ———-插入 如果结点的父结点为黑色，表示没插入这个结点前满足红黑树性质，且插入这个红色结点后，也不影响红黑树黑高，故保持当前位置 如果结点的父结点为红色，那么判断插入结点与父结点，以及父结点的父结点，叔结点，这四个结点是否组成一个倒立的”v”字形： (1). 如果是倒立”v”，则插入结点的父结点为红色，破坏了红黑树的：红色结点的左右孩子都为黑色的性质，故父结点一定要变为黑色;那么将父结点变为黑色; 判断叔结点若为红色，则将叔结点变为黑色，父结点的父结点变为红色，插入结点的指针指向父结点的父结点，再次从步骤1判断（因为经过变换，从插入结点的父结点的父结点开始的子数都满足红黑树性质，只需要将父结点的父结点单独当作一个新插入它的父结点的子结点再进行处理即可）; 否则叔结点为黑色，则直接将父结点的父结点变为红色，但是这样做之后，父结点因为变为黑色，而叔结点还是黑色，两个子树路径的黑高相差1,要维持黑高相等，则将父结点的父结点的父结点向叔结点相同的方向旋转（可以针对这种情况画图，会发现这样旋转后，两个黑高不一样的子树分开了，，且满足红黑树性质）。 (2). 如果不是倒立”v”，即插入结点的父结点所处子树为某方向上的子树，但插入结点又是父结点另一方的孩子结点，则只需要进行一下旋转，就将结点变为倒立的”v”形状，继续从步骤1开始作为倒立”v”子树判断。 将根结点变为黑色 ———-删除 以指针p指向待删除结点node，p_color记录node颜色 判断node的左右孩子 (1). 如果左孩子为空寻找node的右孩子，记为q（不管是否指向空）用q结点替换node结点 (2). 但如果右孩子为空寻找node的左孩子，记为q（不管是否指向空）用q结点替换node结点 (3). 否则左右孩子都不为空寻找node的中序遍历后继(tree_minimum())，p指向它; p_color记录后继的颜色; q指向p的右结点（不管是否为空）; 判断p的父结点是否为node:是，则， q的父结点设为p（只有当q为空结点时有用）/否，则，用p的右结点替换p(rb_transplant(tree, p, p-&gt;right))，用p结点接管node结点右子树（p-&gt;right = node-&gt;right, p-&gt;right-&gt;parent = p）; 用p结点替换node结点(rb_transplant(tree, node, p)); p结点接管node结点左子树(p-&gt;left = node-&gt;left,p-&gt;left-&gt;parent = p); p结点的颜色设置为node结点的颜色 判断p_color的颜色如果为黑色，表示删除结点后，黑高可能-1,要修复红黑树，从结点q处开始修复红黑树，根据q的颜色来修复 循环.直到q结点不为根结点以及p结点的颜色不为黑色 (1). 如果node的兄弟结点为红色（因为node结点替换了删除结点，黑高-1,与兄弟结点子树黑高差1）设置兄弟结点为黑色，父结点设置为红色，从父结点开始向node一侧旋转，兄弟结点成为新的子树根结点，因为兄弟结点为黑色，则经过兄弟结点到node结点的子树黑高+1,平衡，但对于兄弟结点的父结点的子树，黑高又可能不平衡，node指针指向兄弟结点，继续步骤4 (2). 如果node的兄弟结点为黑色，且兄弟结点的左右孩子均为黑色（因为node结点替换了删除结点，黑高-1,与兄弟结点子树黑高差1）设置兄弟结点颜色为红色，兄弟结点子树黑高-1,达到平衡，但父结点以上的子树可能受影响，node指针指向父结点，继续步骤4 (3). 如果node的兄弟结点为黑色，且兄弟结点的靠近node一侧的孩子结点颜色为红色，另一侧的孩子结点为黑色（因为node结点替换了删除结点，黑高-1,与兄弟结点子树黑高差1）兄弟结点靠近node一侧的孩子结点设置为黑色，兄弟结点设置为红色，从兄弟结点开始进行向远离node一侧旋转，兄弟结点的孩子结点成为它的父结点，原兄弟结点的左右子树黑高不变，但node结点所处子树因为替换删除结点，黑高-1，还是没有平衡，node指针指向新的兄弟结点的孩子结点，继续4 (4). 如果node的兄弟结点为黑色，且兄弟结点的远离node一侧的孩子结点颜色为红色，另一侧颜色未知（因为node结点替换了删除结点，黑高-1,与兄弟结点子树黑高差1）兄弟结点设置为node父结点的颜色，父结点设置为黑色，兄弟结点为红色的设置为黑色，然后从node父结点开始进行向node一侧旋转，旋转前，可以思考，父结点若为红色，旋转后不改变子树黑高，若父结点为黑色，旋转后也不会改变黑高经过一轮变换后，node结点的父结点的父结点左右子树黑高一样，且经过node替换后-1的黑高，因为变换，又+1,本子树在整个红黑树中没有破坏黑高一致性，故将node指针指向整个树的根结点，跳出循环设置node指针的结点颜色为黑色 代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;time.h&gt; //#define COLOR_RED 1; //#define COLOR_BLACK 2; typedef enum color { COLOR_RED, COLOR_BLACK }color; typedef struct rbTreeNode { int key; color color; struct rbTreeNode *parent; struct rbTreeNode *left; struct rbTreeNode *right; }rbTreeNode; typedef struct rbTree { int node_num; int height; rbTreeNode *root; rbTreeNode *null; }rbTree; void print_tree( rbTree * ); rbTreeNode *tree_minimum( rbTreeNode *root, rbTreeNode *null ) { while ( root-&gt;left != null ) { root = root-&gt;left; } return root; } rbTreeNode *tree_maximum( rbTreeNode *root, rbTreeNode *null ) { while ( root-&gt;right != null ) { root = root-&gt;right; } return root; } void left_rotate( rbTree *tree, rbTreeNode *node ) { rbTreeNode *p = node-&gt;right; node-&gt;right = p-&gt;left; if ( p-&gt;left != tree-&gt;null ) p-&gt;left-&gt;parent = node; p-&gt;parent = node-&gt;parent; if ( node-&gt;parent == tree-&gt;null ) tree-&gt;root = p; else if ( node == node-&gt;parent-&gt;left ) node-&gt;parent-&gt;left = p; else node-&gt;parent-&gt;right = p; p-&gt;left = node; node-&gt;parent = p; } void right_rotate( rbTree *tree, rbTreeNode *node ) { rbTreeNode *p = node-&gt;left; node-&gt;left = p-&gt;right; if ( p-&gt;right != tree-&gt;null ) p-&gt;right-&gt;parent = node; p-&gt;parent = node-&gt;parent; if ( node-&gt;parent == tree-&gt;null ) tree-&gt;root = p; else if ( node == node-&gt;parent-&gt;right ) node-&gt;parent-&gt;right = p; else node-&gt;parent-&gt;left = p; p-&gt;right = node; node-&gt;parent = p; } void rb_insert_fixup( rbTree *tree, rbTreeNode *node ) { rbTreeNode *p = tree-&gt;null; while ( node-&gt;parent-&gt;color == COLOR_RED ) { if ( node-&gt;parent == node-&gt;parent-&gt;parent-&gt;left ) { p = node-&gt;parent-&gt;parent-&gt;right; if ( p-&gt;color == COLOR_RED ) { node-&gt;parent-&gt;color = COLOR_BLACK; p-&gt;color = COLOR_BLACK; node-&gt;parent-&gt;parent-&gt;color = COLOR_RED; node = node-&gt;parent-&gt;parent; } else if ( node == node-&gt;parent-&gt;right ) { node = node-&gt;parent; left_rotate( tree, node ); } else { node-&gt;parent-&gt;color = COLOR_BLACK; node-&gt;parent-&gt;parent-&gt;color = COLOR_RED; right_rotate( tree, node-&gt;parent-&gt;parent ); } } else { p = node-&gt;parent-&gt;parent-&gt;left; if ( p-&gt;color == COLOR_RED ) { node-&gt;parent-&gt;color = COLOR_BLACK; p-&gt;color = COLOR_BLACK; node-&gt;parent-&gt;parent-&gt;color = COLOR_RED; node = node-&gt;parent-&gt;parent; } else if ( node == node-&gt;parent-&gt;left ) { node = node-&gt;parent; right_rotate( tree, node ); } else { node-&gt;parent-&gt;color = COLOR_BLACK; node-&gt;parent-&gt;parent-&gt;color = COLOR_RED; left_rotate( tree, node-&gt;parent-&gt;parent ); } } } tree-&gt;root-&gt;color = COLOR_BLACK; } void rb_insert( rbTree *tree, rbTreeNode *node ) { rbTreeNode *p = tree-&gt;null; rbTreeNode *q = tree-&gt;root; while ( q != tree-&gt;null ) { p = q; if ( node-&gt;key &lt; q-&gt;key ) q = q-&gt;left; else q = q-&gt;right; } node-&gt;parent = p; if ( p == tree-&gt;null ) tree-&gt;root = node; else if ( node-&gt;key &lt; p-&gt;key ) p-&gt;left = node; else p-&gt;right = node; node-&gt;left = tree-&gt;null; node-&gt;right = tree-&gt;null; node-&gt;color = COLOR_RED; rb_insert_fixup( tree, node ); } void rb_transplant( rbTree *tree, rbTreeNode *node_a, rbTreeNode *node_b ) { if ( node_a-&gt;parent == tree-&gt;null ) tree-&gt;root = node_b; else if ( node_a == node_a-&gt;parent-&gt;left ) node_a-&gt;parent-&gt;left = node_b; else node_a-&gt;parent-&gt;right = node_b; node_b-&gt;parent = node_a-&gt;parent; free( node_a ); } void rb_delete_fixup( rbTree *tree, rbTreeNode *node ) { rbTreeNode *p = tree-&gt;null; while ( node != tree-&gt;null &amp;&amp; node-&gt;color == COLOR_BLACK ) { if ( node == node-&gt;parent-&gt;left ) { p = node-&gt;parent-&gt;right; if ( p-&gt;color == COLOR_RED ) { p-&gt;color = COLOR_BLACK; node-&gt;parent-&gt;color = COLOR_RED; left_rotate( tree, node-&gt;parent ); p = node-&gt;parent-&gt;right; } else if ( p-&gt;left-&gt;color == COLOR_BLACK &amp;&amp; p-&gt;right-&gt;color == COLOR_BLACK ) { p-&gt;color = COLOR_RED; node = node-&gt;parent; } else if ( p-&gt;right-&gt;color == COLOR_BLACK ) { p-&gt;left-&gt;color = COLOR_BLACK; p-&gt;color = COLOR_RED; right_rotate( tree, p ); p = node-&gt;parent-&gt;right; } else { p-&gt;color = node-&gt;parent-&gt;color; node-&gt;parent-&gt;color = COLOR_BLACK; left_rotate( tree, node-&gt;parent ); node = tree-&gt;root; } } else { p = node-&gt;parent-&gt;left; if ( p-&gt;color == COLOR_RED ) { p-&gt;color = COLOR_BLACK; node-&gt;parent-&gt;color = COLOR_RED; right_rotate( tree, node-&gt;parent ); p = node-&gt;parent-&gt;left; } else if ( p-&gt;left-&gt;color == COLOR_BLACK &amp;&amp; p-&gt;right-&gt;color == COLOR_BLACK ) { p-&gt;color = COLOR_RED; node = node-&gt;parent; } else if ( p-&gt;left-&gt;color == COLOR_BLACK ) { p-&gt;right-&gt;color = COLOR_BLACK; p-&gt;color = COLOR_RED; left_rotate( tree, p ); p = node-&gt;parent-&gt;left; } else { p-&gt;color = node-&gt;parent-&gt;color; node-&gt;parent-&gt;color = COLOR_BLACK; right_rotate( tree, node-&gt;parent ); node = tree-&gt;root; } } } node-&gt;color = COLOR_BLACK; } void rb_delete( rbTree *tree, rbTreeNode *node ) { rbTreeNode *p = node; rbTreeNode *q = tree-&gt;null; color origin_color = p-&gt;color; if ( node-&gt;left == tree-&gt;null ) { q = node-&gt;right; rb_transplant( tree, node, node-&gt;right ); } else if ( node-&gt;right == tree-&gt;null ) { q = node-&gt;left; rb_transplant( tree, node, node-&gt;left ); } else { p = tree_minimum( node-&gt;right, tree-&gt;null ); origin_color = p-&gt;color; q = p-&gt;right; if ( p-&gt;parent == node ) q-&gt;parent = p; else { rb_transplant( tree, p, p-&gt;right ); p-&gt;right = node-&gt;right; p-&gt;right-&gt;parent = p; } rb_transplant( tree, node, p ); p-&gt;left = node-&gt;left; p-&gt;left-&gt;parent = p; p-&gt;color = node-&gt;color; } if ( origin_color == COLOR_BLACK ) rb_delete_fixup( tree, q ); } int random_num() { int a = 1; int b = 100; return rand() % ( b - a ) + a; } void postorder_tree_free( rbTreeNode *root, rbTreeNode *null ) { if ( root != null ) { postorder_tree_free( root-&gt;left, null ); postorder_tree_free( root-&gt;right, null ); free( root ); } } void inorder_tree_walk( rbTreeNode *root, rbTreeNode *null ) { if ( root != null ) { inorder_tree_walk( root-&gt;left, null ); printf(&quot;%d(%d) &quot;, root-&gt;key, root-&gt;color); inorder_tree_walk( root-&gt;right, null ); } } void preorder_tree_walk( rbTreeNode *root, rbTreeNode *null ) { if ( root != null ) { printf(&quot;%d(%d) &quot;, root-&gt;key, root-&gt;color); preorder_tree_walk( root-&gt;left, null ); preorder_tree_walk( root-&gt;right, null ); } } void postorder_tree_walk( rbTreeNode *root, rbTreeNode *null ) { if ( root != null ) { postorder_tree_walk( root-&gt;left, null ); postorder_tree_walk( root-&gt;right, null ); printf(&quot;%d(%d) &quot;, root-&gt;key, root-&gt;color); } } void print_tree( rbTree *tree ) { printf(&quot;中序:&quot;); inorder_tree_walk( tree-&gt;root, tree-&gt;null ); printf(&quot;\\n&quot;); printf(&quot;前序:&quot;); preorder_tree_walk( tree-&gt;root, tree-&gt;null ); printf(&quot;\\n&quot;); printf(&quot;后序:&quot;); postorder_tree_walk( tree-&gt;root, tree-&gt;null ); printf(&quot;\\n\\n&quot;); } rbTreeNode *tree_search_recursion( rbTreeNode *root, int key, rbTreeNode *null) { if ( root == null || key == root-&gt;key ) { return root; } if ( key &lt; root-&gt;key ) return tree_search_recursion( root-&gt;left, key, null ); else return tree_search_recursion( root-&gt;right, key, null ); } rbTreeNode *tree_search( rbTreeNode *root, int key, rbTreeNode *null ) { while ( root != null &amp;&amp; key != root-&gt;key ) { if ( key &lt; root-&gt;key ) root = root-&gt;left; else root = root-&gt;right; } return root; } // 找前驱 即中序遍历的前一个位置值 rbTreeNode *tree_predecessor( rbTreeNode *node, rbTreeNode *null ) { if ( node-&gt;left != null ) return tree_maximum( node-&gt;left, null ); rbTreeNode *p = node-&gt;parent; while ( p != null &amp;&amp; node == p-&gt;left ) { node = p; p = p-&gt;parent; } return p; } // 找后继 即中序遍历的后一个位置值 rbTreeNode *tree_successor( rbTreeNode *node, rbTreeNode *null ) { if ( node-&gt;right != null ) return tree_minimum( node-&gt;right, null ); rbTreeNode *p = node-&gt;parent; while ( p != null &amp;&amp; node == p-&gt;right ) { node = p; p = p-&gt;parent; } return p; } void free_tree( rbTree *tree ) { rbTreeNode *root = tree-&gt;root; postorder_tree_free( root, tree-&gt;null ); free( tree ); } int main( int argc, char **argv ) { srand((int)time(NULL)); int i = 10; int len = 10; int arr[10] = {10,4,15,14,5, 2,8,13,1,19}; rbTree *tree = ( rbTree * )malloc( sizeof(rbTree) ); tree-&gt;node_num = 0; tree-&gt;height = 0; tree-&gt;null = ( rbTreeNode * )malloc( sizeof(rbTreeNode) ); tree-&gt;null-&gt;color = COLOR_BLACK; tree-&gt;root = tree-&gt;null; for ( i = 0; i &lt; len; i++ ) { rbTreeNode *node = ( rbTreeNode * )malloc( sizeof(rbTreeNode) ); //node-&gt;key = random_num(); node-&gt;key = arr[i]; node-&gt;parent = tree-&gt;null; node-&gt;left = tree-&gt;null; node-&gt;right = tree-&gt;null; rb_insert( tree, node ); printf(&quot;insert %d successfully\\n&quot;, arr[i]); } print_tree( tree ); rbTreeNode *delete_node = tree_search( tree-&gt;root, 4, tree-&gt;null ); if ( delete_node != tree-&gt;null ) { rb_delete( tree, delete_node ); } printf(&quot;\\n删除%d的节点后遍历顺序为:\\n&quot;, 4); print_tree( tree ); printf(&quot;\\n&quot;); delete_node = tree_search( tree-&gt;root, 15, tree-&gt;null ); if ( delete_node != tree-&gt;null ) { rb_delete( tree, delete_node ); } printf(&quot;\\n删除%d的节点后中序遍历顺序为:\\n&quot;, 15); print_tree( tree ); printf(&quot;\\n&quot;); free_tree( tree ); return 0; }","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://lkness/tags/数据结构-算法/"}]},{"title":"二叉搜索树-《算法导论》学习笔记十一","slug":"022bin-search-tree/index","date":"2018-06-19T12:36:13.000Z","updated":"2018-06-19T12:38:27.885Z","comments":true,"path":"2018/06/19/022bin-search-tree/index/","link":"","permalink":"http://lkness/2018/06/19/022bin-search-tree/index/","excerpt":"","text":"二叉搜索树是以一颗二叉树来组织的，每个节点除数据外，还包括三个分别指向父结点、左孩子、右孩子的指针，二叉搜索树有个特性：某个结点root的左子树的某个节点x的关键值小于等于root结点右子树某个结点y的关键值。 二叉搜索树有几个操作： 1、查找 查找与给定关键值相等的结点 2、遍历 前序、中序、后序遍历输出 3、从某结点出发，寻找子树中最小关键值的结点 4、从某结点出发，寻找子树中最大关键值的结点 5、以某种遍历方式的次数，寻找某结点的前驱结点和后继结点 例如中序遍历的顺序为123456，则4结点的前驱为3，后继为5 6、插入结点 7、删除结点 删除某个结点后，要把它的后继结点补在删除的位置上，要注意： 如果结点没有孩子结点，那么只是简单地将它删除，并删改它的父结点的孩子指针指向它 如果结点只有一个孩子，那么将它孩子提升到它的位置，并修改它的父结点的孩子指针指向它 如果节点有两个孩子，那么寻找它的后继（按中序遍历来说一定在右子树），并让后继占据它的位置，后继（按中序遍历来说一定没有左子树）的子树提升到后继的位置 情况如上，具体删除时如何替换，又有不同情况： 如果结点只有左或孩子，用孩子替换结点 如果结点有左右两个孩子，那么要查找结点的后继：(1)、如果后继是结点的右孩子，用后继替换结点，并留下后继的右孩子；(2)、后继位于结点的右子树，但并不是结点的右孩子，则，先用后继的右孩子替换后继，再用后继替换结点 代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;time.h&gt; typedef struct biSearchTreeNode { int key; struct biSearchTreeNode *parent; struct biSearchTreeNode *left; struct biSearchTreeNode *right; }biSearchTreeNode; typedef struct biSearchTree { int node_num; int height; biSearchTreeNode *root; }biSearchTree; int random_num() { int a = 1; int b = 100; return rand() % ( b - a ) + a; } void postorder_tree_free( biSearchTreeNode *root ) { if ( root != NULL ) { postorder_tree_free( root-&gt;left ); postorder_tree_free( root-&gt;right ); free( root ); } } void inorder_tree_walk( biSearchTreeNode *root ) { if ( root != NULL ) { inorder_tree_walk( root-&gt;left ); printf(&quot;%d &quot;, root-&gt;key); inorder_tree_walk( root-&gt;right ); } } void preorder_tree_walk( biSearchTreeNode *root ) { if ( root != NULL ) { printf(&quot;%d &quot;, root-&gt;key); preorder_tree_walk( root-&gt;left ); preorder_tree_walk( root-&gt;right ); } } void postorder_tree_walk( biSearchTreeNode *root ) { if ( root != NULL ) { postorder_tree_walk( root-&gt;left ); postorder_tree_walk( root-&gt;right ); printf(&quot;%d &quot;, root-&gt;key); } } void print_tree( biSearchTree *tree ) { printf(&quot;中序:&quot;); inorder_tree_walk( tree-&gt;root ); printf(&quot;\\n&quot;); printf(&quot;前序:&quot;); preorder_tree_walk( tree-&gt;root ); printf(&quot;\\n&quot;); printf(&quot;后序:&quot;); postorder_tree_walk( tree-&gt;root ); printf(&quot;\\n\\n&quot;); } biSearchTreeNode *tree_search_recursion( biSearchTreeNode *root, int key ) { if ( root == NULL || key == root-&gt;key ) { return root; } if ( key &lt; root-&gt;key ) return tree_search_recursion( root-&gt;left, key ); else return tree_search_recursion( root-&gt;right, key ); } biSearchTreeNode *tree_search( biSearchTreeNode *root, int key ) { while ( root != NULL &amp;&amp; key != root-&gt;key ) { if ( key &lt; root-&gt;key ) root = root-&gt;left; else root = root-&gt;right; } return root; } biSearchTreeNode *tree_minimum( biSearchTreeNode *root ) { while ( root-&gt;left != NULL ) { root = root-&gt;left; } return root; } biSearchTreeNode *tree_maximum( biSearchTreeNode *root ) { while ( root-&gt;right != NULL ) { root = root-&gt;right; } return root; } // 找前驱 即中序遍历的前一个位置值 biSearchTreeNode *tree_predecessor( biSearchTreeNode *node ) { if ( node-&gt;left != NULL ) return tree_maximum( node-&gt;left ); biSearchTreeNode *p = node-&gt;parent; while ( p != NULL &amp;&amp; node == p-&gt;left ) { node = p; p = p-&gt;parent; } return p; } // 找后继 即中序遍历的后一个位置值 biSearchTreeNode *tree_successor( biSearchTreeNode *node ) { if ( node-&gt;right != NULL ) return tree_minimum( node-&gt;right ); biSearchTreeNode *p = node-&gt;parent; while ( p != NULL &amp;&amp; node == p-&gt;right ) { node = p; p = p-&gt;parent; } return p; } void tree_insert( biSearchTree *tree, biSearchTreeNode *node ) { biSearchTreeNode *root = tree-&gt;root; biSearchTreeNode *p = NULL; biSearchTreeNode *q = root; while ( q != NULL ) { p = q; if ( node-&gt;key &lt; q-&gt;key ) q = q-&gt;left; else q = q-&gt;right; } node-&gt;parent = p; if ( p == NULL ) { tree-&gt;root = node; } else if ( node-&gt;key &lt; p-&gt;key ) p-&gt;left = node; else p-&gt;right = node; } void transplant( biSearchTree *tree, biSearchTreeNode *node_a, biSearchTreeNode *node_b ) { if ( node_a-&gt;parent == NULL ) tree-&gt;root = node_b; else if ( node_a == node_a-&gt;parent-&gt;left ) node_a-&gt;parent-&gt;left = node_b; else node_a-&gt;parent-&gt;right = node_b; if ( node_b != NULL ) node_b-&gt;parent = node_a-&gt;parent; } void tree_delete( biSearchTree *tree, biSearchTreeNode *node ) { if ( node-&gt;left == NULL ) transplant( tree, node, node-&gt;right ); else if ( node-&gt;right == NULL ) transplant( tree, node, node-&gt;left ); else { biSearchTreeNode *p = tree_minimum( node-&gt;right ); if ( p-&gt;parent != node ) { transplant( tree, p, p-&gt;right ); p-&gt;right = node-&gt;right; p-&gt;right-&gt;parent = p; } transplant( tree, node, p ); p-&gt;left = node-&gt;left; p-&gt;left-&gt;parent = p; } free( node ); } void free_tree( biSearchTree *tree ) { biSearchTreeNode *root = tree-&gt;root; postorder_tree_free( root ); free( tree ); } int main( int argc, char **argv ) { srand((int)time(NULL)); int i = 10; int len = 10; int arr[10] = {10,4,15,14,5, 2,8,13,1,19}; biSearchTree *tree = ( biSearchTree * )malloc( sizeof(biSearchTree) ); tree-&gt;node_num = 0; tree-&gt;height = 0; for ( i = 0; i &lt; len; i++ ) { biSearchTreeNode *node = ( biSearchTreeNode * )malloc( sizeof(biSearchTreeNode) ); //node-&gt;key = random_num(); node-&gt;key = arr[i]; node-&gt;parent = NULL; node-&gt;left = NULL; node-&gt;right = NULL; tree_insert( tree, node ); } print_tree( tree ); for ( i = 0; i &lt; len; i++ ) { biSearchTreeNode *pre = tree_predecessor( tree_search(tree-&gt;root, arr[i]) ); biSearchTreeNode *post = tree_successor( tree_search(tree-&gt;root, arr[i]) ); printf(&quot;\\n&quot;); if ( pre != NULL ) printf(&quot;查找%d的中序遍历前驱为:%d\\n&quot;, arr[i], pre-&gt;key); else printf(&quot;查找%d的中序遍历前驱为空！\\n&quot;, arr[i]); if ( post != NULL ) printf(&quot;查找%d的中序遍历后继为:%d\\n&quot;, arr[i], post-&gt;key); else printf(&quot;查找%d的中序遍历后继为空！\\n&quot;, arr[i]); } biSearchTreeNode *delete_node = tree_search( tree-&gt;root, 4 ); if ( delete_node != NULL ) { tree_delete( tree, delete_node ); } printf(&quot;\\n删除%d的节点后中序遍历顺序为:&quot;, 4); inorder_tree_walk( tree-&gt;root ); printf(&quot;\\n&quot;); delete_node = tree_search( tree-&gt;root, 15 ); if ( delete_node != NULL ) { tree_delete( tree, delete_node ); } printf(&quot;\\n删除%d的节点后中序遍历顺序为:&quot;, 15); inorder_tree_walk( tree-&gt;root ); printf(&quot;\\n&quot;); free_tree( tree ); return 0; }","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://lkness/tags/数据结构-算法/"}]},{"title":"查找数组第i小的数-《算法导论》学习笔记十","slug":"021search-min-i/index","date":"2018-06-19T12:32:13.000Z","updated":"2018-06-19T12:35:17.286Z","comments":true,"path":"2018/06/19/021search-min-i/index/","link":"","permalink":"http://lkness/2018/06/19/021search-min-i/index/","excerpt":"","text":"查找第i小的数利用了快速排序的一点思想，即以数组某个值作为比较值，然后遍历数组中除这个数以外的数，小于它的就放左边，大于它的放右边，然后作为比较值的数放中间，并返回比较值的下标，如果下标等于i，表示就找到了，如果下标大于i，又再次从大于此下标的数组递归进行此过程，同理，小于i就从小于此下标的数组递归进行此过程，代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int partition( int *arr, int p, int r ) { int x = arr[r]; int i = p - 1; int j = 0; int temp = 0; for ( j = p; j &lt; r; j++ ) { if ( arr[j] &lt;= x ) { i += 1; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } temp = arr[i + 1]; arr[i + 1] = arr[r]; arr[r] = temp; return i + 1; } int randomized_partition( int *arr, int p, int r ) { int i = rand() % (r - p) + p; int temp = arr[r]; arr[r] = arr[i]; arr[i] = temp; return partition( arr, p, r ); } int randomized_select( int *arr, int p, int r, int i ) { if ( p == r ) return arr[p]; int q = 0, k = 0; q = randomized_partition( arr, p, r ); k = q - p + 1; if ( i == k ) return arr[q]; else if ( i &lt; k ) return randomized_select( arr, p, q - 1, i ); else return randomized_select( arr, q + 1, r, i - k ); } int main() { int arr[10] = {1,2,3,4,5,6,7,8,9,10}; int len = 10; int i = 8; printf(&quot;第%d小的数是:%d\\n&quot;, i, randomized_select(arr, 0, 9, i)); return 0; }","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://lkness/tags/数据结构-算法/"}]},{"title":"桶排序-《算法导论》学习笔记九","slug":"020bucket-sort/index","date":"2018-06-19T12:28:14.000Z","updated":"2018-06-19T12:29:00.827Z","comments":true,"path":"2018/06/19/020bucket-sort/index/","link":"","permalink":"http://lkness/2018/06/19/020bucket-sort/index/","excerpt":"","text":"桶排序要求数据均匀、独立分布在某个区间上，然后将待排序值按某个区间划分为几个区间数组，然后将待排序的数按这个区间划分公式有序放入对应桶中，这样放完之后再按顺序从桶中拿出来一个一个放入原数组。c代码桶可以用链表，如待排序数组的值为0-99，那么桶可以划分为0-9、10-19、20-29…..，这样就得到了10个桶数组链表，然后遍历待排序的数组，将值/10后以链表插入排序方式放入对应桶链表中（就像打扑克一样从前往后遍历，能插入就插入），待所有数遍历完后，就得到了桶数据了，然后再排序0-9的桶，每个桶做链表遍历取数据，直接从数组0开始插入到待排序数组，代码： #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt; //#define DEBUG typedef struct bucket_data { int no; struct bucket_data *next; } bucket_data; void sort_insert( bucket_data *, int ); void bucket_sort( int *arr, int len ) { bucket_data *tmp_arr = ( bucket_data * )malloc( sizeof(bucket_data) * 10 ); int i = 0, count = 0; //初始化链表头数组 for ( i = 0; i &lt; 10; i++ ) { tmp_arr[i].next = NULL; } //遍历数据并有序插入到相应链表中 for ( i = 0; i &lt; len; i++ ) { sort_insert( &amp;tmp_arr[arr[i] / 10], arr[i] ); } //从链表中取数据到数组 count = 0; for ( i = 0; i &lt; 10; i++ ) { bucket_data *p = tmp_arr[i].next; bucket_data *free_p = NULL; #ifdef DEBUG printf(&quot;bucket[%d]:\\n&quot;, i); #endif while( p != NULL ) { #ifdef DEBUG printf(&quot;%d &quot;, p-&gt;no); #endif free_p = p; arr[count] = p-&gt;no; count++; p = p-&gt;next; free( free_p ); } #ifdef DEBUG printf(&quot;\\n&quot;); #endif } free( tmp_arr ); } void sort_insert( bucket_data *head, int no ) { bucket_data *p = head; bucket_data *data = ( bucket_data * )malloc( sizeof(bucket_data) ); data-&gt;no = no; data-&gt;next = NULL; while ( p != NULL &amp;&amp; p-&gt;next != NULL ) { if ( p-&gt;next-&gt;no &gt;= no ) { data-&gt;next = p-&gt;next; p-&gt;next = data; break; } p = p-&gt;next; } if ( p-&gt;next == NULL ) { p-&gt;next = data; } } void check_is_inc_arr( int *arr, int len ) { int i = 0; for ( i = 0; i &lt; len; i++ ) { if ( arr[i] &lt; arr[i - 1] ) { printf(&quot;check_is_inc_arr fail.\\n&quot;); return; } } } //初始化随机数组 void initArr( int *arr, int lowV, int upV, int len ) { int i = 0; int size = upV - lowV; for ( i = 0; i &lt; len; i++ ) { arr[i] = rand() % size + lowV; } } void print_arr( int *arr, int len ) { int i = 0; printf(&quot;\\n=============================================\\n&quot;); for ( i = 0; i &lt; len; i++ ) { printf(&quot;%d &quot;, arr[i]); } printf(&quot;\\n=============================================\\n&quot;); } int main( int argc, char **argv ) { if ( argc != 4 ) { printf(&quot;input array length and the random value range.\\n&quot;); exit( 0 ); } srand( (int)time(NULL) ); int length = atoi( argv[1] ); int lowV = atoi( argv[2] ); int upV = atoi( argv[3] ); int *arr = ( int * )malloc( sizeof(int) * (length) ); int i = 1000; for ( ; i &gt; 0; i-- ) { initArr( arr, lowV, upV, length ); //print_arr( arr, length ); bucket_sort( arr, length ); //print_arr( arr, length ); check_is_inc_arr( arr, length ); } return 0; }","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://lkness/tags/数据结构-算法/"}]},{"title":"计数排序-《算法导论》学习笔记八","slug":"019count-sort/index","date":"2018-06-19T12:27:08.000Z","updated":"2018-06-19T12:27:51.135Z","comments":true,"path":"2018/06/19/019count-sort/index/","link":"","permalink":"http://lkness/2018/06/19/019count-sort/index/","excerpt":"","text":"计数排序：假设n个输入元素中的每一个都是在0-k区间内的一个整数(k为正整数)，对每一个输入元素x，确定小于x的元素个数，用一个0-k长度的数组做记录，例如输入数组的数为0-10长度，随机出[2,5,3,0,2,3,0,3]，可以计算出一个0-10的数组，分别表示小于等于x的数的个数，于是有：0-&gt;2,1-&gt;2,2-&gt;4,3-&gt;7,4-&gt;7,5-&gt;8,6-&gt;8,7-&gt;8,9-&gt;8,10-&gt;8，然后再倒序遍历待排序数组，根据值去0-10数组取索引，然后将数组值放入一个新的等长数组那个索引处，取过的索引值要减一，这是为了下次再取到相同值不会放在同一位置，代码： #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt; void counting_sort( int *in_arr, int *out_arr, int arr_len, int k ) { int *tmp_arr = ( int * )malloc( sizeof(int) * (k + 1) ); int i = 0, j = 0; for ( i = 0; i &lt; k; i++ ) { tmp_arr[i] = 0; } for ( j = 0; j &lt; arr_len; j++ ) { tmp_arr[in_arr[j]] = tmp_arr[in_arr[j]] + 1; } for ( i = 1; i &lt; k + 1; i++ ) { tmp_arr[i] = tmp_arr[i] + tmp_arr[i - 1]; } for ( j = arr_len - 1; j &gt;= 0; j-- ) { //printf(&quot;j:%d, in_arr[j]:%d, tmp_arr[in_arr[j]]:%d\\n&quot;, // j, in_arr[j], tmp_arr[in_arr[j]]); out_arr[tmp_arr[in_arr[j]] - 1] = in_arr[j]; tmp_arr[in_arr[j]] = tmp_arr[in_arr[j]] - 1; } free( tmp_arr ); } void check_is_inc_arr( int *arr, int len ) { int i = 0; for ( i = 0; i &lt; len; i++ ) { if ( arr[i] &lt; arr[i - 1] ) { printf(&quot;check_is_inc_arr fail.\\n&quot;); return; } } } //初始化随机数组 void initArr( int *arr, int lowV, int upV, int len ) { int i = 0; int size = upV - lowV; for ( i = 0; i &lt; len; i++ ) { arr[i] = rand() % size + lowV; } } void print_arr( int *arr, int len ) { int i = 0; printf(&quot;\\n=============================================\\n&quot;); for ( i = 0; i &lt; len; i++ ) { printf(&quot;%d &quot;, arr[i]); } printf(&quot;\\n=============================================\\n&quot;); } int main( int argc, char **argv ) { if ( argc != 4 ) { printf(&quot;input array length and the random value range.\\n&quot;); exit( 0 ); } srand( (int)time(NULL) ); int length = atoi( argv[1] ); int lowV = atoi( argv[2] ); int upV = atoi( argv[3] ); int *arr = ( int * )malloc( sizeof(int) * (length) ); int *new_arr = ( int * )malloc( sizeof(int) * length ); int i = 1000; for ( ; i &gt; 0; i-- ) { initArr( arr, lowV, upV, length ); //print_arr( arr, length ); counting_sort( arr, new_arr, length, upV ); //print_arr( new_arr, length ); check_is_inc_arr( new_arr, length ); } return 0; }","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://lkness/tags/数据结构-算法/"}]},{"title":"快速排序-《算法导论》学习笔记七","slug":"018quick-sort/index","date":"2018-06-19T12:24:39.000Z","updated":"2018-06-19T12:26:47.543Z","comments":true,"path":"2018/06/19/018quick-sort/index/","link":"","permalink":"http://lkness/2018/06/19/018quick-sort/index/","excerpt":"","text":"快排利用分治的思想，将问题规模切分为小的子规模问题，类似归并排序，归并是将两个待排序的子数组合并为一个有序的数组，而快排是将数组以某个数组值划分为两个子数组，一个数组的所有数比这个值小，一个数组的所有数比这个值大，然后再递归地对两个子数组再以某个数组值做切分和交换： #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt; int partition( int *arr, int p, int r ) { int x = arr[r]; int i = p - 1; int j = 0; int temp = 0; for ( j = p; j &lt; r; j++ ) { if ( arr[j] &lt;= x ) { i += 1; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } temp = arr[i + 1]; arr[i + 1] = arr[r]; arr[r] = temp; return i + 1; } void quick_sort( int *arr, int p, int r ) { int q = 0; if ( p &lt; r ) { q = partition( arr, p, r ); //printf(&quot;p-&gt;%d, q-&gt;%d, r-&gt;%d\\n&quot;, p, q, r); quick_sort( arr, p, q - 1 ); quick_sort( arr, q + 1, r ); } } void check_is_inc_arr( int *arr, int len ) { int i = 0; for ( i = 0; i &lt; len; i++ ) { if ( arr[i] &lt; arr[i - 1] ) { printf(&quot;check_is_inc_arr fail.\\n&quot;); return; } } } //初始化随机数组 void initArr( int *arr, int lowV, int upV, int len ) { int i = 0; int size = upV - lowV; for ( i = 0; i &lt; len; i++ ) { arr[i] = rand() % size + lowV; } } void print_arr( int *arr, int len ) { int i = 0; printf(&quot;\\n=============================================\\n&quot;); for ( i = 0; i &lt; len; i++ ) { printf(&quot;%d &quot;, arr[i]); } printf(&quot;\\n=============================================\\n&quot;); } int main( int argc, char **argv ) { if ( argc != 4 ) { printf(&quot;input array length and the random value range.\\n&quot;); exit( 0 ); } srand( (int)time(NULL) ); int length = atoi( argv[1] ); int lowV = atoi( argv[2] ); int upV = atoi( argv[3] ); int *arr = ( int * )malloc( sizeof(int) * (length) ); initArr( arr, lowV, upV, length ); print_arr( arr, length ); quick_sort( arr, 0, length - 1 ); print_arr( arr, length ); check_is_inc_arr( arr, length ); return 0; }","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://lkness/tags/数据结构-算法/"}]},{"title":"erlang的终端带颜色输出与中文字符串输出","slug":"017erlang-shell-color/index","date":"2018-06-19T12:19:59.000Z","updated":"2018-06-19T12:21:25.453Z","comments":true,"path":"2018/06/19/017erlang-shell-color/index/","link":"","permalink":"http://lkness/2018/06/19/017erlang-shell-color/index/","excerpt":"","text":"1.带颜色输出erlang终端支持带颜色输出，例如lager日志库就可以。其实就是在输出前设置一下输出属性，正常的字体是：”\\e[0;38m”下面自己弄了一些宏： -define(CONSOLE_COLOR_RED, &quot;\\e[0;31m&quot;). -define(CONSOLE_COLOR_RED_BOLD, &quot;\\e[1;31m&quot;). -define(CONSOLE_COLOR_YELLOW1, &quot;\\e[0;32m&quot;). -define(CONSOLE_COLOR_YELLOW2, &quot;\\e[0;33m&quot;). -define(CONSOLE_COLOR_BLUE, &quot;\\e[0;34m&quot;). -define(CONSOLE_COLOR_PURPLE, &quot;\\e[0;35m&quot;). -define(CONSOLE_COLOR_GREEN, &quot;\\e[0;36m&quot;). -define(CONSOLE_COLOR_GRAY, &quot;\\e[0;37m&quot;). -define(CONSOLE_COLOR_NORMAL, &quot;\\e[0;38m&quot;). 用法就是打印的字符串前后加上要设置的属性例如io:format(“~s~s~s~n”, [“\\e[0;31m”, debug, “\\e[0;38m”]).就是在输出debug之前设置字体为红色，然后输出结束后设置字体为正常白色。 2.中文输出中文输出乱码在rebar3插件里用rebar_info输出以及在ct里用io:format(user, ….)输出会遇到，带中文的字符串要转为utf8，代码形如： NewFormat = io_lib:format(Format, Args), io:format(&quot;~s&quot;, [unicode:characters_to_binary(NewFormat, utf8)]).","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"Erlang","slug":"Erlang","permalink":"http://lkness/tags/Erlang/"}]},{"title":"堆排序-《算法导论》学习笔记六","slug":"016heap-sort/index","date":"2018-06-19T12:18:42.000Z","updated":"2018-06-19T12:19:36.767Z","comments":true,"path":"2018/06/19/016heap-sort/index/","link":"","permalink":"http://lkness/2018/06/19/016heap-sort/index/","excerpt":"","text":"堆排序就是将一组数按二叉树层序遍历的存储顺序，经过一系列比较转移，最终变成有序的数组，这里的二叉树堆一定是完全二叉树。堆排序能进行的基础是有个最大堆的数组，最大堆性质是指树上的每个节点的子节点都比自己小或等于。因此最顶上的根节点一定是值最大的节点，有了最大堆在，堆排序就可以进行了，从层序遍历的最后一个节点开始倒序循环，交换当前节点与最顶层根节点，即最大值的节点，这样每次最大的节点都被放在层序遍历的最后位置，类似冒泡排序了，而放了最大值的节点即从堆中排除（只要堆长度减一即表示堆没有这个节点了），交换到顶点根节点的值再做一次下滤操作（以这个节点值与子树的最大值交换），保证剩余子树一定也是最大堆性质。贴代码： #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt; int parent( int ); int left( int ); int right( int ); inline int parent( int index ) { return index / 2; } inline int left( int index ) { return index * 2; } inline int right( int index ) { return index * 2 + 1; } //下滤 void max_heapify( int *arr, int heap_size, int index ) { int l = left( index ); int r = right( index ); int largest = 0; if ( l &lt;= heap_size &amp;&amp; arr[l] &gt; arr[index] ) { largest = l; } else { largest = index; } if ( r &lt;= heap_size &amp;&amp; arr[r] &gt; arr[largest] ) { largest = r; } if ( largest != index ) { int temp = arr[index]; arr[index] = arr[largest]; arr[largest] = temp; max_heapify( arr, heap_size, largest ); } } //构建最大堆 void build_max_heap( int *arr, int length, int heap_size ) { int i = 0; for ( i = length / 2; i &gt;= 1; i-- ) { max_heapify( arr, heap_size, i ); } } //开始堆排序 void heap_sort( int *arr, int length, int heap_size ) { int i = 0; build_max_heap( arr, length, heap_size ); for ( i = heap_size; i &gt;= 2; i-- ) { int temp = arr[1]; arr[1] = arr[i]; arr[i] = temp; heap_size -= 1; max_heapify( arr, heap_size, 1 ); } } void check_is_inc_arr( int *arr, int len ) { int i = 0; for ( i = 1; i &lt;= len; i++ ) { if ( arr[i] &lt; arr[i - 1] ) { printf(&quot;check_is_inc_arr fail.\\n&quot;); return; } } printf(&quot;check_is_inc_arr ok.\\n&quot;); } //初始化随机数组 void initArr( int *arr, int lowV, int upV, int len ) { int i = 0; int size = upV - lowV; for ( i = 1; i &lt; len + 1; i++ ) { arr[i] = rand() % size + lowV; } arr[0] = 0; } void print_arr( int *arr, int len ) { int i = 0; printf(&quot;\\n=============================================\\n&quot;); for ( i = 0; i &lt;= len; i++ ) { printf(&quot;%d &quot;, arr[i]); } printf(&quot;\\n=============================================\\n&quot;); } int main( int argc, char **argv ) { if ( argc != 4 ) { printf(&quot;input array length and the random value range.\\n&quot;); exit( 0 ); } srand( (int)time(NULL) ); int length = atoi( argv[1] ); int lowV = atoi( argv[2] ); int upV = atoi( argv[3] ); int *arr = ( int * )malloc( sizeof(int) * (length + 1) ); initArr( arr, lowV, upV, length ); //print_arr( arr, length ); heap_sort( arr, length, length ); //print_arr( arr, length ); check_is_inc_arr( arr, length ); return 0; } 上面代码中因为c数组从0开始的原因，因此0位置不参与存储和运算，数据形式是{0, 2, 3, 4, 5, 6}。","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://lkness/tags/数据结构-算法/"}]},{"title":"n阶矩阵一般乘法-《算法导论》学习笔记五","slug":"015nmatrix/index","date":"2018-06-19T12:16:29.000Z","updated":"2018-06-19T12:18:12.130Z","comments":true,"path":"2018/06/19/015nmatrix/index/","link":"","permalink":"http://lkness/2018/06/19/015nmatrix/index/","excerpt":"","text":"A、B两个矩阵均是nxn的矩阵，则两个矩阵的乘法： 一般的矩阵乘法代码： #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;time.h&gt; class SquareMatrix { public: SquareMatrix(){} SquareMatrix( int row, int col ): mRow(row), mCol(col) { Init(); } ~SquareMatrix() { for ( int i = 0; i &lt; mRow; i++ ) { delete[] mElement[i]; //printf(&quot;delete %d\\n&quot;, i); } delete[] mElement; } void Init() { mElement = new int*[mRow]; for ( int i = 0; i &lt; mCol; i++ ) { mElement[i] = new int[i]; } } void SetElement( int lowV, int upV ) { int size = upV - lowV; for ( int i = 0; i &lt; mRow; i++ ) { for ( int j = 0; j &lt; mCol; j++ ) { mElement[i][j] = rand() % size + lowV; } } } void PrintElement() { printf(&quot;=========================================\\n&quot;); for ( int i = 0; i &lt; mRow; i++ ) { for ( int j = 0; j &lt; mCol; j++ ) { printf(&quot;%d &quot;, mElement[i][j]); } printf(&quot;\\n&quot;); } printf(&quot;=========================================\\n&quot;); } public: int mRow; int mCol; int *(*mElement); }; void SquareMatrixMultiply( SquareMatrix &amp;a, SquareMatrix &amp;b, SquareMatrix &amp;c ) { int n = a.mRow; c.mRow = c.mCol = n; c.Init(); for ( int i = 0; i &lt; n; i++ ) { for ( int j = 0; j &lt; n; j++ ) { c.mElement[i][j] = 0; for ( int k = 0; k &lt; n; k++ ) { c.mElement[i][j] += a.mElement[i][k] * b.mElement[j][k]; } } } } int main( int argc, char **argv ) { if ( argc != 2 ) { printf(&quot;Usage:./binaryfile num\\n&quot;); exit( 0 ); } int n = atoi( argv[1] ); SquareMatrix smA( n, n ), smB( n, n ), smC; smA.SetElement( 1, 10 ); smA.PrintElement(); smB.SetElement( 1, 10 ); smB.PrintElement(); SquareMatrixMultiply( smA, smB, smC ); smC.PrintElement(); printf(&quot;init square matrix finished\\n&quot;); return 0; } 算法复杂度为O(n^3)，而Stranssen算法通过分治法将大矩阵切分为小矩阵进行计算，算法复杂度可以降低为O(n^2.81)，但是尝试写下代码，发现切割子矩阵时有点复杂，普通的切分会创建子矩阵并复制值，而用下标进行计算又比较复杂，下次有空再尝试写吧。","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://lkness/tags/数据结构-算法/"}]},{"title":"erlang编写rebar3插件","slug":"014rebar3-plugin/index","date":"2018-06-19T12:11:35.000Z","updated":"2018-06-19T12:15:54.478Z","comments":true,"path":"2018/06/19/014rebar3-plugin/index/","link":"","permalink":"http://lkness/2018/06/19/014rebar3-plugin/index/","excerpt":"","text":"1.生成插件工程假设插件名为testp，执行rebar3 new plugins testp，即生成了插件工程项目，查看目录结构如图： testp.erl文件调用初始化的代码，而插件最重要的代码在testp_prv.erl的文件，文件里提供了三个接口，分别为init/1,do/1,format_error/1，init做插件初始化的工作，初始化命名空间/初始化命令，然后将命令加入到rebar3，贴一份配置： init(State) -&gt; Provider = providers:create([ {name, compile}, % The &apos;user friendly&apos; name of the task {module, ?MODULE}, % The module implementation of the task {namespace, testp}, {bare, true}, % The task can be run by the user, always true {deps, ?DEPS}, % The list of dependencies {example, &quot;rebar3 testp compile&quot;}, % How to use the plugin {opts, []}, % list of options understood by the plugin {short_desc, &quot;rebar3 testp compiler&quot;}, {desc, &quot;rebar3 testp compiler&quot;} ]), {ok, rebar_state:add_provider(State, Provider)}. 这份配置就是为rebar3添加一个rebar3 testp compile命令，如果只输入rebar3 testp，会提示rebar3 testp compiler。第二个方法do就是主要的业务逻辑了，执行了rebar3 testp compiler命令就会调用里面的do方法。如果想添加多个命令，可以在testp.erl里多写一个命令的init调用，然后再添加一个命令类似的prv文件，写不同的do业务逻辑，就可以上传git，将git地址配置在rebar.config的plugins里了，rebar3 compile编译就自动拉取插件代码。插件还可以配置钩子(provider_hook)使用，例如添加编译前调用{provider_hooks,[{pre[{compile, {testp, compile}}]}]}，编译后调用将pre改为post即可","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"Erlang","slug":"Erlang","permalink":"http://lkness/tags/Erlang/"}]},{"title":"erlang rebar3配置文件","slug":"013rebar3-conf/index","date":"2018-06-19T11:59:19.000Z","updated":"2018-06-19T12:11:02.436Z","comments":true,"path":"2018/06/19/013rebar3-conf/index/","link":"","permalink":"http://lkness/2018/06/19/013rebar3-conf/index/","excerpt":"","text":"rebar3的简单使用可以参考rebar3的官方文档。以下讲解一些rebar3的配置，初入erlang，理解还不甚深刻。用rebar3进行工程创建，会生成rebar.config文件，贴一些配置的使用方法 1.编译设置%% 编译设置 {erl_opts, [ {parse_transform, lager_transform} , {parse_transform, ms_transform} , report , warn_export_all , warn_export_vars , warn_obsolete_guard , warn_shadow_vars , warn_unused_function , warn_deprecated_function %% ,warn_missing_spec , warn_unused_import ]}. {parse_transform, lager_transform}是lager依赖库的编译选项，修改抽象语法树的方式在编译期生成对应的代码，lager源代码里本身没有lager:error，lager:info等等方法 2.rebar3 shell{shell, [ {apps, [app_name, sync, recon]} , {config, “config/app_name.config”} ]}. 这个配置支持在项目根目录直接运行rebar3 shell启动一个erl shell来运行我们的app，而其配置可以指定为config目录下的某个配置文件，而不是sys.config，适合本地调试，app_name后面的app名字是需要依赖启动的app 3.rebar3插件{plugins, [ rebar3_run , rebar3_auto , {relflow, “1.0.5”} ]}. 配置我们项目需要的plugins，这里的插件可以是我们自己编写的rebar3插件 4.钩子 provider_hooks{provider_hooks, [ {pre,[ {compile, {my_plugins, do_something}} ]}, {post,[{compile,{my_plugins1, clean}}]} ]}. 例如这份配置，就是在执行rebar3 compile之前(pre)运行以my_plugins命名空间下的do_something命令，简单说就是编写了一个rebar3的插件叫my_plugins，提供一个命令叫do_something，即可以在命令行执行rebar3 my_plugins do_something的功能，只是现在配置之后自动调用了命令；post同理就是在compile之后执行那个插件的clean功能，clean功能具体干什么我们不得而知。 5.环境{profiles, [ {profile1, [ {erl_opts, [no_debug_info]}, {relx, [ {include_src, false} , {dev_mode, false} , {include_erts, true} , {system_libs, true} ]} ]}]} 例如这份配置，指定了一种环境叫profile1，编译选项erl_opts为no_debug_info，打包发布的选项为不包含源码，禁止开发模式(目录不是软连接于default环境)，包含erlang环境等，当然还可以加其它很多选项，为每种环境单独自定义需要的功能，常用default、prod、test等 6.覆盖{overrides, [{add, deps1, [{erl_opts, [no_debug_info]}]}]} 例如这份配置，就是对名为deps1的依赖的rebar.config再添加一个配置，overrides提供了add和override两种功能，第一种是加配置，第二种也就是用配置的数据去覆盖原来依赖中有的数据","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"Erlang","slug":"Erlang","permalink":"http://lkness/tags/Erlang/"}]},{"title":"ubuntu16+ideaIC+rebar3搭建erlang开发环境","slug":"012erlang-system-build/index","date":"2018-06-19T11:42:44.000Z","updated":"2018-06-19T11:52:53.451Z","comments":true,"path":"2018/06/19/012erlang-system-build/index/","link":"","permalink":"http://lkness/2018/06/19/012erlang-system-build/index/","excerpt":"","text":"1.ubuntu16系统2.安装各种库sudo apt-get install build-essential sudo apt-get install libncurses5-dev sudo apt-get install libssl-dev sudo apt-get install m4 sudo apt-get install unixodbc unixodbc-dev sudo apt-get install freeglut3-dev libwxgtk2.8-dev sudo apt-get install xsltproc sudo apt-get install fop sudo apt-get install tk8.5 3.安装erlang源码deb安装包：esl-erlang_19.1.3-1-ubuntu-xenial_amd64.deb dpkg -i esl-erlang_19.1.3-1-ubuntu-xenial_amd64.deb 4.安装ideaIC工具百度搜索安装ideaIC，我安装的ideaIC3.4版本，地址 5.下载rebar3rebar3地址 6.ideaIC安装erlang插件打开ideaIC，进入configure菜单进入settings进行设置：settings -&gt; Plugins -&gt; Browse repositories，然后搜索erlang，就可以安装erlang插件了 7.配置安装完后再次进入settings界面：settings -&gt; Build,Execution,Deployment -&gt; Compiler -&gt; Erlang Compiler，将”Compiler project with rebar”和”Add debug info”都打勾。 接着：settings -&gt; Other Settings -&gt; Erlang External Tools，将”rebar”的路径设置为下载的rebar3可执行路径的目录。配置完成。 8.创建、打开新工程等略","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"Erlang","slug":"Erlang","permalink":"http://lkness/tags/Erlang/"}]},{"title":"分治之最大子数组-《算法导论》学习笔记四","slug":"011max-sub-arr/index","date":"2018-06-19T11:35:51.000Z","updated":"2018-06-19T11:41:36.432Z","comments":true,"path":"2018/06/19/011max-sub-arr/index/","link":"","permalink":"http://lkness/2018/06/19/011max-sub-arr/index/","excerpt":"","text":"《算法导论》第4章4.1使用分治策略求最大子数组（数组包含负数，不然整个数组即使最大子数组，求解没意义）。 思路：数组头为low，尾为high，mid=(low+high)/2，这样将数组分为了两段。首先肯定存在这个最大子数组。那么子数组的位置要么处于mid左边，要么处于mid右边，要么包含mid。假设最大子数组出现在mid左边，对mid左边子数组再进行(low+high)/2切分，那么最大子数组可能在切分出的子数组中的位置又存在三种情况中的一种，这样递归地切分下去，最终切分到整个数组都变为1-2个元素的子数组，这时候的情况就像一颗二叉树，例如数组[53,-4,-73,-16,88,91,-50,-15,-15,52,-19]，切分之后的二叉树： 然后用后续遍历二叉树的方式计算、查找最大子数组。如图，节点8的子数组有53、-4、53,-4，则找出来最大子数组为[53]，后序遍历的方式遍历完左子树，返回根，到右子树，有一个节点9，则最大子数组为9，对于节点4的左右子树的最大子数组都找到，再对节点8、4、9合并的数组找位于mid的最大子数组(此时low为0，mid为1，high为2，从mid出发往左走找最大子数组，再从mid+1出发往右走找最大子数组，再将找到的两个数组合并起来，为经过mid的最大子数组)，找到为[53,-4,-73]，将[53]、[-73]，[53,-4,-73]比较，得出根节点为4的树最大数组为[53]，则再返回根节点2，再后续到节点5，对5再求最大子数组为[88,91]，再对节点2求经过mid的最大子数组为[53,-4,-73,-16,88,91]，和为139，与[53]、[88,91]比较，选[88,91]；接着返回根节点1，对右子树节点2求最大子数组，为[52]，再对节点1组成的数组求经过mid的最大子数组，为[88,91,-50,-15,-15,52]，和为151，与[88,91]、[52]比较，选[88,91]。 c代码： #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;time.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; int crossLow = 0, crossHigh = 0, crossSum = 0; int finalLeftIndex = -1; int finalRightIndex = -1; int finalSubArraySum = 0; //求经过mid的最长子数组，范围low-high void find_max_crossing_subarray( int *arr, int low, int mid, int high ) { if ( low == mid &amp;&amp; mid == high ) { crossLow = low; crossHigh = high; crossSum = arr[mid]; return ; } int lMax = -10000000, rMax = -10000000; int lTmpSum = 0, rTmpSum = 0; int i = 0; for ( i = mid; i &gt;= low; i-- ) { lTmpSum += arr[i]; if ( lTmpSum &gt; lMax ) { lMax = lTmpSum; crossLow = i; } } for ( i = mid + 1; i &lt;= high; i++ ) { rTmpSum += arr[i]; if ( rTmpSum &gt; rMax ) { rMax = rTmpSum; crossHigh = i; } } crossSum = lMax + rMax; } //分治，将数组切分子规模的待求数组 void find_maximum_subarray( int *arr, int low, int high ) { if ( high &lt;= low + 1 ) { find_max_crossing_subarray( arr, low, low, high ); if ( arr[low] &gt;= arr[high] &amp;&amp; arr[low] &gt;= crossSum ) { finalLeftIndex = low; finalRightIndex = low; finalSubArraySum = arr[low]; } else if ( arr[high] &gt;= arr[low] &amp;&amp; arr[high] &gt;= crossSum ) { finalLeftIndex = high; finalRightIndex = high; finalSubArraySum = arr[high]; } else { finalLeftIndex = low; finalRightIndex = high; finalSubArraySum = crossSum; } } else { int lLow = 0, lHigh = 0, lSum = 0; int rLow = 0, rHigh = 0, rSum = 0; //其实这里的递归就像二叉树的后续遍历，直到遍历完左子树，再开始右子树， //这样的好处假如数组有上亿的元素，不会造成栈空间不足， //解决了一个左子树就返回了递归栈，再进行右子树的展开工作 int mid = ( low + high ) / 2; find_maximum_subarray( arr, low, mid ); lLow = finalLeftIndex; lHigh = finalRightIndex; lSum = finalSubArraySum; find_maximum_subarray( arr, mid + 1, high ); rLow = finalLeftIndex; rHigh = finalRightIndex; rSum = finalSubArraySum; find_max_crossing_subarray( arr, low, mid, high ); // printf(&quot;%d %d %d/%d %d %d/%d %d %d\\n&quot;, // lLow, lHigh, lSum, // rLow, rHigh, rSum, // crossLow, crossHigh, crossSum); if ( lSum &gt;= rSum &amp;&amp; lSum &gt;= crossSum ) { finalLeftIndex = lLow; finalRightIndex = lHigh; finalSubArraySum = lSum; } else if ( rSum &gt;= lSum &amp;&amp; rSum &gt;= crossSum ) { finalLeftIndex = rLow; finalRightIndex = rHigh; finalSubArraySum = rSum; } else { finalLeftIndex = crossLow; finalRightIndex = crossHigh; finalSubArraySum = crossSum; } // printf(&quot;------%d %d %d\\n&quot;, finalLeftIndex, finalRightIndex, finalSubArraySum); } } //暴力破解法求最长子数组，不过这里用来测试我写的分治求法结果是否正确 int check_result( int *arr, int len, int lIndex, int rIndex, int Sum ) { int maxSum = -100000000; int lIndex1; int rIndex1; int i = 0, j = 0; for ( i = 0; i &lt; len; i++ ) { int tmpSum = 0; for ( j = i; j &lt; len; j++ ) { tmpSum += arr[j]; if ( tmpSum &gt; maxSum ) { maxSum = tmpSum; lIndex1 = i; rIndex1 = j; } } } if ( Sum == maxSum ) { if ( lIndex == lIndex1 &amp;&amp; rIndex == rIndex1 ) { return 0; } printf(&quot;equal!!\\n&quot;); printf(&quot;exhaustivly_find_result:lIndex-&gt;%d,rIndex-&gt;%d,Sum-&gt;%d\\n&quot;, lIndex1, rIndex1, maxSum); printf(&quot;divide_and_conquer_result:lIndex-&gt;%d,rIndex-&gt;%d,Sum-&gt;%d\\n&quot;, lIndex, rIndex, Sum); return 1; } // else { // printf(&quot;not equal!!!!!!!!!&quot;); // } return -1; } void mainLoop( int *arr, int len ) { find_maximum_subarray( arr, 0, len - 1 ); printf(&quot;----------------------------------------------------\\n&quot;); printf(&quot;lIndex:%d,rIndex:%d,subArrSum:%d\\n&quot;, finalLeftIndex, finalRightIndex, finalSubArraySum); printf(&quot;----------------------------------------------------\\n&quot;); } void stepLoop( int *arr, int len ) { time_t tt0 = time( NULL ); printf(&quot;before:%s&quot;, ctime(&amp;tt0)); mainLoop( arr, len ); time_t tt1 = time( NULL ); printf(&quot;after:%s&quot;, ctime(&amp;tt1)); printf(&quot;cost %d(sec),%d(min)\\n&quot;, (int)(tt1 - tt0), (int)((tt1 - tt0) / 60)); } //初始化随机数组 void initArr( int *arr, int lowV, int upV, int len ) { int i = 0; int size = upV - lowV; for ( ; i &lt; len; i++ ) { arr[i] = rand() % size + lowV; } } //打印数组 void printArr( int *arr, int len ) { int i = 0; for ( ; i &lt; len; i++ ) printf(&quot;%d &quot;, arr[i]); printf(&quot;\\n&quot;); } int main( int argc, char **argv ) { srand( (int)time(NULL) ); if ( argc != 4 ) { printf(&quot;usage: ./execfile lowV upV len\\n&quot;); return 0; } int lowV = atoi( argv[1] ); int upV = atoi( argv[2] ); unsigned int len = atoi( argv[3] ); int *arr = NULL; arr = ( int *) malloc( len * sizeof(int) ); // int len = 10; // int arr[10] = {7, 0, -86, 61, -72, 50, -38, -25, -70, -76}; int i = 0; //随机10000个数组求最大子数组，然后检测结果是否正确 for ( i = 0; i &lt; 10000; i++ ) { initArr( arr, lowV, upV, len ); printArr( arr, len ); // stepLoop( arr, len ); usleep(1000); find_maximum_subarray( arr, 0, len - 1 ); int ret = check_result( arr, len, finalLeftIndex, finalRightIndex, finalSubArraySum ); if ( ret &lt; 0 ) { printf(&quot;failed!!\\n&quot;); return 0; } printf(&quot;-------------equal:%d\\n&quot;, i); } free( arr ); arr = NULL; return 0; } 以上代码定义了几个全局变量，与《算法导论》的代码有点出入，书上的函数块返回3个值，例如：(left-low,left-high,left-sum) = FIND-MAXIMUM-SUBARRAY(A, low, mid)，这里可能用其它编程语言更好描述算法，erlang/golang/python的函数就可以返回一个元组并接收{LeftLow, LeftHigh, LeftSum} = FIND….()。","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://lkness/tags/数据结构-算法/"}]},{"title":"递归插入排序-《算法导论》学习笔记三","slug":"010recu-insert-sort/index","date":"2018-06-15T12:15:00.000Z","updated":"2018-06-19T11:50:06.319Z","comments":true,"path":"2018/06/15/010recu-insert-sort/index/","link":"","permalink":"http://lkness/2018/06/15/010recu-insert-sort/index/","excerpt":"","text":"算法导论第二章结尾练习2.3-4提到将插入排序写递归版本，然后尝试写了个，本来写了就好了，但是调试的时候排序10w个数可以，排序100w个数就段错误，分析了一下，把结果放上来以后查看，先贴代码： #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;time.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; void insert_sort0( int *arr, int index ) { int i, tmp = arr[index]; //printf(&quot;index:%d\\n&quot;, index); for ( i = index - 1; i &gt;= 0; i-- ) { if ( arr[i] &gt; tmp ) { arr[i + 1] = arr[i]; } else { arr[i + 1] = tmp; return; } } arr[i + 1] = tmp; } void insert_sort( int *arr, int index ) { //printf(&quot;index:%d\\n&quot;, index); if ( index &gt; 0 ) { insert_sort( arr, index - 1 ); //printf(&quot;index:%d\\n&quot;, index); insert_sort0( arr, index ); } } void sortLoop0( int *arr, int len ) { //sleep( 20 ); insert_sort( arr, len - 1 ); } //排序前后做时间对比，精度sec void sortLoop( int *arr, int len ) { time_t tt0 = time( NULL ); printf(&quot;\\tbefore sort:%s&quot;, ctime(&amp;tt0)); sortLoop0( arr, len ); time_t tt1 = time( NULL ); printf(&quot;\\tafter sort:%s&quot;, ctime(&amp;tt1)); printf(&quot;\\tsort the array cost %d(sec),%d(min)\\n&quot;, (int)(tt1 - tt0), (int)((tt1 - tt0) / 60)); } //初始化随机数组 void initArr( int *arr, int lowV, int upV, int len ) { srand( (int)time(NULL) ); int i = 0; int size = upV - lowV; for ( ; i &lt; len; i++ ) { arr[i] = rand() % size + lowV; } } //打印数组 void printArr( int *arr, int len ) { int i = 0; for ( ; i &lt; len; i++ ) printf(&quot;%d &quot;, arr[i]); printf(&quot;\\n&quot;); } //这里写了个简单得数组检查，检查是否 //是正确的递增序列(怕自己的代码没检查 //边界条件偶尔有错误的排序数组) int check_arr_increase( int *arr, int len ) { int i = 0; for ( ; i &lt; len - 1; i++ ) { if ( arr[i] &lt;= arr[i + 1] ) continue; else { printf(&quot;array isn&apos;t increase!!!\\n&quot;); return -1; } } printf(&quot;array is increase!!!!\\n&quot;); return 0; } int main( int argc, char **argv ) { if ( argc != 4 ) { printf(&quot;usage: ./execfile lowV upV len\\n&quot;); return 0; } int lowV = atoi( argv[1] ); int upV = atoi( argv[2] ); unsigned int len = atoi( argv[3] ); int *arr = NULL; arr = ( int *) malloc( len * sizeof(int) ); initArr( arr, lowV, upV, len ); //printArr( arr, len ); sortLoop( arr, len ); check_arr_increase( arr, len ); //printArr( arr, len ); free( arr ); arr = NULL; return 0; } 开始一直以为是代码有数组越界或者边界条件没考虑到，后来看了代码许久没发现问题。然后gdb看core文件，bt看调用栈发现段在递归向下大概70w-80w的位置，而递归栈还没返回，执行过程很正常没出问题，想了想是栈溢出，每次自顶向下调用一次自身函数就要在栈里保存一次函数地址和参数。 用ulimit -a|grep stack看了一下默认的栈空间大小为8192kb=8m=810241024=8388608byte。网上查了下说一次函数调用每次占用栈内存为：4返回地址 + 4参数个数 + 4寄存器保护 + 4局部变量数（未验证准确与否），我的排序占用4+42+12=24字节，但根据我每次设置栈大小调试程序，设置到31256kb时程序没有段错误，也就是312561024/1000000=32字节，这里的一次函数调用为32字节。 用ulimit -s 102400修改了栈空间大小100M（暂时修改），再次运行程序排序100w个数，发现打印正常，程序也没段错误了，只是递归栈开始返回等了好久。 对归并排序的思考：以前也有用归并排序排1亿个数（http://blog.csdn.net/u012785877/article/details/52475023），没有出现栈溢出，里面也是用递归的方法，因此仔细看了下归并排序（算法导论里有提到归并排序的递归树，可以算出数量，但是我看着头大，准备略过这些数学问题，先照着把代码写出来，看完了再回头深入看一遍），模拟了一下递归的栈过程如下： 假设有134217728个数待排序(2^27)。因此递归树根节点为2^27；递归第一次递归树有二层，两个节点分别为2^26、2^26；递归第三次递归树为有三层，四个节点分别为2^25、2^25、2^25、2^25……这样一直推到递归树叶子节点为2^1，此递归树有27层，2^(floor - 1) + 1 = 2^(26 -1) + 1 = 67108865个节点，也就是要维护67108865*30约为20亿的函数调用栈空间，为什么没有栈溢出呢？。通过调试归并排序，排序4个数时，是将0-3分为0-1，在将0-1分为0，对0再分发现不能分了，则此次递归返回到父节点，划分右子树1，对1再分发现不能分了，于是调用排序，将0、1排为0-1，再回归0-1的父节点，再对右子树2-3递归进行此过程。其实排序4个数最大只需要5次递归函数调用（即递归树走到最深度），如果排序n层递归树，最大需要n+1次。回到以上排序2^27个数，则最大同时需要28次递归函数调用，其余时候都是栈空间在不断出栈入栈。 上面写得有点昏，无奈不是学文科的，又不想画图，额。这个归并排序的分析结果只花了2个小时分析，也不能确定准不准确，如果错了欢迎批评指正。","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://lkness/tags/数据结构-算法/"}]},{"title":"c半同步半异步进程池模型之cgi服务器","slug":"009cgiserver/index","date":"2018-06-15T10:47:28.000Z","updated":"2018-06-19T02:02:56.131Z","comments":true,"path":"2018/06/15/009cgiserver/index/","link":"","permalink":"http://lkness/2018/06/15/009cgiserver/index/","excerpt":"","text":"对半同步半异步进程池模型垂涎已久，这次中秋放假撸了下代码。 模型的简单介绍：主进程创建几个子进程作为工作进程，主进程监听客户端connect事件，一旦有连接事件，即通过round robin(简单轮询)选取一个子进程， 通过父子进程间的通信管道通知子进程有连接事件，子进程epoll监听到管道通信时间，即知道有客户端连接，因此进程accept，并将客户端连接套接字加入epoll监听事件，客户端浏览器发送get请求，客户端监听到请求事件，即调用封装好的客户端事件进行处理，本例子的客户端处理为recv客户的请求，从中提取文件名(now.cgi)，并重定向客户端连接套接字到stdout，然后执行对应cgi文件，cgi文件打印html页面字符串，因为重定向的缘故，打印的html字符串发送给客户端，客户端浏览器即显示了html页面。 代码写了几个模块，分别是： util：封装了套接字创建、unix族socket管道创建、中断信号、简单屏幕输出(可自行替换为日志文件输出) epoll_wrapper：封装了epoll相关操作包括创建epfd、添加epoll监听事件、删除epoll监听事件 myhshappool(我的半同步半异步进程池 - -!…)：封装了进程池初始化、启动进程池进行事件监听 client_handle：进程池监听到客户事件、即调用client_handle封装的处理事件，这里封装的是执行cgi文件向客户端浏览器返回服务器时间(最近在看unix网络编程，里面都是时间获取的服务器，借鉴下拿来搞事，当然，嵌入式里拿来控制个灯泡开关想来特别带劲，用android做个网页app，板子接wifi模块接智能灯，cgi负责开关灯泡 。。) cgisrv：入口，初始化进程池，启动进程池 代码快1k行，不知道一个博客文章能不能写下，这种玩具demo代码就不往github放了。代码中凑合写了注释(有时候不想切换中英文因此用了蹩脚的英文注释)，限(wo)于(tai)篇(lan)幅(le)没有写文件头注释和函数头注释。 util.h： #ifndef _UTIL_H #define _UTIL_H #include &lt;stdio.h&gt; #include &lt;signal.h&gt; #include &lt;string.h&gt; #include &lt;errno.h&gt; #include &lt;sys/socket.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;stdlib.h&gt; #include &lt;fcntl.h&gt; //这里不用 #转字符串了，不方便管理等级 #ifdef LEVELNUMPRINT #define LEVEL0 &quot;LEVEL0&quot; #define LEVEL1 &quot;LEVEL1&quot; #define LEVEL2 &quot;LEVEL2&quot; #define LEVEL3 &quot;LEVEL3&quot; #define LEVEL4 &quot;LEVEL4&quot; #define LEVEL4 &quot;LEVEL5&quot; #else #define LEVEL0 &quot;DEBUG&quot; #define LEVEL1 &quot;INFO&quot; #define LEVEL2 &quot;NOTICE&quot; #define LEVEL3 &quot;WARN&quot; #define LEVEL4 &quot;ERROR&quot; #define LEVEL5 &quot;FATAL&quot; #endif #define PRINTINFO( LEVEL, format, args... ) \\ do { \\ printf(&quot;[%s]:(pid:%d)/(file:%s)/(func:%s)/(line:%d)&quot;, \\ LEVEL, getpid(), __FILE__, __func__, __LINE__); \\ /*printf(&quot;\\t&quot; #LEVEL &quot;:&quot;);*/ \\ printf(&quot;--|--&quot;); \\ printf( format, ##args ); \\ printf(&quot;\\n&quot;); \\ } while( 0 ) #define PRINTINFO_ERR( LEVEL, format, args... ) \\ do { \\ printf(&quot;[%s]:(pid:%d)/(file:%s)/(func:%s)/(line:%d)&quot;, \\ LEVEL, getpid(), __FILE__, __func__, __LINE__); \\ /*printf(&quot;\\t&quot; #LEVEL &quot;:&quot;);*/ \\ printf(&quot;--|--&quot;); \\ printf( format, ##args ); \\ printf(&quot;(errmsg:%s)&quot;, strerror(errno)); \\ printf(&quot;\\n&quot;); \\ } while( 0 ) void Add_sig( int sig, void (*handler)(int), int restart_syscall ); void Socketpair( int *pairpipefd ); int Socket_create( char *ipaddr, int port ); void Setnonblocking( int fd ); #endif util.c: #include &quot;util.h&quot; static int add_sig( int sig, void (*handler)(int), int restart_syscall ) { struct sigaction act; bzero( &amp;act, sizeof(act) ); act.sa_handler = handler; act.sa_flags = 0; //早期unix系统对于进程在执行一个低速系统调用(如ioctl、 //read、write、wait)而阻塞期间捕捉到一个信号，则系统 //调用被中断不再执行，该系统调用返回错误，设置errno为 //EINTR，随后的bsd系统引入了自动重启，即再次进行此系统 //调用。unix衍生系统默认的方式可能为可选、总是等，类 //unix系统的linux系统可能默认为不重启，因此添加重启标识 if ( restart_syscall ) { act.sa_flags |= SA_RESTART; } //宏定义： //#define sigfillset(*p) (*p) = ~(0,0) sigfillset( &amp;act.sa_mask ); if ( -1 == sigaction(sig, &amp;act, NULL) ) { PRINTINFO_ERR( LEVEL4, &quot;sigaction error&quot; ); return -1; } return 0; } void Add_sig( int sig, void (*handler)(int), int restart_syscall ) { if ( add_sig(sig, handler, restart_syscall) &lt; 0 ) { PRINTINFO( LEVEL5, &quot;add_sig error&quot; ); exit( 0 ); } } void Socketpair( int *pairpipefd ) { int ret; ret = socketpair( PF_UNIX, SOCK_STREAM, 0, pairpipefd ); if ( ret &lt; 0 ) { PRINTINFO_ERR( LEVEL5, &quot;socketpair error!!&quot; ); exit( 0 ); } } static int socket_create( char *ipaddr, int port, int backlog ) { int sockfd; int ret; sockfd = socket( AF_INET, SOCK_STREAM, 0 ); if ( sockfd &lt; 0 ) { PRINTINFO_ERR( LEVEL4, &quot;socket error!!!&quot; ); return -1; } struct sockaddr_in addr; bzero( &amp;addr, sizeof(addr) ) ; addr.sin_family = AF_INET; addr.sin_port = htons( port ); inet_pton( AF_INET, ipaddr, &amp;addr.sin_addr ); int reuseaddr = 1; setsockopt( sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuseaddr, sizeof(int) ); ret = bind( sockfd, (struct sockaddr *)&amp;addr, (socklen_t)sizeof(addr) ) ; if ( ret &lt; 0 ) { PRINTINFO_ERR( LEVEL4, &quot;bind error!!!&quot; ); return -1; } ret = listen( sockfd, backlog ); if ( ret &lt; 0 ) { PRINTINFO_ERR( LEVEL4, &quot;listen error!!!&quot; ); return -1; } return sockfd; } int Socket_create( char *ipaddr, int port ) { int ret; ret = socket_create( ipaddr, port, 5 ); if ( ret &lt; 0 ) { PRINTINFO( LEVEL5, &quot;socket_creaet error!!!&quot; ); exit( 0 ); } return ret; } static int setnonblocking( int fd ) { int old_opt = fcntl( fd, F_GETFL ); int new_opt = old_opt | O_NONBLOCK; fcntl( fd, F_SETFL, new_opt ); return old_opt; } void Setnonblocking( int fd ) { setnonblocking( fd ); } int Send ( int socket_fd, const unsigned char * send_buf, int buf_size, int flag ) { int snd_bytes = 0; int snd_total_bytes = 0; int snd_count = 3; while ( snd_count -- ) { snd_bytes = send( socket_fd, send_buf, buf_size, flag ); if ( snd_bytes &lt;= 0 ) { if ( EAGAIN == errno || EINTR == errno || EWOULDBLOCK == errno ) { //暂时发送失败，需要重复发送 usleep( 50 ); continue; }else { //连接不正常，返回-1交由上层清理此套接字 PRINTINFO_ERR( LEVEL4, &quot;send return error!!!&quot; ); return -1; } } snd_total_bytes += snd_bytes; if ( snd_total_bytes &gt;= buf_size ) { break; } } if ( !snd_count ) { PRINTINFO( LEVEL4, &quot;send timeout!!!&quot; ); return -1; } return snd_total_bytes; } #if 0 int main() { PRINTINFO( LEVEL0, &quot;likun:%d&quot;, 123 ); PRINTINFO( LEVEL1, &quot;likun:&quot; ); //PRINTINFO( likun, &quot;likun:&quot; ); return 0; } #endif epoll_wrapper.h: #ifndef _EPOLL_WRAPPER_H #define _EPOLL_WRAPPER_H #include &lt;sys/epoll.h&gt; #include &lt;stdlib.h&gt; int Epoll_create( int size ); int Epoll_wait( int epfd, struct epoll_event *events, int maxevents, int timeout ); void Epoll_add_fd( int epfd, int fd ); void Epoll_del_fd( int epfd, int fd ); #endif epoll_wrapper.c: #include &quot;epoll_wrapper.h&quot; #include &quot;util.h&quot; static int epoll_create0( int size ) { int ret; ret = epoll_create( size ); if ( ret &lt;= 0 ) { PRINTINFO_ERR( LEVEL3, &quot;epoll_create error!!!&quot; ); return -1; } return ret; } int Epoll_create( int size ) { int ret; if ( (ret = epoll_create0(size)) &lt; 0 ) { PRINTINFO( LEVEL5, &quot;epoll_create0 error!!!&quot; ); exit( 0 ); } return ret; } int Epoll_wait( int epfd, struct epoll_event *events, int maxevents, int timeout ) { return epoll_wait( epfd, events, maxevents, timeout ); } static int epoll_add_fd( int epfd, int fd ) { struct epoll_event event; event.data.fd = fd; event.events = EPOLLIN | EPOLLET; epoll_ctl( epfd, EPOLL_CTL_ADD, fd, &amp;event ); Setnonblocking( fd ); return 0; } void Epoll_add_fd( int epfd, int fd ) { epoll_add_fd( epfd, fd ); } void Epoll_del_fd( int epfd, int fd ) { epoll_ctl( epfd, EPOLL_CTL_DEL, fd, NULL ); } #if 0 int main() {} #endif myhshappool.h: #ifndef _MY_HS_HA_P_POOL_H #define _MY_HS_HA_P_POOL_H #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;assert.h&gt; #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/epoll.h&gt; #include &lt;signal.h&gt; #include &lt;sys/wait.h&gt; #include &lt;sys/stat.h&gt; #include &lt;libgen.h&gt; typedef struct process { //当前进程id号 pid_t pid; //与父进程通信用的管道 //0端父进程写 //1端子进程读 int pipefd[2]; } process; typedef struct processpool { //进程池最大进程数 int max_process_num; //每个进程最大处理客户数量 int max_user_num; //epoll最多处理的事件数 int max_epoll_event; //当前进程池进程总数 int cur_process_num; //当前子进程在进程池序号，从0开始 int index; //每个进程一个epoll内核事件表 int epollfd; //监听socket int listenfd; //停止线程池 int stop; //进程池子进程管理 struct process *sub_process; } processpool; int init_process_pool( processpool *ppool, int maxpnum, int maxunum, int maxeevent, int curpnum, int listenfd ); void run( processpool *ppool ); #endif myhshappool.c: #include &quot;myhshappool.h&quot; #include &quot;client_handle.h&quot; #include &quot;util.h&quot; //用于信号中断时主进程通信， //统一处理事件，即将客户端连接 //事件、信号事件都统一用epoll //监听处理，0端信号处理函数写， //1端进程读 static int sig_pipefd[2]; static void sig_handler( int sig ) { //保存旧的errno，对后续的send不 //进行错误判定，但send假如返回 //失败会设置errno，信号中断调用 //结束后影响进程其它模块判断 int old_errno = errno; char signo = (char)sig; send( sig_pipefd[0], (char *)&amp;signo, 1, 0 ); errno = old_errno; } static void init_signal( processpool *ppool ) { Socketpair( sig_pipefd ); Setnonblocking( sig_pipefd[0] ); //Epoll_add_fd( ppool-&gt;epollfd, sig_pipefd[1] ); Add_sig( SIGCHLD, sig_handler, 1 ); Add_sig( SIGTERM, sig_handler, 1 ); Add_sig( SIGINT, sig_handler, 1 ); Add_sig( SIGPIPE, SIG_IGN, 1 ); } int init_process_pool( processpool *ppool, int maxpnum, int maxunum, int maxeevent, int curpnum, int listenfd ) { if ( !ppool ) { PRINTINFO( LEVEL4, &quot;ppool is null!!!&quot; ); return -1; } ppool-&gt;max_process_num = maxpnum; ppool-&gt;max_user_num = maxunum; ppool-&gt;max_epoll_event = maxeevent; ppool-&gt;cur_process_num = curpnum; ppool-&gt;listenfd = listenfd; // ppool-&gt;epollfd = Epoll_create( 5 ); ppool-&gt;index = -1; ppool-&gt;stop = 0; ppool-&gt;sub_process = (process *)calloc( sizeof(process), curpnum ); if ( !ppool-&gt;sub_process ) { PRINTINFO( LEVEL4, &quot;sub_process calloc error!!!&quot; ); return -1; } int i = 0; int pid; //先模拟一下进程池创建之前的情况，假设终端 //bash shell进程id为1000，运行此程序进程id //为1001，其父进程为1000，fork之后主进程不 //变，子进程id为1002，其父进程为1001，因此 //明白fork的过程，下面可以走一下进程池创建 //的流程（条件均为以上假设）： //第一次fork:创建亲缘进程的管道，父进程1001 //，子进程1002，其父进程为1001，子进程不再 //执行for循环，且主进程与1002子进程有单独通 //信的管道 //第二次fork:创建亲缘进程的管道，父进程1001 //，子进程1003，其父进程为1001，子进程不再 //执行for循环，且主进程与1003子进程有单独通 //信的管道 //第三次fork .....1004..... // ........ //通过以上过程，可以看到for循环次数为创建的 //子进程数量，且每个子进程可以单独与父进程 //通信 // //这里进程创建，没有脱离当前终端的会话， //我觉得可以setsid()来摆脱终端影响 for ( ; i &lt; curpnum; i++ ) { Socketpair( ppool-&gt;sub_process[i].pipefd ); pid = fork(); if ( pid &gt; 0 ) { //parent fork close( ppool-&gt;sub_process[i].pipefd[1] ); ppool-&gt;sub_process[i].pid = pid; Setnonblocking( ppool-&gt;sub_process[i].pipefd[0] ); continue; } else if ( pid == 0 ) { //child ppool-&gt;index = i; PRINTINFO( LEVEL0, &quot;child(%d):%d\\tparent:%d&quot;, i + 1, getpid(), getppid() ); close( ppool-&gt;sub_process[i].pipefd[0] ); //每次只由父进程去创建进程 break; } else { PRINTINFO( LEVEL5, &quot;fork error!!!&quot; ); exit( 0 ); } } } static int client_signal_handle( processpool *ppool, char *signals, int signals_num ) { int i = 0; for ( ; i &lt; signals_num; i++ ) { switch( signals[i] ) { case SIGCHLD: { PRINTINFO( LEVEL0, &quot;child receive a SIGCHLD signal&quot; ); pid_t pid; int stat; //catch SIGCHLD while ( (pid = waitpid(-1, &amp;stat, WNOHANG)) &gt; 0 ) { continue; } break; } case SIGTERM: { PRINTINFO( LEVEL0, &quot;child receive a SIGTERM signal&quot; ); ppool-&gt;stop = 1; break; } case SIGINT: { PRINTINFO( LEVEL0, &quot;child receive a SIGINT signal&quot; ); ppool-&gt;stop = 1; break; } default: { break; } } } } static void run_child( processpool *ppool ) { if ( !ppool ) { PRINTINFO( LEVEL4, &quot;ppool is null!!!&quot; ); return; } init_signal( ppool ); ppool-&gt;epollfd = Epoll_create( 5 ); PRINTINFO( LEVEL0, &quot;child cur process:%d&quot;, ppool-&gt;cur_process_num ); int pipefd = ppool-&gt;sub_process[ppool-&gt;index].pipefd[1]; Epoll_add_fd( ppool-&gt;epollfd, pipefd ); Epoll_add_fd( ppool-&gt;epollfd, sig_pipefd[1] ); struct epoll_event *events = (struct epoll_event *) calloc( sizeof(struct epoll_event), ppool-&gt;max_epoll_event ); if ( !events ) { PRINTINFO( LEVEL5, &quot;calloc error!!!&quot; ); goto _free_source; } struct client_param *cparam = NULL; cparam = (struct client_param *) calloc( sizeof(struct client_param), ppool-&gt;max_user_num ); if ( !cparam ) { PRINTINFO( LEVEL5, &quot;calloc error!!!&quot; ); goto _free_source; } int event_num, event_fd; int i, j, ret, onebyte; while ( !ppool-&gt;stop ) { event_num = Epoll_wait( ppool-&gt;epollfd, events, ppool-&gt;max_epoll_event, -1); //PRINTINFO( LEVEL0, &quot;child event num:%d&quot;, event_num ); if ( (event_num &lt; 0) &amp;&amp; (errno != EINTR) ) { PRINTINFO_ERR( LEVEL4, &quot;Epoll_wait error!!!&quot; ); ppool-&gt;stop = 1; break; } for ( i = 0; i &lt; event_num; i++ ) { event_fd = events[i].data.fd; //parent process notify that there is a new client connect to. if ( event_fd == pipefd &amp;&amp; events[i].events &amp; EPOLLIN ) { PRINTINFO( LEVEL0, &quot;receive signal from parent there is a new client connection&quot; ); ret = recv( event_fd, (char *)&amp;onebyte, 1, 0 ); if ( ret &lt;= 0 ) { continue; } else { struct sockaddr_in clientaddr; socklen_t addrlen = sizeof(clientaddr); bzero( &amp;clientaddr, addrlen ); int connfd = accept( ppool-&gt;listenfd, (struct sockaddr *)&amp;clientaddr, &amp;addrlen ); if ( connfd &lt; 0 ) { PRINTINFO_ERR( LEVEL3, &quot;accept a new client error!!!&quot; ); continue; } PRINTINFO( LEVEL0, &quot;one client conntect(fd:%d)&quot;, connfd ); Epoll_add_fd( ppool-&gt;epollfd, connfd ); client_param_init( &amp;cparam[connfd], connfd, &amp;clientaddr ); } } //process catch a signal else if ( event_fd == sig_pipefd[1] &amp;&amp; events[i].events &amp; EPOLLIN ) { int sig; char signals[1024] = {0}; ret = recv( sig_pipefd[1], signals, sizeof(signals), 0 ); if ( ret &lt;= 0 ) { continue; } client_signal_handle( ppool, signals, ret ); } //client socket fd has readable event,maybe a //request else if ( events[i].events &amp; EPOLLIN ) { client_handle( &amp;cparam[event_fd] ); } else { continue; } } } _free_source: free( events ); events = NULL; free( cparam ); cparam = NULL; close( pipefd ); close( ppool-&gt;epollfd ); } static int parent_signal_handle( processpool *ppool, char *signals, int signals_num ) { int i = 0, j = 0; for ( ; i &lt; signals_num; i++ ) { switch( signals[i] ) { case SIGCHLD: { PRINTINFO( LEVEL0, &quot;parent receive SIGCHLD signal&quot; ); pid_t pid; int stat; while ( (pid = waitpid(-1, &amp;stat, WNOHANG)) &gt; 0 ) { PRINTINFO( LEVEL0, &quot;parent receive SIGCHLD signal(pid:%d)&quot;, pid ); for ( j = 0; j &lt; ppool-&gt;cur_process_num; j++ ) { if ( ppool-&gt;sub_process[j].pid == pid ) { PRINTINFO( LEVEL3, &quot;child process(%d) exit.&quot;, pid ); close( ppool-&gt;sub_process[j].pipefd[1] ); ppool-&gt;sub_process[j].pid = -1; } } } ppool-&gt;stop = 1; for ( j = 0; j &lt; ppool-&gt;cur_process_num; j++ ) { PRINTINFO( LEVEL0, &quot;pid:%d&quot;, ppool-&gt;sub_process[j].pid ); if ( ppool-&gt;sub_process[j].pid != -1 ) { ppool-&gt;stop = 0; break; } } break; } case SIGTERM: case SIGINT: { PRINTINFO( LEVEL2, &quot;recv SIGINT/SIGTERM, kill all child process now.&quot; ); //PRINTINFO( LEVEL0, &quot;cur_process_num:%d&quot;, ppool-&gt;cur_process_num ); for ( i = 0; i &lt; ppool-&gt;cur_process_num; i++ ) { int pid = ppool-&gt;sub_process[i].pid; if ( pid != -1 ) { PRINTINFO( LEVEL0, &quot;kill process:%d&quot;, pid ); ppool-&gt;sub_process[i].pid = -1; kill( pid, SIGTERM ); } } ppool-&gt;stop = 1; break; } default: { break; } } } } static void run_parent( processpool *ppool ) { if ( !ppool ) { PRINTINFO( LEVEL4, &quot;ppool is null!!!&quot; ); return; } init_signal( ppool ); ppool-&gt;epollfd = Epoll_create( 5 ); Epoll_add_fd( ppool-&gt;epollfd, ppool-&gt;listenfd ); Epoll_add_fd( ppool-&gt;epollfd, sig_pipefd[1] ); struct epoll_event *events = NULL; events = (struct epoll_event *) calloc( sizeof(struct epoll_event), ppool-&gt;max_epoll_event ); if ( !events ) { PRINTINFO( LEVEL5, &quot;calloc error!!!&quot; ); char sig = SIGINT; parent_signal_handle( ppool, &amp;sig, 1 ); goto _free_source; } int event_num; int i, onebyte = 1, ret, j; //p_idx specifies current dispatched child process. //roll_index specifies the next child process. int p_idx , roll_index = 0; //PRINTINFO( LEVEL0, &quot;epollfd:%d&quot;, ppool-&gt;epollfd ); while ( !ppool-&gt;stop ) { //Specifying a timeout of -1 causes epoll_wait() //to block indefinitely. event_num = Epoll_wait( ppool-&gt;epollfd, events, ppool-&gt;max_epoll_event, -1 ); if ( event_num &lt; 0 &amp;&amp; errno != EINTR ) { PRINTINFO_ERR( LEVEL5, &quot;Epoll_wait error!!!&quot; ); ppool-&gt;stop = 1; break; } //PRINTINFO( LEVEL0, &quot;event_num:%d&quot;, event_num ); for ( i = 0; i &lt; event_num; i++ ) { int event_fd = events[i].data.fd; //listenfd,there is a new client connection. //notify child process to accept if ( event_fd == ppool-&gt;listenfd ) { PRINTINFO( LEVEL0, &quot;event:parent listenfd&quot; ); //round robin dispatch //easily roll polling p_idx = roll_index; do { if ( ppool-&gt;sub_process[p_idx].pid != -1 ) { break; } p_idx = ( p_idx + 1 ) % ppool-&gt;cur_process_num; } while ( p_idx != roll_index ); //roll polling all the child process,but they are //all run error.so p_idx equals to roll_index. if ( ppool-&gt;sub_process[p_idx].pid &lt; 0 ) { ppool-&gt;stop = 1; break; } roll_index = ( p_idx + 1 ) % ppool-&gt;cur_process_num; if ( Send( ppool-&gt;sub_process[p_idx].pipefd[0], (char *)&amp;onebyte, 1, 0 ) &lt; 0 ) { PRINTINFO( LEVEL5, &quot;Send error!!!&quot; ); ppool-&gt;stop = 1; break; } } //receive signal from signal handler. else if ( (event_fd == sig_pipefd[1]) &amp;&amp; (events[i].events &amp; EPOLLIN) ) { PRINTINFO( LEVEL0, &quot;event:parent receive signal&quot; ); int sig; char signals[1024]; ret = recv( sig_pipefd[1], signals, sizeof(signals), 0 ); if ( ret &lt;= 0 ) { continue; } else { parent_signal_handle( ppool, signals, ret ); } } } } _free_source: free( events ); events = NULL; close( ppool-&gt;epollfd ); } void run( processpool *ppool ) { if ( ppool-&gt;index != -1 ) { run_child( ppool ); return; } run_parent( ppool ); } client_handle.h: #ifndef _CLIENT_HANDLE_H #define _CLIENT_HANDLE_H #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/socket.h&gt; #include &lt;sys/types.h&gt; #include &lt;arpa/inet.h&gt; #define MAXRECVBUF 1024 typedef struct client_param { //用于recv返回出错移除sockfd int epollfd; int sockfd; struct sockaddr_in addr; char buf[ MAXRECVBUF ]; } client_param; void client_param_init( client_param *cparam, int connfd, struct sockaddr_in *addr ); void client_handle( client_param *cparam ); #endif client_handle.c: #include &quot;client_handle.h&quot; #include &quot;util.h&quot; void client_param_init( client_param *cparam, int connfd, struct sockaddr_in *addr ) { if ( !cparam ) { PRINTINFO( LEVEL4, &quot;cparam is null!!!&quot; ); return; } cparam-&gt;sockfd = connfd; memcpy( &amp;cparam-&gt;addr, addr, sizeof(struct sockaddr_in) ); memset( cparam-&gt;buf, 0, sizeof(cparam-&gt;buf) ); } void client_handle( client_param *cparam ) { int i, ret; while ( 1 ) { memset( cparam-&gt;buf, 0, sizeof(cparam-&gt;buf) ); ret = recv( cparam-&gt;sockfd, cparam-&gt;buf, sizeof(cparam-&gt;buf), 0 ); if ( ret &lt; 0 ) { if ( errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK &amp;&amp; errno != EINTR ) { Epoll_del_fd( cparam-&gt;epollfd, cparam-&gt;sockfd ); } close( cparam-&gt;sockfd ); break; } else if ( 0 == ret ) { Epoll_del_fd( cparam-&gt;epollfd, cparam-&gt;sockfd ); close( cparam-&gt;sockfd ); break; } else { if ( ret &lt; 15 ) { close( cparam-&gt;sockfd ); break; } //PRINTINFO( LEVEL0, &quot;child receive buf:\\n%s&quot;, cparam-&gt;buf ); fflush(stdout); char *p_get = strstr( cparam-&gt;buf, &quot;GET&quot; ); if ( !p_get ) { close( cparam-&gt;sockfd ); break; } char *p_http = strstr( cparam-&gt;buf, &quot;HTTP&quot; ); if ( !p_http ) { close( cparam-&gt;sockfd ); break; } cparam-&gt;buf[ret] = &apos;\\0&apos;; //GET filename HTTP/1.1 ..... char file_name[20] = {0}; int file_name_len = p_http - p_get - 6; memcpy( file_name, p_get + 5, file_name_len ); if ( access( file_name, F_OK ) == -1 ) { PRINTINFO( LEVEL3, &quot;file:(%s) dosen&apos;t exist!!&quot;, file_name ); Epoll_del_fd( cparam-&gt;epollfd, cparam-&gt;sockfd ); close( cparam-&gt;sockfd ); break; } PRINTINFO( LEVEL0, &quot;file name:%s--&quot;, file_name ); ret = fork(); if ( ret == -1 ) { Epoll_del_fd( cparam-&gt;epollfd, cparam-&gt;sockfd ); close( cparam-&gt;sockfd ); break; } else if ( ret &gt; 0 ) { Epoll_del_fd( cparam-&gt;epollfd, cparam-&gt;sockfd ); close( cparam-&gt;sockfd ); break; } else { close( STDOUT_FILENO ); //relocate the stdou to sockfd PRINTINFO( LEVEL0, &quot;sockfd:%d&quot;, cparam-&gt;sockfd ); dup( cparam-&gt;sockfd ); //printf(&quot;likun\\n&quot;); execl( file_name, file_name, NULL ); fflush(stdout); Epoll_del_fd( cparam-&gt;epollfd, cparam-&gt;sockfd ); close( cparam-&gt;sockfd ); exit( 0 ); } } } } cgisrv.c: #include &quot;myhshappool.h&quot; #include &quot;client_handle.h&quot; #include &quot;util.h&quot; #include &quot;epoll_wrapper.h&quot; //进程池最大数量 #define MAXPROCESSNUMBER 16 //每个进程支持客户连接任务 #define USERPERPROCESS 65535 //epool最大支持的监听事件数 #define MAXEPOLLEVENT 10000 processpool ppool; int main() { int listenfd = Socket_create( &quot;192.168.1.250&quot;, 8888 ); init_process_pool( &amp;ppool, MAXPROCESSNUMBER, USERPERPROCESS, MAXEPOLLEVENT, 5, listenfd ); run( &amp;ppool ); close( listenfd ); return 0; } 贴一下makefile： CC = gcc ROOTDIR = $(shell pwd) OBJ = util.o myhshappool.o epoll_wrapper.o \\ client_handle.o cgisrc.o BIN = cgisrv.bin CFLAG = -Wall -O2 -I./ LDFLAG += -c $(BIN):${OBJ} $(CC) $(CFLAG) -o $@ $^ %:%.c $(CC) $(CFLAG) -o $@ $&lt; $(LDFLAG) .PHONY:clean clean: rm $(OBJ) $(BIN) -rf 还有cgi执行程序： #include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;string.h&gt; /* &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;u&gt;&lt;font color=00ff00&gt;..&lt;/font&gt;&lt;/u&gt;&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; */ int main( int argc, char **argv ) { time_t tt = time(NULL); printf(&quot;&lt;!DOCTYPE html&gt;&quot;); printf(&quot;&lt;html&gt;&quot;); printf(&quot;&lt;head&gt;&quot;); printf(&quot;&lt;meta charset=\\&quot;utf-8\\&quot;&gt;&quot;); printf(&quot;&lt;title&gt;get now time&lt;/title&gt;&quot;); printf(&quot;&lt;/head&gt;&quot;); printf(&quot;&lt;body&gt;&quot;); printf(&quot;&lt;h1&gt;&lt;u&gt;&lt;font color=00ff00&gt;&quot;); printf(&quot;当前服务器时间:%s&quot;, ctime(&amp;tt)); printf(&quot;&lt;/font&gt;&lt;/u&gt;&lt;/h1&gt;&quot;); printf(&quot;&lt;/body&gt;&quot;); printf(&quot;&lt;/html&gt;&quot;); return 0; } 测试：代码编译了，即可执行cgisrv.bin，主进程处于监听客户端连接情况，打开浏览器输入: http://xxx.xxx.xxx.xxx:8888/now.cgi，可以看到出现一行加下划线的绿字：当前服务器时间:Sat Sep 17 21:49:07 2016。 ip、端口、进程池数、最大epoll监听事件数等在入口模块(cgisrv)可以改。 本例子写完，调试了几个地方，运行几个客户端发送get请求就没有做测试了，练手的玩具demo ^_^。","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://lkness/tags/C-C/"}]},{"title":"归并排序-《算法导论》学习笔记二","slug":"008merge-sort/index","date":"2018-06-15T10:40:26.000Z","updated":"2018-06-19T02:02:56.123Z","comments":true,"path":"2018/06/15/008merge-sort/index/","link":"","permalink":"http://lkness/2018/06/15/008merge-sort/index/","excerpt":"","text":"算法导论第二章3小节讲到分治法，即将大问题化解为规模小一些的同类问题，这样先处理小问题，再合并两个小问题再解决，递归的思路。按照书上的伪代码，写了c算法。 #include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt; void merge( int *arr, int p, int q, int r ) { int arrlen = r - p + 1; int *tmparr = (int *)malloc( sizeof(int) * arrlen ); int i, j, k, tmp; for ( i = 0; i &lt; arrlen; i++ ) tmparr[i] = arr[i + p]; j = 0; k = q - p + 1; for ( i = p; i &lt; r + 1; i++ ) { if ( tmparr[j] &gt; tmparr[k] ) { arr[i] = tmparr[k]; k++; } else { arr[i] = tmparr[j]; j++; } if ( j == q - p + 1 || k == r - p + 1 ) { i++; break; } } for ( ; i &lt; r + 1; i++ ) { if ( j &lt; q - p + 1 ) { arr[i] = tmparr[j]; j++; continue; } if ( k &lt; r - p + 1 ) { arr[i] = tmparr[k]; k++; continue; } } free( tmparr ); tmparr = NULL; } void mergeSort( int *arr, int p, int r ) { int q; if ( p &lt; r ) { q = ( p + r ) / 2; mergeSort( arr, p, q ); mergeSort( arr, q + 1, r ); merge( arr, p, q, r ); } } void sortLoop0( int *arr, int len ) { mergeSort( arr, 0, len - 1 ); } //排序前后做时间对比，精度sec void sortLoop( int *arr, int len ) { time_t tt0 = time( NULL ); printf(&quot;\\tbefore sort:%s&quot;, ctime(&amp;tt0)); sortLoop0( arr, len ); time_t tt1 = time( NULL ); printf(&quot;\\tafter sort:%s&quot;, ctime(&amp;tt1)); printf(&quot;\\tsort the array cost %d(sec),%d(min)\\n&quot;, (int)(tt1 - tt0), (int)((tt1 - tt0) / 60)); } //初始化随机数组 void initArr( int *arr, int lowV, int upV, int len ) { srand( (int)time(NULL) ); int i = 0; int size = upV - lowV; for ( ; i &lt; len; i++ ) { arr[i] = rand() % size + lowV; } } //打印数组 void printArr( int *arr, int len ) { int i = 0; for ( ; i &lt; len; i++ ) printf(&quot;%d &quot;, arr[i]); printf(&quot;\\n&quot;); } //这里写了个简单得数组检查，检查是否 //是正确的递增序列(怕自己的代码没检查 //边界条件偶尔有错误的排序数组) int check_arr_increase( int *arr, int len ) { int i = 0; for ( ; i &lt; len - 1; i++ ) { if ( arr[i] &lt;= arr[i + 1] ) continue; else { printf(&quot;array isn&apos;t increase!!!\\n&quot;); return -1; } } printf(&quot;array is increase!!!!\\n&quot;); return 0; } int main( int argc, char **argv ) { if ( argc != 4 ) { printf(&quot;usage: ./execfile lowV upV len\\n&quot;); return 0; } int lowV = atoi( argv[1] ); int upV = atoi( argv[2] ); unsigned int len = atoi( argv[3] ); int *arr = NULL; arr = ( int *) malloc( len * sizeof(int) ); initArr( arr, lowV, upV, len ); //printArr( arr, len ); sortLoop( arr, len ); check_arr_increase( arr, len ); //printArr( arr, len ); free( arr ); arr = NULL; return 0; } 分治法的算法复杂度可以计算，效率是很恐怖的，排序取值10-1000000值长度1000万的数组用时4s： 排序取值10-1000000值长度1亿的数组用时85s：","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://lkness/tags/数据结构-算法/"}]},{"title":"插入排序-《算法导论》学习笔记一","slug":"007insert-sort/index","date":"2018-06-15T10:37:04.000Z","updated":"2018-06-19T02:02:56.123Z","comments":true,"path":"2018/06/15/007insert-sort/index/","link":"","permalink":"http://lkness/2018/06/15/007insert-sort/index/","excerpt":"","text":"算法导论第二章的第一小节是插入排序，也就是像打扑克牌整理扑克一样，从左边第二张开始，每张与前边排好序的扑克牌比较，比较到能插入的位置就插入，算法比较简单。 #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;time.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; void insert_sort0( int* arr, int idx ) { int i = idx - 2; int tmp = arr[idx]; arr[idx] = arr[idx - 1]; for ( ; i &gt;= 0; i-- ) { if ( arr[i] &gt; tmp ) arr[i + 1] = arr[i]; else { arr[i + 1] = tmp; break; } } if ( i &lt; 0 ) arr[0] = tmp; } int insert_sort( int* arr, int len) { time_t t_old, t_new; t_old = time(NULL); if ( arr[0] &gt; arr[1] ) { int tmp = arr[0]; arr[0] = arr[1]; arr[1] = tmp; } int i = 1; for ( ; i + 1&lt; len; i++ ) { if ( arr[i + 1] &lt; arr[i] ) { insert_sort0( arr, i + 1 ); } } t_new = time(NULL); return (int)(t_new - t_old); } void sortLoop0( int *arr, int len ) { insert_sort( arr, len ); } //排序前后做时间对比，精度sec void sortLoop( int *arr, int len ) { time_t tt0 = time( NULL ); printf(&quot;\\tbefore sort:%s&quot;, ctime(&amp;tt0)); sortLoop0( arr, len ); time_t tt1 = time( NULL ); printf(&quot;\\tafter sort:%s&quot;, ctime(&amp;tt1)); printf(&quot;\\tsort the array cost %d(sec),%d(min)\\n&quot;, (int)(tt1 - tt0), (int)((tt1 - tt0) / 60)); } //初始化随机数组 void initArr( int *arr, int lowV, int upV, int len ) { srand( (int)time(NULL) ); int i = 0; int size = upV - lowV; for ( ; i &lt; len; i++ ) { arr[i] = rand() % size + lowV; } } //打印数组 void printArr( int *arr, int len ) { int i = 0; for ( ; i &lt; len; i++ ) printf(&quot;%d &quot;, arr[i]); printf(&quot;\\n&quot;); } //这里写了个简单得数组检查，检查是否 //是正确的递增序列(怕自己的代码没检查 //边界条件偶尔有错误的排序数组) int check_arr_increase( int *arr, int len ) { int i = 0; for ( ; i &lt; len - 1; i++ ) { if ( arr[i] &lt;= arr[i + 1] ) continue; else { printf(&quot;array isn&apos;t increase!!!\\n&quot;); return -1; } } printf(&quot;array is increase!!!!\\n&quot;); return 0; } int main( int argc, char **argv ) { if ( argc != 4 ) { printf(&quot;usage: ./execfile lowV upV len\\n&quot;); return 0; } int lowV = atoi( argv[1] ); int upV = atoi( argv[2] ); unsigned int len = atoi( argv[3] ); int *arr = NULL; arr = ( int *) malloc( len * sizeof(int) ); initArr( arr, lowV, upV, len ); //printArr( arr, len ); sortLoop( arr, len ); check_arr_increase( arr, len ); //printArr( arr, len ); free( arr ); arr = NULL; return 0; } 我的ubuntu虚拟机环境是双核3代i5,2G内存，排序10-100000的随机10万的数组如下情况： 如果是100万的数组，耗时10几分钟；如果是1000万的数组，挂着跑了一晚上都没排好序。 对插入排序的一点思考：在写排序的时候想到当前数可以从排好序数组后往前比较，也可以从前往后比较，前一种比较一个不符合即可将比较的数组值后移一位，给待插入值让位，这样就在比较重顺便后移，如果是后一种比较插入方法，则是遍历排好序数组，直到找到符合的索引位置，将位置后边的数组后移，这样相当于每次都要遍历一遍排好序数组，因此不用此方法。","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://lkness/tags/数据结构-算法/"}]},{"title":"C时间堆","slug":"006time-heap/index","date":"2018-06-15T07:46:30.000Z","updated":"2018-06-19T02:02:56.115Z","comments":true,"path":"2018/06/15/006time-heap/index/","link":"","permalink":"http://lkness/2018/06/15/006time-heap/index/","excerpt":"","text":"跟上一篇，这里写一下时间堆： 时间轮的滴答是固定以指定的槽间隔触发，而时间堆是以定时器堆中的最小到期时间做定时，也就是alarm(minTimeout)，一旦定时器被触发，那么就删除此定时器，更新时间堆，将新的最小到期时间定时器作为新的定时。 然后是时间堆的数据结构，这里用了二叉树，将二叉树的根节点作为最小最小到期时间，每次滴答就取根节点，并且是完全二叉树，因此比较容易理解，我也懒得画图了，截了书上的图： 从图中可以看到，对时间堆的关键操作其实就是上滤和下滤，上滤也就是简单的将完全二叉树待添加的定时器最为最后一个节点并与父节点比较，如果小于，则交换两节点位置，再将此节点与父节点比较，直到待插入节点值大于父节点值或者已经是根节点即停止；下滤就是触发一个定时器之后删除此定时器，然后取完全二叉树的深度最大一排的最后一个叶子节点作为根节点，然后用此根节点与两个儿子节点比较，若根节点值大于儿子节点中最大者，则交换这两个节点，再以这个节点做同样的下滤，如果对于任意完全二叉树，这样简单的下滤不能找出最小节点，但是配合定时器添加时的上滤操作后的完全二叉树，这样就可行。 下面贴自己改的代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;signal.h&gt; #include &lt;time.h&gt; typedef struct client_data { char buf[512]; time_t tt; void* data; } client_data; typedef struct heap_timer { //单个定时器设置绝对时间 time_t expire; //加的设置的定时器到时秒数 int timeout; //到时回调函数 void (*cb_func)( void* ); //回调函数参数 struct client_data* user_data; } heap_timer ; typedef struct h_t_manager { //定时器指针数组 struct heap_timer** array; //当前定时管理器支持的最大定时器个数 int capacity; //当前定时管理器上的定时器个数 int cur_size; } h_t_manager ; void cb_func( void* param ) { time_t tt = time(NULL); printf(&quot;\\n-----------------------------------------------\\n&quot;); printf(&quot;\\tontime,cur time - old time:%d\\n&quot;, (int)(tt - ((client_data*)param)-&gt;tt)); printf(&quot;\\toldtime:%s&quot;, ctime(&amp;(((client_data*)param)-&gt;tt))); printf(&quot;\\tcurtime:%s&quot;, ctime(&amp;tt)); printf(&quot;-----------------------------------------------\\n&quot;); } static void percolate_down( h_t_manager* tmanager, int hole ) { heap_timer* temp = tmanager-&gt;array[hole]; int flag = 0; int child = 0; for ( ; ((hole*2+1) &lt;= (tmanager-&gt;cur_size-1)); hole = child ) { flag = 0; child = hole * 2 + 1; //这里找出当前节点最小儿子节点 if ( (child &lt; (tmanager-&gt;cur_size-1)) &amp;&amp; (tmanager-&gt;array[child+1]-&gt;expire) &lt; tmanager-&gt;array[child]-&gt;expire ) { ++child; } //比较待删除节点和最小儿子节点，若大于就交换 if ( tmanager-&gt;array[child]-&gt;expire &lt; temp-&gt;expire ) { //这里的交换其实该用内存拷贝比较好 int tmp_expire = tmanager-&gt;array[hole]-&gt;expire; int tmp_timeout = tmanager-&gt;array[hole]-&gt;timeout; tmanager-&gt;array[hole]-&gt;expire = tmanager-&gt;array[child]-&gt;expire; tmanager-&gt;array[hole]-&gt;timeout = tmanager-&gt;array[child]-&gt;timeout; tmanager-&gt;array[child]-&gt;expire = tmp_expire; tmanager-&gt;array[child]-&gt;timeout = tmp_timeout; } else { break; } //新的下滤比较 temp = tmanager-&gt;array[child]; //tmanager-&gt;array[hole] = temp; } } //将堆数组的容量扩大1倍 static int resize( h_t_manager* tmanager ) { heap_timer** temp = (heap_timer**) malloc( 2 * tmanager-&gt;capacity * sizeof(h_t_manager) ); int i = 0; for ( ; i &lt; 2 * tmanager-&gt;capacity; ++i ) { temp[i] = NULL; } if ( !temp ) { return -1; } tmanager-&gt;capacity = 2 * tmanager-&gt;capacity; for ( i = 0; i &lt; tmanager-&gt;cur_size; ++i ) { temp[i] = tmanager-&gt;array[i]; free(tmanager-&gt;array[i]); tmanager-&gt;array[i] = NULL; } tmanager-&gt;array = temp; return 0; } int init_ht_manager_0( h_t_manager* tmanager, int cap ) { tmanager-&gt;capacity = cap; tmanager-&gt;cur_size = 0; tmanager-&gt;array = (heap_timer**)malloc(cap * sizeof(h_t_manager)); int i = 0; for ( ; i &lt; cap; ++i ) { tmanager-&gt;array[i] = NULL; } } //添加定时器 int add_timer( h_t_manager* tmanager, int timeout ) { if ( !tmanager || timeout &lt;= 0) { return -1; } if ( tmanager-&gt;cur_size &gt;= tmanager-&gt;capacity ) { resize( tmanager ); } int hole = tmanager-&gt;cur_size++; int parent = 0; heap_timer* timer = (heap_timer*)malloc(sizeof(heap_timer)); time_t tt = time(NULL); timer-&gt;expire = (int)tt + timeout; timer-&gt;timeout = timeout; timer-&gt;user_data = (client_data*)malloc(sizeof(client_data)); timer-&gt;user_data-&gt;tt = time(NULL); timer-&gt;cb_func = cb_func; for ( ; hole &gt; 0; hole = parent ) { parent = ( hole - 1 ) / 2; if ( tmanager-&gt;array[parent]-&gt;expire &lt;= timer-&gt;expire ) { break; } tmanager-&gt;array[hole] = tmanager-&gt;array[parent]; } tmanager-&gt;array[hole] = timer; return 0; } int del_timer( h_t_manager* tmanager, heap_timer* timer ) { if ( !tmanager || !timer ) { return -1; } timer-&gt;cb_func = NULL; } int empty( h_t_manager* tmanager ) { return tmanager-&gt;cur_size == 0; } heap_timer* top( h_t_manager* tmanager ) { if ( empty(tmanager) ) { printf(&quot;!!!!!!!top-&gt;empty cur size\\n&quot;); return NULL; } return tmanager-&gt;array[0]; } int pop_timer( h_t_manager* tmanager ) { if ( empty( tmanager ) ) { printf(&quot;!!!!!!!pop_timer-&gt;empty cur size\\n&quot;); return -1; } if ( tmanager-&gt;array[0] ) { free( tmanager-&gt;array[0] ); tmanager-&gt;array[0] = NULL; tmanager-&gt;array[0] = tmanager-&gt;array[--tmanager-&gt;cur_size]; percolate_down( tmanager, 0 ); } return 0; } void tick( h_t_manager* tmanager ) { heap_timer* tmp = tmanager-&gt;array[0]; time_t cur = time( NULL ); while ( !empty(tmanager) ) { if ( !tmp ) { break; } if ( tmp-&gt;expire &gt; cur ) { break; } if ( tmanager-&gt;array[0]-&gt;cb_func ) { printf(&quot;timer on time,heap:&quot;); int i = 0; for ( ; i &lt; 10; i++ ) { if ( tmanager-&gt;array[i] ) printf(&quot;%d:%d &quot;, i, tmanager-&gt;array[i]-&gt;timeout); } tmanager-&gt;array[0]-&gt;cb_func( tmanager-&gt;array[0]-&gt;user_data ); } pop_timer( tmanager ); tmp = tmanager-&gt;array[0]; printf(&quot;after timer on time,heap:&quot;); int i = 0; for ( ; i &lt; 10; i++ ) { if ( tmanager-&gt;array[i] ) printf(&quot;%d:%d &quot;, i, tmanager-&gt;array[i]-&gt;timeout); } printf(&quot;\\n&quot;); if ( tmanager-&gt;array[0] ) printf(&quot;the next alarm is:%d\\n&quot;, (int)(tmanager-&gt;array[0]-&gt;timeout)); printf(&quot;current timer count:%d\\n&quot;, tmanager-&gt;cur_size); } } h_t_manager tmanager; void alarm_handler( int sig ) { tick( &amp;tmanager ); alarm( tmanager.array[0]-&gt;expire - time(NULL) ); } int main() { printf(&quot;start timer 。。。。。。。\\n&quot;); init_ht_manager_0( &amp;tmanager, 20 ); add_timer( &amp;tmanager, 11 ); add_timer( &amp;tmanager, 5 ); add_timer( &amp;tmanager, 11 ); // add_timer( &amp;tmanager, 22 ); add_timer( &amp;tmanager, 6 ); add_timer( &amp;tmanager, 9 ); // add_timer( &amp;tmanager, 23 ); // add_timer( &amp;tmanager, 33 ); // add_timer( &amp;tmanager, 28 ); // add_timer( &amp;tmanager, 1 ); // add_timer( &amp;tmanager, 66 ); // add_timer( &amp;tmanager, 77 ); // add_timer( &amp;tmanager, 88 ); // add_timer( &amp;tmanager, 55 ); signal( SIGALRM, alarm_handler ); time_t tt = time(NULL); printf(&quot;current time:%s&quot;, ctime(&amp;tt)); alarm( tmanager.array[0]-&gt;expire - time(NULL) ); while(1) sleep(5); return 0; } 因为用的完全二叉树，比较简单，跟上一篇时间轮一样，存在注意某些使用问题，整理的时候发现时间堆代码的注释还没写，想着自己加一点，发现很久前写的代码了，有点忘了，加了点也困了，打完羽毛球回来又连撸两篇博客 ，还被蚊子咬，一挠还挠死个咬得比我写博客还专注的蚊子 ，醉了 ~","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://lkness/tags/C-C/"}]},{"title":"C时间轮","slug":"005time-wheel/index","date":"2018-06-15T07:41:11.000Z","updated":"2018-06-19T02:02:56.087Z","comments":true,"path":"2018/06/15/005time-wheel/index/","link":"","permalink":"http://lkness/2018/06/15/005time-wheel/index/","excerpt":"","text":"看完了《linux高性能服务器编程》对里面的定时器很感兴趣。书中提到三种定时器，分别是：基于升序链表的定时器，基于时间轮的定时器，基于时间堆的定时器。三种定时器的实现书中均是给了C++代码，不过我对C++不太感兴趣，虽然现在在做C++开发，因此写了C版本的。书中定时器只给了封装的定时器类，没有给调用层代码，我是估摸着写了调用层代码。这里做个总结，以后可以翻翻： 基于升序链表的定时器没太大难度，因此也懒得总结了。 说一下时间轮，下面是截的书中的图片： 时间轮，像轮子一样滚动定时，每滚一个刻度，指针就走一个滴答，滚完一圈，就进入下一圈。因此有了这个概念，时间轮的结构也就出来了：1.齿轮（槽slot），用来标识一个滴答；2.槽间隔（slot interval ），当前槽经过多长时间到下一个槽；3.一圈的槽数量（N）；4.当前指针，走一个滴答加一，走完一圈又回到初始位置。 再深入一点，定时器以什么方式添加到槽上？可以看图，每一个槽其实就是一个链表头结点，定时器即添加到所属槽的链表后。这样我们可以对时间轮性能进行分析，SI越小，定时精度越高，如果SI=10s，那么我们指定的定时器只能是10s的倍数；如果N越大，定时器效率越高，这也很好理解，N越小，一圈槽数量越少，那么我们同样添加100个定时器，分配到每个头结点的定时器越多，每一次滴答到时，就遍历当前槽，遍历一次所花时间越多。 如何确定定时器位置？根据定时器到时时间可以计算，例如：定时器超时时间timeout=21s(即21s后触发定时器)，当前间隔SI=2s，一圈槽数量N=70，当前指针cur_slot指向第5个槽，我们可以计算出定时器放置的位置，这里需要两个变量，一个rotation指定定时器处于第几圈，一个slot指定定时器处于第几个槽，因此slot = ( cur_slot + timeout / SI ) % N = 15, rotation = timeout / SI / N = 0，即此定时器被放置于15槽的链表后，至于是链表头插还是尾插这个随意，指针滴答到了15槽即触发15槽到时，遍历15槽链表，若rotation=0的表示为当前该触发定时器，若rotation&gt;0的定时器对rotation–（其实很好理解，cur_slot在转当前轮，则不处理后面的轮，只对它的rotation减一就跳过，等到cur_slot转下一圈再判断此定时器）。根据这个计算，如果其它参数不变，现在有一个timeout=161s的定时器，cur_slot=5,我们可以计算出这个定时器的slot=15，rotation=1，正好处于第15槽，但是是下一转触发该触发。 也就是说，如果我们根据以上参数，同时添加一个15s和一个161s定时器，他们都会随时间轮轮转触发到，只不过指针第一次只想15槽时，判断15s的定时器rotation为0，则触发定时器，然后删除定时器，遍历到161s定时器时，rotation=1，执行减1，跳过继续轮转，当cur_slot=70的时候也就是时间轮走过652=130s时，时间轮转一圈，cur_slot=0，继续下一圈开始，再走过142=28s后，到达15槽，判断161s定时器，rotation=0，触发定时器。 有了这些分析，下面直接贴代码： #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;time.h&gt; #include &lt;unistd.h&gt; #include &lt;signal.h&gt; #include &lt;stdlib.h&gt; typedef struct client_data { int fd; time_t tt; char buf[512]; void* data; }client_data; typedef struct tw_timer { //处于时间轮第几转，即时间轮转多少转 //此定时器可以处于当前转，若再加上槽 //即可确定此定时器所处时间轮位置 int rotation; //处于当前时间轮转的第几个槽 int slot; //定时器到时执行的回调函数 void* (*cb_func)( void* param ); //用户数据，触发回调任务函数的参数 struct client_data c_data; //这里只需要单向不循环链表即可 //struct tw_timer* prev; struct tw_timer* next; }tw_timer; typedef struct timer_manager { //时间轮当前槽，每经过一个间隔时间，加一实现轮转动， //超过总槽数即归零表示当前轮转完 int cur_slot; //时间轮一转的总槽数，总槽数越大槽链表越短，效率越高 int slot_num_r; //相邻时间槽间隔时间，即时间轮转到下一个槽需要时间， //间隔时间越短，精度越高，例如10s，表示定时器支持10s //间隔定时器添加，最小支持1s int slot_interval; //每个时间槽链表头结点，即一个槽管理一条链表，链表 //添加相同槽数的结点，但转数可能不同 struct tw_timer* slots_head[512]; }timer_manager; timer_manager tmanager; void* ontime_func( void* param ) { client_data* data = (client_data*)param; time_t tt = time(NULL); printf(&quot;\\n----------------------------------------------------\\n&quot;); printf(&quot;\\tontime,interval:%d\\n&quot;, (int)(tt - data-&gt;tt)); printf(&quot;\\told time:%s&quot;, ctime(&amp;data-&gt;tt)); printf(&quot;\\t%s&quot;, data-&gt;buf); printf(&quot;\\tcur time:%s&quot;, ctime(&amp;tt)); //getchar(); printf(&quot;----------------------------------------------------\\n&quot;); return NULL; } int add_timer( timer_manager* tmanager, int timeout, client_data* c_data ) { if ( timeout &lt; 0 || !tmanager ) return -1; int tick = 0; //转动几个槽触发 int rotation = 0; //处于时间轮第几转 int slot = 0; //距离当前槽相差几个槽 if ( timeout &lt; tmanager-&gt;slot_interval ) tick = 0; else tick = timeout / tmanager-&gt;slot_interval; rotation = tick / tmanager-&gt;slot_num_r; slot = ( tmanager-&gt;cur_slot + tick % tmanager-&gt;slot_num_r ) % tmanager-&gt;slot_num_r - 1; printf(&quot;addtimer--&gt;timeout:%d, rotation:%d,slot:%d\\n&quot;, timeout, rotation, slot); tw_timer* tmp_t = (tw_timer*)malloc(sizeof(tw_timer)); tmp_t-&gt;rotation = rotation; char buf[100] = {0}; time_t tt = time(NULL) + timeout; sprintf( buf, &quot;set time:%s&quot;, ctime(&amp;tt)); memset( tmp_t-&gt;c_data.buf, 0, sizeof(tmp_t-&gt;c_data.buf)); strcpy( tmp_t-&gt;c_data.buf, buf ); tmp_t-&gt;slot = slot; tmp_t-&gt;c_data.tt = time(NULL); tmp_t-&gt;cb_func = ontime_func; if ( !tmanager-&gt;slots_head[slot] ) { tmanager-&gt;slots_head[slot] = tmp_t; tmp_t-&gt;next = NULL; //printf(&quot;[line]:%d\\n&quot;, __LINE__); return 0; } //printf(&quot;[line]:%d\\n&quot;, __LINE__); tmp_t-&gt;next = tmanager-&gt;slots_head[slot]-&gt;next; tmanager-&gt;slots_head[slot]-&gt;next = tmp_t; return 0; } int del_all_timer( timer_manager* tmanager ) { //清除、释放所有定时器，懒得写了 } int tick( timer_manager* tmanager ) { if ( !tmanager ) return -1; tw_timer* tmp = tmanager-&gt;slots_head[tmanager-&gt;cur_slot]; tw_timer* p_tmp; while ( tmp ) { //rotation减一，当前时间轮转不起作用 //假设这个tmp指向第0个槽的头，链中某个结点的rotaion为下一圈， //即rotation=1，所以这个定时器不起作用，而因为cur_slot不断 //走动，tmp在当前转不可能再指向这个定时器，下一圈cur_slot //为0时能继续判断这个定时器，故实现了定时器处于不同转的判断 if ( tmp-&gt;rotation &gt; 0 ) { tmp-&gt;rotation--; p_tmp = tmp; tmp = tmp-&gt;next; } else { //否则定时器到时，触发回调函数 tmp-&gt;cb_func( &amp;tmp-&gt;c_data ); //删除此定时器结点 //吃了没用双向链表的亏，写这么low if ( tmp == tmanager-&gt;slots_head[tmanager-&gt;cur_slot] ) { //printf(&quot;[line]:%d\\n&quot;, __LINE__); tmanager-&gt;slots_head[tmanager-&gt;cur_slot] = tmp-&gt;next; p_tmp = tmp; tmp = tmp-&gt;next; free( p_tmp ); p_tmp = NULL; p_tmp = tmp; //printf(&quot;[line]:%d\\n&quot;, __LINE__); } else { p_tmp-&gt;next = p_tmp-&gt;next-&gt;next; free( tmp ); tmp = NULL; tmp = p_tmp-&gt;next; } } } //更新时间轮，转动一个槽，转一圈又从开始转 tmanager-&gt;cur_slot = ++tmanager-&gt;cur_slot % tmanager-&gt;slot_num_r; return 0; } int init_t_manager( timer_manager* tmanager, int slot_num_r, int slot_interval ) { tmanager-&gt;cur_slot = 0; tmanager-&gt;slot_num_r = slot_num_r; tmanager-&gt;slot_interval = slot_interval; return 0; } //自己试着写的调用层代码 void alarm_handler( int sig ) { time_t tt = time(NULL); //printf(&quot;timer tick:%s&quot;, ctime(&amp;tt)); int ret = tick( &amp;tmanager ); if ( ret &lt; 0 ) printf(&quot;tick error\\n&quot;); alarm( tmanager.slot_interval ); } int main() { time_t tt = time(NULL); signal( SIGALRM, alarm_handler ); //init_t_manager( &amp;tmanager, 60, 10 ); init_t_manager( &amp;tmanager, 60, 1 ); add_timer( &amp;tmanager, 6, NULL ); add_timer( &amp;tmanager, 11, NULL ); add_timer( &amp;tmanager, 22, NULL ); add_timer( &amp;tmanager, 33, NULL ); add_timer( &amp;tmanager, 44, NULL ); add_timer( &amp;tmanager, 55, NULL ); add_timer( &amp;tmanager, 66, NULL ); add_timer( &amp;tmanager, 77, NULL ); add_timer( &amp;tmanager, 88, NULL ); add_timer( &amp;tmanager, 99, NULL ); add_timer( &amp;tmanager, 111, NULL ); add_timer( &amp;tmanager, 122, NULL ); add_timer( &amp;tmanager, 133, NULL ); add_timer( &amp;tmanager, 144, NULL ); printf(&quot;start time:%s\\n&quot;, ctime(&amp;tt)); alarm( tmanager.slot_interval ); while ( 1 ) sleep( 5 ); return 0; } 看以上代码，main函数开始即指定了SI=1s，N=60，并添加了很多定时器，然后开始以SI执行定时，每一次到时就触发滴答函数tick()，如此循环定时触发到时信号就实现了时间轮轮转。 关于代码的思考：这里用了SIGALRM信号，每一次到时，主线程暂停，去执行信号函数内容，如果信号SIGALRM的处理函数太庞大，会影响主线程的任务卡顿，虽然以上代码执行量不大，但为了扩展，我觉得可以将定时器触发执行的操作改为添加任务结点到任务链，这样配合线程池效率会高一点，线程池本身会从任务链取任务结点执行，如果我们的定时处理函数只是往任务链放任务，那性能会高很多，而不是往cb_func里执行具体业务逻辑。 下一篇上时间堆。","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://lkness/tags/C-C/"}]},{"title":"Linux daemon守护进程的创建","slug":"004deamon/index","date":"2018-06-14T13:31:50.000Z","updated":"2018-06-19T02:02:56.055Z","comments":true,"path":"2018/06/14/004deamon/index/","link":"","permalink":"http://lkness/2018/06/14/004deamon/index/","excerpt":"","text":"今天在看《UNIX网络编程》的时候，看到了守护进程的创建，代码中fork了两次，并且第一次fork后对子进程调用setsid()，有些懵。当时搜了下setsid也是看得有点云里雾里。后来折腾了一下午，才算有点明白，这里把自己的一点分析心得写上来，以后忘了可以翻翻： 这里我用ssh登陆ubuntu，在终端用vim编写。 第一次fork我们先写一个简单的代码来fork并创建一个后台程序，代码如下： //testdaemon1.c #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;signal.h&gt; int main() { pid_t pid; if ( (pid = fork()) &lt; 0 ) return -1; else if ( pid ) exit( 0 ); signal( SIGHUP, SIG_IGN ); int i = 10; while ( i-- ) sleep( 5 ); return 0; } 编译gcc -o testdaemon1 testdaemon1.c运行./testdaemon1 然后我们用ps查看程序:ps axjf | grep testdaemon1 1 28511 28510 28168 pts/18 28168 S 0 0:00 ./testdaemon1 这里看第二列是进程id(28511)，第四列是sessionId(28168)，第五列是控制终端(pts/18)，代码中子进程fork而来，会默认继承父进程的控制终端以及会话组。而如果我们查看linux后台守护进程的话，会发现进程控制终端为“？”，因此这个代码距离标准的守护进程还有距离，后面逐一分析。 什么是会话session呢？我大概的理解就是linux下进程组织结构分很多会话，一个会话有很多进程，会话的首进程会有一个控制终端，一个会话只能有一个控制终端。而我们现在用ssh登陆ubuntu创建了一个会话，此会话首进程id号就是28168,如果我们运行ps aux | grep 28168会输出下面值: root 28168 0.0 0.4 6904 4640 pts/18 Ss+ 16:06 0:00 -bash 可以看到这个进程是 bash进程shell终端，其控制终端是pts/18，此后我们在此终端运行的进程都属于以这个首进程id为sessionId的会话组，我们可以运行一个后台的top程序:top &amp;ps axjf | grep top得到下面输出： 28168 28670 28670 28168 pts/18 28672 T 0 0:00 _ top 再看28168的会话组： ps axjf | grep 28168得到下面输出： 28141 28168 28168 28168 pts/18 28693 Ss 0 0:00 _ -bash 28168 28670 28670 28168 pts/18 28693 T 0 0:00 _ top 28168 28693 28693 28168 pts/18 28693 R+ 0 0:00 _ ps axjf 28168 28694 28693 28168 pts/18 28693 S+ 0 0:00 _ grep –color=auto 28168 1 28691 28690 28168 pts/18 28693 S 0 0:00 ./testdaemon1 可以看到运行的几个后台程序sid都是28168。 说了这么多，这个会话组有什么作用呢？我们就要提到SIGHUP信号了，SIGHUP信号会在终端关闭时或者会话首进程退出时发送给会话组的其它进程，当其它进程收到此信号时如果不捕获或者忽略信号的话，默认会退出。如果现在点击ssh窗口的×关闭终端界面或者kill -9 28618的话，下面所属的进程都会退出。 因此，我们在代码中要调用setsid()，将子进程与父进程会话分离、终端分离，我们加入setsis再编译执行： ./testdaemon1执行ps axjf | grep testdaemon1 1 28891 28891 28891 ? -1 Ss 0 0:00 ./testdaemon1 看到其所属会话组已经变成新的（它自己为首进程）会话组，而终端也变为？，这正是我们看linux下其他守护进程的状态。 第二次fork第一次fork还不够，因为我们setsid之后，第一子进程变为新会话首进程，它有权限重新申请打开一个终端，为了避免这种情况，可以通过使进程不再成为会话组长来禁止进程重新打开控制终端，这就需要第二次调用fork()函数 改变工作路径第二次fork之后，我们在第二子进程里可以进行一些守护进程属性设置了， 改变工作路径可以用chdir(“/”)，为什么要改变工作路径呢？《unix网络编程》中Stevens大神说得很清楚，这里搬过来“守护进程可能是在某个任意的文件系统中启动，如果仍然在其中，那么该文件系统就无法拆卸(unmounting)，除非使用潜在的破坏性的强制措施。” 关闭所有打开的文件描述符守护进程从执行它的进程(当前的shell)继承所有打开的描述符。但没有现成的函数提供来检测打开的文件描述符，Stevens大神的解决办法是关闭前64个，而我在网上找到的有用getdtablesize()，有用NOFILE宏(sys/param.h)的，我的ubuntu前者为1024，后者为256，也不想去深究了。 重定向stdin、stdout、stderr上一步关闭了0开始的描述符，而stdin stdout stderr分别对应0 1 2，因此关闭之后如果不进行重定向，守护进程分配文件描述符会从0开始，因此stevens大神打开/dev/null三次，分配了三次描述符，分别为012，都对应/dev/null #贴上整个代码吧（跟《UNIX网络编程》里代码有些出入，某些东西也懒得深究了）： #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;signal.h&gt; int main() { pid_t pid; //原代码的fork用的封装函数Fork，其实多了对fork查错 if ( (pid = fork()) &lt; 0 ) return -1; else if ( pid ) exit( 0 ); setsid(); //原代码用的封装函数Sianal，这里懒得写了 //父进程退出，会给所有子进程发一个SIGHUP信号，进程接收到此信号如果不做捕获处理默认会退出 signal( SIGHUP, SIG_IGN ); if ( (pid = fork()) &lt; 0 ) return -1; else if ( pid ) exit( 0 ); //daemon_proc = 1;//原代码有这句 chdir(&quot;/&quot;); int i = 0; for ( ; i &lt; 64; i++ ) close( i ); open(&quot;/dev/null&quot;, O_RDONLY); open(&quot;/dev/null&quot;, O_RDWR); open(&quot;/dev/null&quot;, O_RDWR); //原代码有这句，就是往syslog里写运行本程序的日志，加上进程id，输出等级为facilit(LOG_WARN这样子) //openlog(pname, LOG_PID, facility); return 0; }","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://lkness/tags/Linux/"}]},{"title":"编译60个小程序之makefile","slug":"003makefile/index","date":"2018-06-13T19:39:08.000Z","updated":"2018-06-19T02:02:56.047Z","comments":true,"path":"2018/06/14/003makefile/index/","link":"","permalink":"http://lkness/2018/06/14/003makefile/index/","excerpt":"","text":"公司有个任务需要编译60个c语言小程序，工程目录结构为： src：放所有小程序源文件.c drv：所有小程序编译后都为对应.drv 其它头文件、库目录省略。 makefile不太熟，也很菜，我第一想法是用for循环进行循环编译，还用到了makefile自定义函数，贴代码： CC = arm-linux-gcc CFLAGS +=-Wall -O -D_REENTRANT -fpic -shared LDFLAGS += -L./lib -lutility -lcrc -lmxml -lserial -lsocket -lpthread ROOT_DIR = $(shell pwd) SRC_DIR = ./src DRV_DIR = ./drv #src/*.c SRC := $(wildcard ${SRC_DIR}/*.c) SRC1 := $(notdir $(SRC)) ALL_NAME := $(basename ${SRC1}) #自定义了一个compile_file函数 define compile_file $(CC) $(CFLAGS) -o $1 $2 $(LDFLAGS) endef default: for name in $(ALL_NAME); do \\ #这里调用自定义函数，传输两个参数:一个drv/xx.drv，一个src/xx.c ${call compile_file, $(DRV_DIR)/$$name.drv, $(SRC_DIR)/$$name.c}; done clean: rm -f $(DRV_DIR)/*.drv 编译的效果是将所有的小程序都编译一遍，不管有没有出错，不管是否为最新。我需要的效果是编译所有程序，编译到哪一个出错即停止，编译前还要检查目标文件和源文件的更新时间，因此这个makefile不好用，只是学习了一下makefile的循环和自定义函数。 然后又构思makefile该如何写，就在思考的过程中想起来了学裸机程序时工程有一个.S和一个.c文件的编译，再结合makefile的伪目标，结构就很清晰了，这里用一个变量ALL_NAME表示获取到的所有src目录下的.c文件的名字替换为.drv（去除src/目录名和.c后缀，再补上drv/和.drv后缀，形式为drv/xxx.drv），代码忘了拷，贴部分自己能记住的吧： .PHONY:default clean default:$(ALL_NAME) $(DRV_DIR)/%.drv:$(SRC_DIR)/%.c $(CC) $(CFLAGS) -o $@ $&lt; $(LDFLAGS) clean: rm $(DRV_DIR)/*.drv -r 这个makefile就能满足之前的要求了。通过两个makefile的编写，学习了makefile的函数、自定义函数、循环、伪目标、makefile规则与shell规则的混合问题。","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://lkness/tags/C-C/"}]},{"title":"v4l2capture","slug":"002v4l2capture/index","date":"2018-06-13T13:38:53.000Z","updated":"2018-06-19T02:02:56.047Z","comments":true,"path":"2018/06/13/002v4l2capture/index/","link":"","permalink":"http://lkness/2018/06/13/002v4l2capture/index/","excerpt":"","text":"虽然网上很多了，还是贴一下吧，自己刚入门的时候也是找苦逼很久找代码，代码我也是总结的。 1.v4l2.cvoid get_cam_info(struct camera *cam) { if(ioctl(cam-&gt;fd, VIDIOC_QUERYCAP, &amp;cam-&gt;cap) &lt; 0) { perror(&quot;query camera information error.\\n&quot;); exit(0); } if(!(cam-&gt;cap.capabilities &amp; V4L2_CAP_VIDEO_CAPTURE)) { printf(&quot;device is not a capture device.\\n&quot;); exit(0); } printf(&quot;\\nCapability Informations:\\n&quot;); printf(&quot;Driver Name:%s\\nCard Name:%s\\nBus info:%s\\nDriver Version:%u.%u.%u\\nCapabilities: %d\\n&quot;, cam-&gt;cap.driver,cam-&gt;cap.card,cam-&gt;cap.bus_info, (cam-&gt;cap.version&gt;&gt;16)&amp;0XFF, (cam-&gt;cap.version&gt;&gt;8)&amp;0XFF,cam-&gt;cap.version&amp;0XFF, cam-&gt;cap.capabilities ); } void get_cam_fmtdesc(struct camera *cam) { cam-&gt;fmtdesc.index = 0; cam-&gt;fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; while ((ioctl(cam-&gt;fd, VIDIOC_ENUM_FMT, &amp;cam-&gt;fmtdesc)) == 0) { printf(&quot;\\t%d.\\n\\t{\\n\\tpixelformat = &apos;%c%c%c%c&apos;,\\n\\tdescription = &apos;%s&apos;\\n \\t}\\n&quot;, cam-&gt;fmtdesc.index+1, cam-&gt;fmtdesc.pixelformat &amp; 0xFF, (cam-&gt;fmtdesc.pixelformat &gt;&gt; 8) &amp; 0xFF, (cam-&gt;fmtdesc.pixelformat &gt;&gt; 16) &amp; 0xFF, (cam-&gt;fmtdesc.pixelformat &gt;&gt; 24) &amp; 0xFF, cam-&gt;fmtdesc.description); cam-&gt;fmtdesc.index++; } } void set_cap_format(struct camera *cam) { memset(&amp;cam-&gt;format, 0, sizeof(cam-&gt;format)); cam-&gt;format.fmt.pix.width = cam-&gt;width; cam-&gt;format.fmt.pix.height = cam-&gt;height; cam-&gt;format.fmt.pix.pixelformat = cam-&gt;cap_format; //cam-&gt;format.fmt.pix.field = V4L2_FIELD_INTERLACED; cam-&gt;format.fmt.pix.field = V4L2_FIELD_ANY; cam-&gt;format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; if(ioctl(cam-&gt;fd, VIDIOC_S_FMT, &amp;cam-&gt;format) &lt; 0) { perror(&quot;set capture format error.\\n&quot;); exit(0); } } void get_cap_format(struct camera *cam) { struct v4l2_format fmt; struct v4l2_fmtdesc fmtdesc; fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; if(ioctl(cam-&gt;fd, VIDIOC_G_FMT, &amp;fmt) &lt; 0) { perror(&quot;get_cap_format:error.\\n&quot;); exit(0); } printf(&quot;\\nCurrent data format information:\\n width:%d\\n height:%d\\n&quot;, fmt.fmt.pix.width,fmt.fmt.pix.height); fmtdesc.index = 0; fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; while(ioctl(cam-&gt;fd, VIDIOC_ENUM_FMT, &amp;fmtdesc) != -1) { if(fmtdesc.pixelformat == cam-&gt;format.fmt.pix.pixelformat) { printf(&quot; format:%s\\n&quot;,fmtdesc.description); break; } fmtdesc.index ++; } } void get_framerate(struct camera *cam) { int ret; memset(&amp;cam-&gt;setfps, 0, sizeof(struct v4l2_streamparm)); cam-&gt;setfps.type = V4L2_BUF_TYPE_VIDEO_CAPTURE ; cam-&gt;setfps.parm.capture.capability = V4L2_CAP_TIMEPERFRAME; ret = ioctl(cam-&gt;fd, VIDIOC_G_PARM, &amp;cam-&gt;setfps); if(ret &lt; 0) { perror(&quot;get fps error.\\n&quot;); } printf(&quot; fps:%d\\n&quot;,cam-&gt;setfps.parm.capture.timeperframe.denominator); } void set_framerate(struct camera *cam) { int ret ; memset(&amp;cam-&gt;setfps, 0, sizeof(struct v4l2_streamparm)); cam-&gt;setfps.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; cam-&gt;setfps.parm.capture.timeperframe.numerator = 1; cam-&gt;setfps.parm.capture.timeperframe.denominator = 25; ret = ioctl(cam-&gt;fd, VIDIOC_S_PARM, &amp;cam-&gt;setfps); if(ret &lt; 0) { perror(&quot;set fps error.\\n&quot;); } } void req_buffer(struct camera *cam) { memset(&amp;cam-&gt;reqbuf, 0, sizeof(cam-&gt;reqbuf)); cam-&gt;reqbuf.count = cam-&gt;buf_num; cam-&gt;reqbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; cam-&gt;reqbuf.memory = V4L2_MEMORY_MMAP; if(ioctl(cam-&gt;fd, VIDIOC_REQBUFS, &amp;cam-&gt;reqbuf) &lt; 0) { perror(&quot;reqbuf error.\\n&quot;); exit(0); } } void init_mmap(struct camera *cam) { unsigned int i; for(i=0; i&lt;cam-&gt;buf_num; i++) { //memset(&amp;cam-&gt;buf, 0, sizeof(cam-&gt;buf)); cam-&gt;buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; cam-&gt;buf.memory = V4L2_MEMORY_MMAP; cam-&gt;buf.index = i; if(-1 == ioctl(cam-&gt;fd, VIDIOC_QUERYBUF, &amp;cam-&gt;buf)) { perror(&quot;ioctl querybuf error.\\n&quot;); exit(0); } cam-&gt;buffers[i].length = cam-&gt;buf.length; cam-&gt;buffers[i].start = (unsigned char *)mmap(NULL, cam-&gt;buf.length, PROT_READ | PROT_WRITE, MAP_SHARED, cam-&gt;fd, cam-&gt;buf.m.offset); if(MAP_FAILED == cam-&gt;buffers[i].start) { perror(&quot;mmap error.\\n&quot;); exit(0); } } } void start_capture(struct camera *cam) { unsigned int i; for(i=0; i&lt;cam-&gt;buf_num; i++) { //memset(&amp;cam-&gt;buf, 0, sizeof(cam-&gt;buf)); cam-&gt;buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; cam-&gt;buf.memory = V4L2_MEMORY_MMAP; cam-&gt;buf.index = i; if(-1 == ioctl(cam-&gt;fd, VIDIOC_QBUF, &amp;cam-&gt;buf)) { perror(&quot;start capture:video ioctl qbuf error.\\n&quot;); exit(0); } } if(-1 == ioctl(cam-&gt;fd, VIDIOC_STREAMON, &amp;cam-&gt;buf.type)) { perror(&quot;start capture:video ioctl streamon error.\\n&quot;); exit(0); } } int isHaveData(int fd) { fd_set fds; struct timeval tv; int r; FD_ZERO (&amp;fds);//将指定的文件描述符集清空 FD_SET (fd, &amp;fds);//在文件描述符集合中增加一个新的文件描述符 tv.tv_sec = 2; tv.tv_usec = 0; for (;;) //这一段涉及到异步IO { r = select (fd + 1, &amp;fds, NULL, NULL, &amp;tv);//判断是否可读（即摄像头是否准备好），tv是定时 if (-1 == r) { if (EINTR == errno) { printf(&quot;select err\\n&quot;); continue; } } if (0 == r) { fprintf (stderr, &quot;select timeout：%d\\n&quot;,errno); return 0; } return 1; } } int get_one_frame_buf(struct camera * cam) { int index ; if(isHaveData(cam-&gt;fd)) { memset(&amp;cam-&gt;buf, 0, sizeof(cam-&gt;buf)); cam-&gt;buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; cam-&gt;buf.memory = V4L2_MEMORY_MMAP; if(ioctl(cam-&gt;fd, VIDIOC_DQBUF, &amp;cam-&gt;buf) &lt; 0) { perror(&quot;get one frame buffer:video ioctl dqbuf error.\\n&quot;); exit(0); } assert(cam-&gt;buf.index &lt; cam-&gt;buf_num); index = cam-&gt;buf.index; //starter = (unsigned char *)buffers[cam-&gt;buf.index].start; if(ioctl(cam-&gt;fd, VIDIOC_QBUF, &amp;cam-&gt;buf) &lt; 0) { perror(&quot;get one frame buffer:video ioctl qbuf error.\\n&quot;); exit(0); } return index; } else { printf(&quot;get one frame buffer error.\\n&quot;); exit(0); } } void stop_capture(struct camera *cam) { if(-1 == ioctl(cam-&gt;fd,VIDIOC_STREAMOFF,&amp;cam-&gt;fmtdesc.type)) { perror(&quot;stop capture error.\\n&quot;); exit(0); } close(cam-&gt;fd); printf(&quot;stop capture successfully!\\n&quot;); } void Munmap(int req_num, struct mmap_buffer *buffers) { unsigned int i; for (i = 0; i &lt; req_num; ++i) if (-1 == munmap(buffers[i].start, buffers[i].length)) free (buffers); } 2.v4l2.h这里的h4all.h包含的库函数,动手man一下吧 :-D #ifndef _V4L2_UVC_H #define _V4L2_UVC_H #include &quot;h4all.h&quot; struct mmap_buffer{ void *start; size_t length; }; typedef struct camera{ int fd; //摄像头文件描述符 int width; int height; int cap_format; int buf_num; struct v4l2_capability cap; struct v4l2_fmtdesc fmtdesc; struct v4l2_format format; struct v4l2_streamparm setfps; struct v4l2_requestbuffers reqbuf; struct v4l2_buffer buf; struct mmap_buffer buffers[4]; }Camera; void get_cam_info(struct camera *cam); void get_cam_fmtdesc(struct camera *cam); void set_cap_format(struct camera *cam); void get_cap_format(struct camera *cam); void get_framerate(struct camera *cam); void set_framerate(struct camera *cam); void req_buffer(struct camera *cam); void init_mmap(struct camera *cam); void start_capture(struct camera *cam); int get_one_frame_buf(struct camera * cam); void stop_capture(struct camera *cam); void Munmap(int req_num, struct mmap_buffer *buffers); void Init_v4l2(struct camera *cam); #endif 3.初始化：main.c#define DRIVER &quot;/dev/video2&quot; #define WIDTH 176 #define HEIGHT 144 #define CAP_FORMAT V4L2_PIX_FMT_YUYV #define REQ_BUFFER 4 Camera *cam; struct mmap_buffer buffers[REQ_BUFFER]; cam = (Camera *)malloc(sizeof(Camera)); void set_cam(Camera *cam, const char *driver_path, int width, int height, int format, int req_num) { cam-&gt;fd = Open(driver_path); cam-&gt;width = width; cam-&gt;height = height; cam-&gt;cap_format = format; cam-&gt;buf_num = req_num; } 4.获得数据调用v4l2_uvc.c的get_one_frame_buf(cam),用int型的index接收返回值，即是目前获得的底几个缓冲区的索引值，cam-&gt;buffers[index].start即是指向那段数据内存，cam-&gt;buffers[index].length即是大小 注：当然，还有什么设置伽马值、曝光度这些套路跟上面差不多，可以百度一下，作为函数补充进去","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"摄像头","slug":"摄像头","permalink":"http://lkness/tags/摄像头/"}]},{"title":"yuv422转换为yuv420p","slug":"001yuv422toyuv420p/index","date":"2018-06-12T14:25:24.000Z","updated":"2018-06-19T02:02:56.039Z","comments":true,"path":"2018/06/12/001yuv422toyuv420p/index/","link":"","permalink":"http://lkness/2018/06/12/001yuv422toyuv420p/index/","excerpt":"","text":"今天遇到一个问题，我的摄像头采集到的数据是yuyv格式(属于yuv422)，而X264在进行编码的时候需要标准的YUV（4：2：0）。所以有一个yuv422toyuv420的转换。在网上找了半天找到的方法拿过来转换了查看都很花。于是自己看了一下yuv格式的解释，准备写一个转换代码。以下许多解释都是按我的理解： 1.yuvyuv格式通常有两大类：打包(packed)和平面(planar)格式。前者在码流里是yuv挨一起，比如我的yuyv就是 Y0 U0 Y1 V1 Y2 U2 …. 每一个 Y对应一组UV分量。后者存储y u v分量是分开存储的，这种方式一般后面带P， 比如y uv420p就是Y0 Y1 Y2 … U0 U1 U2 … V0 V1 V2 … uv分量的多少根据格式来，yuv420也就是每四个 Y共用一组UV分量。 2.转换理解了yuyv即yuv422与yuv420p中分量的排布，就要进行转换了。网上查到的资料说yuv422-&gt;yuv420p时 丢弃偶数行的uv分量。 3.编码定义： unsignedchar *y = out; unsignedchar *u = out + width*height; unsigned char*v = out + width*height + width*height/4; y u v分别指向yuv420buf中存储y u v分量的数组，这里out的类型为char型数组，按yuv420p的定义，4个y共用一对uv，那么一个y对应1/4个uv，一个分量占一个byte，out的大小为：总共的y分量(widthheight) + 总共的u分量(widthheight/4) + 总共的v分量(widthheight/4) = widthheight*3/2。通过上面的转换也可以得到yuyv(yuv422)一个像素占用2个字节，yuv420p一个像素占1.5个字节，rgb24的话占用3个字节，还是节约了一点点空间的。。。 获取y分量并存储到yuv420buf中： for(i=0; i&lt;yuv422_length; i+=2){ *(y+y_index) = *(in+i); y_index++; } 这里的yuv422_length为width*height*2;y_index初始为0，存储一个y就自加一次。 获取uv分量并存储到yuv420buf中： for(i=0; i&lt;height; i+=2){ base_h = i*width*2; for(j=base_h+1;j&lt;base_h+width*2; j+=2){ if(is_u){ *(u+u_index)= *(in+j); u_index++; is_u = 0; } else{ *(v+v_index)= *(in+j); v_index++; is_u = 1; } } } 总结：初入视频图像，我还是一个菜鸟，对于很多理解也不深，这个代码应该还有很多没考虑，对于我可用了。当然以上都是废话，直接贴代码 int yuv422toyuv420(unsigned char *out, const unsigned char *in, unsigned int width, unsigned int height) { unsigned char *y = out; unsigned char *u = out + width*height; unsigned char *v = out + width*height + width*height/4; unsigned int i,j; unsigned int base_h; unsigned int is_y = 1, is_u = 1; unsigned int y_index = 0, u_index = 0, v_index = 0; unsigned long yuv422_length = 2 * width * height; //序列为YU YV YU YV，一个yuv422帧的长度 width * height * 2 个字节 //丢弃偶数行 u v for(i=0; i&lt;yuv422_length; i+=2){ *(y+y_index) = *(in+i); y_index++; } for(i=0; i&lt;height; i+=2){ base_h = i*width*2; for(j=base_h+1; j&lt;base_h+width*2; j+=2){ if(is_u){ *(u+u_index) = *(in+j); u_index++; is_u = 0; } else{ *(v+v_index) = *(in+j); v_index++; is_u = 1; } } } return 1; }","categories":[{"name":"开发","slug":"开发","permalink":"http://lkness/categories/开发/"}],"tags":[{"name":"摄像头","slug":"摄像头","permalink":"http://lkness/tags/摄像头/"}]}]}