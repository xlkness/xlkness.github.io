{"meta":{"title":"My Blog","subtitle":"我的小站","description":"学不见其长，但日有所增","author":"lkness","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-06-13T14:13:04.000Z","updated":"2018-06-19T02:02:56.175Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-06-13T14:08:29.000Z","updated":"2018-06-19T02:02:56.147Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"红黑树-《算法导论》学习笔记十二","slug":"023red-black-tree/index","date":"2018-06-19T12:38:53.000Z","updated":"2018-06-19T12:50:03.888Z","comments":true,"path":"2018/06/19/023red-black-tree/index/","link":"","permalink":"http://yoursite.com/2018/06/19/023red-black-tree/index/","excerpt":"","text":"红黑树是一种二叉搜索树，它在每个结点上增加了一个存储为来表示结点的颜色，或红或黑，通过从根到叶子的简单路径上各个结点的颜色进行约束，红黑树确保没有一条路径会比其它路径长出2倍，近似平衡的。 树种每个结点包含5个属性：color、key、left、right、parent，如果一个结点没有子结点或父结点，则该结点相应指针属性值指向空（这里的空不是空指针，而是定义一个空结点，结点颜色为黑色），一颗红黑树是满足几个特殊性质的二叉搜索树： 每个结点或是红色的，或是黑色的 根结点是黑色的 每个叶结点（亦即空结点）为黑色的 如果一个结点是红色的，则它的两个子结点都是黑色的 对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点（经过的黑色结点数为黑高） 与二叉搜索树相似，红黑树也有一些操作接口： 遍历 寻找结点中序遍历的后继:tree_minimum 寻找结点中序遍历的前驱:tree_maximum 结点左右旋转（红黑树不同于二叉搜索树的操作），用来平衡黑高 左旋：结点的父结点的左孩子指向结点的右孩子，右孩子的左孩子变为结点的右孩子，右孩子变为它的父结点 右旋：结点的父结点的右孩子指向结点的左孩子，做孩子的右孩子变为结点的左孩子，左孩子变为它的父结点* 插入，插入一个新结点时，考虑如果插入黑色结点，破坏了原树的红黑性质（黑高），要进行重新平衡 删除，删除了一个结点后，考虑如果删除的是黑色结点，或删除了结点，后继提升到删除节点的位置后，平衡红黑性质 ———-插入 如果结点的父结点为黑色，表示没插入这个结点前满足红黑树性质，且插入这个红色结点后，也不影响红黑树黑高，故保持当前位置 如果结点的父结点为红色，那么判断插入结点与父结点，以及父结点的父结点，叔结点，这四个结点是否组成一个倒立的”v”字形： (1). 如果是倒立”v”，则插入结点的父结点为红色，破坏了红黑树的：红色结点的左右孩子都为黑色的性质，故父结点一定要变为黑色;那么将父结点变为黑色; 判断叔结点若为红色，则将叔结点变为黑色，父结点的父结点变为红色，插入结点的指针指向父结点的父结点，再次从步骤1判断（因为经过变换，从插入结点的父结点的父结点开始的子数都满足红黑树性质，只需要将父结点的父结点单独当作一个新插入它的父结点的子结点再进行处理即可）; 否则叔结点为黑色，则直接将父结点的父结点变为红色，但是这样做之后，父结点因为变为黑色，而叔结点还是黑色，两个子树路径的黑高相差1,要维持黑高相等，则将父结点的父结点的父结点向叔结点相同的方向旋转（可以针对这种情况画图，会发现这样旋转后，两个黑高不一样的子树分开了，，且满足红黑树性质）。 (2). 如果不是倒立”v”，即插入结点的父结点所处子树为某方向上的子树，但插入结点又是父结点另一方的孩子结点，则只需要进行一下旋转，就将结点变为倒立的”v”形状，继续从步骤1开始作为倒立”v”子树判断。 将根结点变为黑色 ———-删除 以指针p指向待删除结点node，p_color记录node颜色 判断node的左右孩子 (1). 如果左孩子为空寻找node的右孩子，记为q（不管是否指向空）用q结点替换node结点 (2). 但如果右孩子为空寻找node的左孩子，记为q（不管是否指向空）用q结点替换node结点 (3). 否则左右孩子都不为空寻找node的中序遍历后继(tree_minimum())，p指向它; p_color记录后继的颜色; q指向p的右结点（不管是否为空）; 判断p的父结点是否为node:是，则， q的父结点设为p（只有当q为空结点时有用）/否，则，用p的右结点替换p(rb_transplant(tree, p, p-&gt;right))，用p结点接管node结点右子树（p-&gt;right = node-&gt;right, p-&gt;right-&gt;parent = p）; 用p结点替换node结点(rb_transplant(tree, node, p)); p结点接管node结点左子树(p-&gt;left = node-&gt;left,p-&gt;left-&gt;parent = p); p结点的颜色设置为node结点的颜色 判断p_color的颜色如果为黑色，表示删除结点后，黑高可能-1,要修复红黑树，从结点q处开始修复红黑树，根据q的颜色来修复 循环.直到q结点不为根结点以及p结点的颜色不为黑色 (1). 如果node的兄弟结点为红色（因为node结点替换了删除结点，黑高-1,与兄弟结点子树黑高差1）设置兄弟结点为黑色，父结点设置为红色，从父结点开始向node一侧旋转，兄弟结点成为新的子树根结点，因为兄弟结点为黑色，则经过兄弟结点到node结点的子树黑高+1,平衡，但对于兄弟结点的父结点的子树，黑高又可能不平衡，node指针指向兄弟结点，继续步骤4 (2). 如果node的兄弟结点为黑色，且兄弟结点的左右孩子均为黑色（因为node结点替换了删除结点，黑高-1,与兄弟结点子树黑高差1）设置兄弟结点颜色为红色，兄弟结点子树黑高-1,达到平衡，但父结点以上的子树可能受影响，node指针指向父结点，继续步骤4 (3). 如果node的兄弟结点为黑色，且兄弟结点的靠近node一侧的孩子结点颜色为红色，另一侧的孩子结点为黑色（因为node结点替换了删除结点，黑高-1,与兄弟结点子树黑高差1）兄弟结点靠近node一侧的孩子结点设置为黑色，兄弟结点设置为红色，从兄弟结点开始进行向远离node一侧旋转，兄弟结点的孩子结点成为它的父结点，原兄弟结点的左右子树黑高不变，但node结点所处子树因为替换删除结点，黑高-1，还是没有平衡，node指针指向新的兄弟结点的孩子结点，继续4 (4). 如果node的兄弟结点为黑色，且兄弟结点的远离node一侧的孩子结点颜色为红色，另一侧颜色未知（因为node结点替换了删除结点，黑高-1,与兄弟结点子树黑高差1）兄弟结点设置为node父结点的颜色，父结点设置为黑色，兄弟结点为红色的设置为黑色，然后从node父结点开始进行向node一侧旋转，旋转前，可以思考，父结点若为红色，旋转后不改变子树黑高，若父结点为黑色，旋转后也不会改变黑高经过一轮变换后，node结点的父结点的父结点左右子树黑高一样，且经过node替换后-1的黑高，因为变换，又+1,本子树在整个红黑树中没有破坏黑高一致性，故将node指针指向整个树的根结点，跳出循环设置node指针的结点颜色为黑色 代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;time.h&gt; //#define COLOR_RED 1; //#define COLOR_BLACK 2; typedef enum color { COLOR_RED, COLOR_BLACK }color; typedef struct rbTreeNode { int key; color color; struct rbTreeNode *parent; struct rbTreeNode *left; struct rbTreeNode *right; }rbTreeNode; typedef struct rbTree { int node_num; int height; rbTreeNode *root; rbTreeNode *null; }rbTree; void print_tree( rbTree * ); rbTreeNode *tree_minimum( rbTreeNode *root, rbTreeNode *null ) { while ( root-&gt;left != null ) { root = root-&gt;left; } return root; } rbTreeNode *tree_maximum( rbTreeNode *root, rbTreeNode *null ) { while ( root-&gt;right != null ) { root = root-&gt;right; } return root; } void left_rotate( rbTree *tree, rbTreeNode *node ) { rbTreeNode *p = node-&gt;right; node-&gt;right = p-&gt;left; if ( p-&gt;left != tree-&gt;null ) p-&gt;left-&gt;parent = node; p-&gt;parent = node-&gt;parent; if ( node-&gt;parent == tree-&gt;null ) tree-&gt;root = p; else if ( node == node-&gt;parent-&gt;left ) node-&gt;parent-&gt;left = p; else node-&gt;parent-&gt;right = p; p-&gt;left = node; node-&gt;parent = p; } void right_rotate( rbTree *tree, rbTreeNode *node ) { rbTreeNode *p = node-&gt;left; node-&gt;left = p-&gt;right; if ( p-&gt;right != tree-&gt;null ) p-&gt;right-&gt;parent = node; p-&gt;parent = node-&gt;parent; if ( node-&gt;parent == tree-&gt;null ) tree-&gt;root = p; else if ( node == node-&gt;parent-&gt;right ) node-&gt;parent-&gt;right = p; else node-&gt;parent-&gt;left = p; p-&gt;right = node; node-&gt;parent = p; } void rb_insert_fixup( rbTree *tree, rbTreeNode *node ) { rbTreeNode *p = tree-&gt;null; while ( node-&gt;parent-&gt;color == COLOR_RED ) { if ( node-&gt;parent == node-&gt;parent-&gt;parent-&gt;left ) { p = node-&gt;parent-&gt;parent-&gt;right; if ( p-&gt;color == COLOR_RED ) { node-&gt;parent-&gt;color = COLOR_BLACK; p-&gt;color = COLOR_BLACK; node-&gt;parent-&gt;parent-&gt;color = COLOR_RED; node = node-&gt;parent-&gt;parent; } else if ( node == node-&gt;parent-&gt;right ) { node = node-&gt;parent; left_rotate( tree, node ); } else { node-&gt;parent-&gt;color = COLOR_BLACK; node-&gt;parent-&gt;parent-&gt;color = COLOR_RED; right_rotate( tree, node-&gt;parent-&gt;parent ); } } else { p = node-&gt;parent-&gt;parent-&gt;left; if ( p-&gt;color == COLOR_RED ) { node-&gt;parent-&gt;color = COLOR_BLACK; p-&gt;color = COLOR_BLACK; node-&gt;parent-&gt;parent-&gt;color = COLOR_RED; node = node-&gt;parent-&gt;parent; } else if ( node == node-&gt;parent-&gt;left ) { node = node-&gt;parent; right_rotate( tree, node ); } else { node-&gt;parent-&gt;color = COLOR_BLACK; node-&gt;parent-&gt;parent-&gt;color = COLOR_RED; left_rotate( tree, node-&gt;parent-&gt;parent ); } } } tree-&gt;root-&gt;color = COLOR_BLACK; } void rb_insert( rbTree *tree, rbTreeNode *node ) { rbTreeNode *p = tree-&gt;null; rbTreeNode *q = tree-&gt;root; while ( q != tree-&gt;null ) { p = q; if ( node-&gt;key &lt; q-&gt;key ) q = q-&gt;left; else q = q-&gt;right; } node-&gt;parent = p; if ( p == tree-&gt;null ) tree-&gt;root = node; else if ( node-&gt;key &lt; p-&gt;key ) p-&gt;left = node; else p-&gt;right = node; node-&gt;left = tree-&gt;null; node-&gt;right = tree-&gt;null; node-&gt;color = COLOR_RED; rb_insert_fixup( tree, node ); } void rb_transplant( rbTree *tree, rbTreeNode *node_a, rbTreeNode *node_b ) { if ( node_a-&gt;parent == tree-&gt;null ) tree-&gt;root = node_b; else if ( node_a == node_a-&gt;parent-&gt;left ) node_a-&gt;parent-&gt;left = node_b; else node_a-&gt;parent-&gt;right = node_b; node_b-&gt;parent = node_a-&gt;parent; free( node_a ); } void rb_delete_fixup( rbTree *tree, rbTreeNode *node ) { rbTreeNode *p = tree-&gt;null; while ( node != tree-&gt;null &amp;&amp; node-&gt;color == COLOR_BLACK ) { if ( node == node-&gt;parent-&gt;left ) { p = node-&gt;parent-&gt;right; if ( p-&gt;color == COLOR_RED ) { p-&gt;color = COLOR_BLACK; node-&gt;parent-&gt;color = COLOR_RED; left_rotate( tree, node-&gt;parent ); p = node-&gt;parent-&gt;right; } else if ( p-&gt;left-&gt;color == COLOR_BLACK &amp;&amp; p-&gt;right-&gt;color == COLOR_BLACK ) { p-&gt;color = COLOR_RED; node = node-&gt;parent; } else if ( p-&gt;right-&gt;color == COLOR_BLACK ) { p-&gt;left-&gt;color = COLOR_BLACK; p-&gt;color = COLOR_RED; right_rotate( tree, p ); p = node-&gt;parent-&gt;right; } else { p-&gt;color = node-&gt;parent-&gt;color; node-&gt;parent-&gt;color = COLOR_BLACK; left_rotate( tree, node-&gt;parent ); node = tree-&gt;root; } } else { p = node-&gt;parent-&gt;left; if ( p-&gt;color == COLOR_RED ) { p-&gt;color = COLOR_BLACK; node-&gt;parent-&gt;color = COLOR_RED; right_rotate( tree, node-&gt;parent ); p = node-&gt;parent-&gt;left; } else if ( p-&gt;left-&gt;color == COLOR_BLACK &amp;&amp; p-&gt;right-&gt;color == COLOR_BLACK ) { p-&gt;color = COLOR_RED; node = node-&gt;parent; } else if ( p-&gt;left-&gt;color == COLOR_BLACK ) { p-&gt;right-&gt;color = COLOR_BLACK; p-&gt;color = COLOR_RED; left_rotate( tree, p ); p = node-&gt;parent-&gt;left; } else { p-&gt;color = node-&gt;parent-&gt;color; node-&gt;parent-&gt;color = COLOR_BLACK; right_rotate( tree, node-&gt;parent ); node = tree-&gt;root; } } } node-&gt;color = COLOR_BLACK; } void rb_delete( rbTree *tree, rbTreeNode *node ) { rbTreeNode *p = node; rbTreeNode *q = tree-&gt;null; color origin_color = p-&gt;color; if ( node-&gt;left == tree-&gt;null ) { q = node-&gt;right; rb_transplant( tree, node, node-&gt;right ); } else if ( node-&gt;right == tree-&gt;null ) { q = node-&gt;left; rb_transplant( tree, node, node-&gt;left ); } else { p = tree_minimum( node-&gt;right, tree-&gt;null ); origin_color = p-&gt;color; q = p-&gt;right; if ( p-&gt;parent == node ) q-&gt;parent = p; else { rb_transplant( tree, p, p-&gt;right ); p-&gt;right = node-&gt;right; p-&gt;right-&gt;parent = p; } rb_transplant( tree, node, p ); p-&gt;left = node-&gt;left; p-&gt;left-&gt;parent = p; p-&gt;color = node-&gt;color; } if ( origin_color == COLOR_BLACK ) rb_delete_fixup( tree, q ); } int random_num() { int a = 1; int b = 100; return rand() % ( b - a ) + a; } void postorder_tree_free( rbTreeNode *root, rbTreeNode *null ) { if ( root != null ) { postorder_tree_free( root-&gt;left, null ); postorder_tree_free( root-&gt;right, null ); free( root ); } } void inorder_tree_walk( rbTreeNode *root, rbTreeNode *null ) { if ( root != null ) { inorder_tree_walk( root-&gt;left, null ); printf(&quot;%d(%d) &quot;, root-&gt;key, root-&gt;color); inorder_tree_walk( root-&gt;right, null ); } } void preorder_tree_walk( rbTreeNode *root, rbTreeNode *null ) { if ( root != null ) { printf(&quot;%d(%d) &quot;, root-&gt;key, root-&gt;color); preorder_tree_walk( root-&gt;left, null ); preorder_tree_walk( root-&gt;right, null ); } } void postorder_tree_walk( rbTreeNode *root, rbTreeNode *null ) { if ( root != null ) { postorder_tree_walk( root-&gt;left, null ); postorder_tree_walk( root-&gt;right, null ); printf(&quot;%d(%d) &quot;, root-&gt;key, root-&gt;color); } } void print_tree( rbTree *tree ) { printf(&quot;中序:&quot;); inorder_tree_walk( tree-&gt;root, tree-&gt;null ); printf(&quot;\\n&quot;); printf(&quot;前序:&quot;); preorder_tree_walk( tree-&gt;root, tree-&gt;null ); printf(&quot;\\n&quot;); printf(&quot;后序:&quot;); postorder_tree_walk( tree-&gt;root, tree-&gt;null ); printf(&quot;\\n\\n&quot;); } rbTreeNode *tree_search_recursion( rbTreeNode *root, int key, rbTreeNode *null) { if ( root == null || key == root-&gt;key ) { return root; } if ( key &lt; root-&gt;key ) return tree_search_recursion( root-&gt;left, key, null ); else return tree_search_recursion( root-&gt;right, key, null ); } rbTreeNode *tree_search( rbTreeNode *root, int key, rbTreeNode *null ) { while ( root != null &amp;&amp; key != root-&gt;key ) { if ( key &lt; root-&gt;key ) root = root-&gt;left; else root = root-&gt;right; } return root; } // 找前驱 即中序遍历的前一个位置值 rbTreeNode *tree_predecessor( rbTreeNode *node, rbTreeNode *null ) { if ( node-&gt;left != null ) return tree_maximum( node-&gt;left, null ); rbTreeNode *p = node-&gt;parent; while ( p != null &amp;&amp; node == p-&gt;left ) { node = p; p = p-&gt;parent; } return p; } // 找后继 即中序遍历的后一个位置值 rbTreeNode *tree_successor( rbTreeNode *node, rbTreeNode *null ) { if ( node-&gt;right != null ) return tree_minimum( node-&gt;right, null ); rbTreeNode *p = node-&gt;parent; while ( p != null &amp;&amp; node == p-&gt;right ) { node = p; p = p-&gt;parent; } return p; } void free_tree( rbTree *tree ) { rbTreeNode *root = tree-&gt;root; postorder_tree_free( root, tree-&gt;null ); free( tree ); } int main( int argc, char **argv ) { srand((int)time(NULL)); int i = 10; int len = 10; int arr[10] = {10,4,15,14,5, 2,8,13,1,19}; rbTree *tree = ( rbTree * )malloc( sizeof(rbTree) ); tree-&gt;node_num = 0; tree-&gt;height = 0; tree-&gt;null = ( rbTreeNode * )malloc( sizeof(rbTreeNode) ); tree-&gt;null-&gt;color = COLOR_BLACK; tree-&gt;root = tree-&gt;null; for ( i = 0; i &lt; len; i++ ) { rbTreeNode *node = ( rbTreeNode * )malloc( sizeof(rbTreeNode) ); //node-&gt;key = random_num(); node-&gt;key = arr[i]; node-&gt;parent = tree-&gt;null; node-&gt;left = tree-&gt;null; node-&gt;right = tree-&gt;null; rb_insert( tree, node ); printf(&quot;insert %d successfully\\n&quot;, arr[i]); } print_tree( tree ); rbTreeNode *delete_node = tree_search( tree-&gt;root, 4, tree-&gt;null ); if ( delete_node != tree-&gt;null ) { rb_delete( tree, delete_node ); } printf(&quot;\\n删除%d的节点后遍历顺序为:\\n&quot;, 4); print_tree( tree ); printf(&quot;\\n&quot;); delete_node = tree_search( tree-&gt;root, 15, tree-&gt;null ); if ( delete_node != tree-&gt;null ) { rb_delete( tree, delete_node ); } printf(&quot;\\n删除%d的节点后中序遍历顺序为:\\n&quot;, 15); print_tree( tree ); printf(&quot;\\n&quot;); free_tree( tree ); return 0; }","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://yoursite.com/tags/数据结构-算法/"}]},{"title":"二叉搜索树-《算法导论》学习笔记十一","slug":"022bin-search-tree/index","date":"2018-06-19T12:36:13.000Z","updated":"2018-06-19T12:38:27.885Z","comments":true,"path":"2018/06/19/022bin-search-tree/index/","link":"","permalink":"http://yoursite.com/2018/06/19/022bin-search-tree/index/","excerpt":"","text":"二叉搜索树是以一颗二叉树来组织的，每个节点除数据外，还包括三个分别指向父结点、左孩子、右孩子的指针，二叉搜索树有个特性：某个结点root的左子树的某个节点x的关键值小于等于root结点右子树某个结点y的关键值。 二叉搜索树有几个操作： 1、查找 查找与给定关键值相等的结点 2、遍历 前序、中序、后序遍历输出 3、从某结点出发，寻找子树中最小关键值的结点 4、从某结点出发，寻找子树中最大关键值的结点 5、以某种遍历方式的次数，寻找某结点的前驱结点和后继结点 例如中序遍历的顺序为123456，则4结点的前驱为3，后继为5 6、插入结点 7、删除结点 删除某个结点后，要把它的后继结点补在删除的位置上，要注意： 如果结点没有孩子结点，那么只是简单地将它删除，并删改它的父结点的孩子指针指向它 如果结点只有一个孩子，那么将它孩子提升到它的位置，并修改它的父结点的孩子指针指向它 如果节点有两个孩子，那么寻找它的后继（按中序遍历来说一定在右子树），并让后继占据它的位置，后继（按中序遍历来说一定没有左子树）的子树提升到后继的位置 情况如上，具体删除时如何替换，又有不同情况： 如果结点只有左或孩子，用孩子替换结点 如果结点有左右两个孩子，那么要查找结点的后继：(1)、如果后继是结点的右孩子，用后继替换结点，并留下后继的右孩子；(2)、后继位于结点的右子树，但并不是结点的右孩子，则，先用后继的右孩子替换后继，再用后继替换结点 代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;time.h&gt; typedef struct biSearchTreeNode { int key; struct biSearchTreeNode *parent; struct biSearchTreeNode *left; struct biSearchTreeNode *right; }biSearchTreeNode; typedef struct biSearchTree { int node_num; int height; biSearchTreeNode *root; }biSearchTree; int random_num() { int a = 1; int b = 100; return rand() % ( b - a ) + a; } void postorder_tree_free( biSearchTreeNode *root ) { if ( root != NULL ) { postorder_tree_free( root-&gt;left ); postorder_tree_free( root-&gt;right ); free( root ); } } void inorder_tree_walk( biSearchTreeNode *root ) { if ( root != NULL ) { inorder_tree_walk( root-&gt;left ); printf(&quot;%d &quot;, root-&gt;key); inorder_tree_walk( root-&gt;right ); } } void preorder_tree_walk( biSearchTreeNode *root ) { if ( root != NULL ) { printf(&quot;%d &quot;, root-&gt;key); preorder_tree_walk( root-&gt;left ); preorder_tree_walk( root-&gt;right ); } } void postorder_tree_walk( biSearchTreeNode *root ) { if ( root != NULL ) { postorder_tree_walk( root-&gt;left ); postorder_tree_walk( root-&gt;right ); printf(&quot;%d &quot;, root-&gt;key); } } void print_tree( biSearchTree *tree ) { printf(&quot;中序:&quot;); inorder_tree_walk( tree-&gt;root ); printf(&quot;\\n&quot;); printf(&quot;前序:&quot;); preorder_tree_walk( tree-&gt;root ); printf(&quot;\\n&quot;); printf(&quot;后序:&quot;); postorder_tree_walk( tree-&gt;root ); printf(&quot;\\n\\n&quot;); } biSearchTreeNode *tree_search_recursion( biSearchTreeNode *root, int key ) { if ( root == NULL || key == root-&gt;key ) { return root; } if ( key &lt; root-&gt;key ) return tree_search_recursion( root-&gt;left, key ); else return tree_search_recursion( root-&gt;right, key ); } biSearchTreeNode *tree_search( biSearchTreeNode *root, int key ) { while ( root != NULL &amp;&amp; key != root-&gt;key ) { if ( key &lt; root-&gt;key ) root = root-&gt;left; else root = root-&gt;right; } return root; } biSearchTreeNode *tree_minimum( biSearchTreeNode *root ) { while ( root-&gt;left != NULL ) { root = root-&gt;left; } return root; } biSearchTreeNode *tree_maximum( biSearchTreeNode *root ) { while ( root-&gt;right != NULL ) { root = root-&gt;right; } return root; } // 找前驱 即中序遍历的前一个位置值 biSearchTreeNode *tree_predecessor( biSearchTreeNode *node ) { if ( node-&gt;left != NULL ) return tree_maximum( node-&gt;left ); biSearchTreeNode *p = node-&gt;parent; while ( p != NULL &amp;&amp; node == p-&gt;left ) { node = p; p = p-&gt;parent; } return p; } // 找后继 即中序遍历的后一个位置值 biSearchTreeNode *tree_successor( biSearchTreeNode *node ) { if ( node-&gt;right != NULL ) return tree_minimum( node-&gt;right ); biSearchTreeNode *p = node-&gt;parent; while ( p != NULL &amp;&amp; node == p-&gt;right ) { node = p; p = p-&gt;parent; } return p; } void tree_insert( biSearchTree *tree, biSearchTreeNode *node ) { biSearchTreeNode *root = tree-&gt;root; biSearchTreeNode *p = NULL; biSearchTreeNode *q = root; while ( q != NULL ) { p = q; if ( node-&gt;key &lt; q-&gt;key ) q = q-&gt;left; else q = q-&gt;right; } node-&gt;parent = p; if ( p == NULL ) { tree-&gt;root = node; } else if ( node-&gt;key &lt; p-&gt;key ) p-&gt;left = node; else p-&gt;right = node; } void transplant( biSearchTree *tree, biSearchTreeNode *node_a, biSearchTreeNode *node_b ) { if ( node_a-&gt;parent == NULL ) tree-&gt;root = node_b; else if ( node_a == node_a-&gt;parent-&gt;left ) node_a-&gt;parent-&gt;left = node_b; else node_a-&gt;parent-&gt;right = node_b; if ( node_b != NULL ) node_b-&gt;parent = node_a-&gt;parent; } void tree_delete( biSearchTree *tree, biSearchTreeNode *node ) { if ( node-&gt;left == NULL ) transplant( tree, node, node-&gt;right ); else if ( node-&gt;right == NULL ) transplant( tree, node, node-&gt;left ); else { biSearchTreeNode *p = tree_minimum( node-&gt;right ); if ( p-&gt;parent != node ) { transplant( tree, p, p-&gt;right ); p-&gt;right = node-&gt;right; p-&gt;right-&gt;parent = p; } transplant( tree, node, p ); p-&gt;left = node-&gt;left; p-&gt;left-&gt;parent = p; } free( node ); } void free_tree( biSearchTree *tree ) { biSearchTreeNode *root = tree-&gt;root; postorder_tree_free( root ); free( tree ); } int main( int argc, char **argv ) { srand((int)time(NULL)); int i = 10; int len = 10; int arr[10] = {10,4,15,14,5, 2,8,13,1,19}; biSearchTree *tree = ( biSearchTree * )malloc( sizeof(biSearchTree) ); tree-&gt;node_num = 0; tree-&gt;height = 0; for ( i = 0; i &lt; len; i++ ) { biSearchTreeNode *node = ( biSearchTreeNode * )malloc( sizeof(biSearchTreeNode) ); //node-&gt;key = random_num(); node-&gt;key = arr[i]; node-&gt;parent = NULL; node-&gt;left = NULL; node-&gt;right = NULL; tree_insert( tree, node ); } print_tree( tree ); for ( i = 0; i &lt; len; i++ ) { biSearchTreeNode *pre = tree_predecessor( tree_search(tree-&gt;root, arr[i]) ); biSearchTreeNode *post = tree_successor( tree_search(tree-&gt;root, arr[i]) ); printf(&quot;\\n&quot;); if ( pre != NULL ) printf(&quot;查找%d的中序遍历前驱为:%d\\n&quot;, arr[i], pre-&gt;key); else printf(&quot;查找%d的中序遍历前驱为空！\\n&quot;, arr[i]); if ( post != NULL ) printf(&quot;查找%d的中序遍历后继为:%d\\n&quot;, arr[i], post-&gt;key); else printf(&quot;查找%d的中序遍历后继为空！\\n&quot;, arr[i]); } biSearchTreeNode *delete_node = tree_search( tree-&gt;root, 4 ); if ( delete_node != NULL ) { tree_delete( tree, delete_node ); } printf(&quot;\\n删除%d的节点后中序遍历顺序为:&quot;, 4); inorder_tree_walk( tree-&gt;root ); printf(&quot;\\n&quot;); delete_node = tree_search( tree-&gt;root, 15 ); if ( delete_node != NULL ) { tree_delete( tree, delete_node ); } printf(&quot;\\n删除%d的节点后中序遍历顺序为:&quot;, 15); inorder_tree_walk( tree-&gt;root ); printf(&quot;\\n&quot;); free_tree( tree ); return 0; }","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://yoursite.com/tags/数据结构-算法/"}]},{"title":"查找数组第i小的数-《算法导论》学习笔记十","slug":"021search-min-i/index","date":"2018-06-19T12:32:13.000Z","updated":"2018-06-19T12:35:17.286Z","comments":true,"path":"2018/06/19/021search-min-i/index/","link":"","permalink":"http://yoursite.com/2018/06/19/021search-min-i/index/","excerpt":"","text":"查找第i小的数利用了快速排序的一点思想，即以数组某个值作为比较值，然后遍历数组中除这个数以外的数，小于它的就放左边，大于它的放右边，然后作为比较值的数放中间，并返回比较值的下标，如果下标等于i，表示就找到了，如果下标大于i，又再次从大于此下标的数组递归进行此过程，同理，小于i就从小于此下标的数组递归进行此过程，代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int partition( int *arr, int p, int r ) { int x = arr[r]; int i = p - 1; int j = 0; int temp = 0; for ( j = p; j &lt; r; j++ ) { if ( arr[j] &lt;= x ) { i += 1; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } temp = arr[i + 1]; arr[i + 1] = arr[r]; arr[r] = temp; return i + 1; } int randomized_partition( int *arr, int p, int r ) { int i = rand() % (r - p) + p; int temp = arr[r]; arr[r] = arr[i]; arr[i] = temp; return partition( arr, p, r ); } int randomized_select( int *arr, int p, int r, int i ) { if ( p == r ) return arr[p]; int q = 0, k = 0; q = randomized_partition( arr, p, r ); k = q - p + 1; if ( i == k ) return arr[q]; else if ( i &lt; k ) return randomized_select( arr, p, q - 1, i ); else return randomized_select( arr, q + 1, r, i - k ); } int main() { int arr[10] = {1,2,3,4,5,6,7,8,9,10}; int len = 10; int i = 8; printf(&quot;第%d小的数是:%d\\n&quot;, i, randomized_select(arr, 0, 9, i)); return 0; }","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://yoursite.com/tags/数据结构-算法/"}]},{"title":"桶排序-《算法导论》学习笔记九","slug":"020bucket-sort/index","date":"2018-06-19T12:28:14.000Z","updated":"2018-06-19T12:29:00.827Z","comments":true,"path":"2018/06/19/020bucket-sort/index/","link":"","permalink":"http://yoursite.com/2018/06/19/020bucket-sort/index/","excerpt":"","text":"桶排序要求数据均匀、独立分布在某个区间上，然后将待排序值按某个区间划分为几个区间数组，然后将待排序的数按这个区间划分公式有序放入对应桶中，这样放完之后再按顺序从桶中拿出来一个一个放入原数组。c代码桶可以用链表，如待排序数组的值为0-99，那么桶可以划分为0-9、10-19、20-29…..，这样就得到了10个桶数组链表，然后遍历待排序的数组，将值/10后以链表插入排序方式放入对应桶链表中（就像打扑克一样从前往后遍历，能插入就插入），待所有数遍历完后，就得到了桶数据了，然后再排序0-9的桶，每个桶做链表遍历取数据，直接从数组0开始插入到待排序数组，代码： #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt; //#define DEBUG typedef struct bucket_data { int no; struct bucket_data *next; } bucket_data; void sort_insert( bucket_data *, int ); void bucket_sort( int *arr, int len ) { bucket_data *tmp_arr = ( bucket_data * )malloc( sizeof(bucket_data) * 10 ); int i = 0, count = 0; //初始化链表头数组 for ( i = 0; i &lt; 10; i++ ) { tmp_arr[i].next = NULL; } //遍历数据并有序插入到相应链表中 for ( i = 0; i &lt; len; i++ ) { sort_insert( &amp;tmp_arr[arr[i] / 10], arr[i] ); } //从链表中取数据到数组 count = 0; for ( i = 0; i &lt; 10; i++ ) { bucket_data *p = tmp_arr[i].next; bucket_data *free_p = NULL; #ifdef DEBUG printf(&quot;bucket[%d]:\\n&quot;, i); #endif while( p != NULL ) { #ifdef DEBUG printf(&quot;%d &quot;, p-&gt;no); #endif free_p = p; arr[count] = p-&gt;no; count++; p = p-&gt;next; free( free_p ); } #ifdef DEBUG printf(&quot;\\n&quot;); #endif } free( tmp_arr ); } void sort_insert( bucket_data *head, int no ) { bucket_data *p = head; bucket_data *data = ( bucket_data * )malloc( sizeof(bucket_data) ); data-&gt;no = no; data-&gt;next = NULL; while ( p != NULL &amp;&amp; p-&gt;next != NULL ) { if ( p-&gt;next-&gt;no &gt;= no ) { data-&gt;next = p-&gt;next; p-&gt;next = data; break; } p = p-&gt;next; } if ( p-&gt;next == NULL ) { p-&gt;next = data; } } void check_is_inc_arr( int *arr, int len ) { int i = 0; for ( i = 0; i &lt; len; i++ ) { if ( arr[i] &lt; arr[i - 1] ) { printf(&quot;check_is_inc_arr fail.\\n&quot;); return; } } } //初始化随机数组 void initArr( int *arr, int lowV, int upV, int len ) { int i = 0; int size = upV - lowV; for ( i = 0; i &lt; len; i++ ) { arr[i] = rand() % size + lowV; } } void print_arr( int *arr, int len ) { int i = 0; printf(&quot;\\n=============================================\\n&quot;); for ( i = 0; i &lt; len; i++ ) { printf(&quot;%d &quot;, arr[i]); } printf(&quot;\\n=============================================\\n&quot;); } int main( int argc, char **argv ) { if ( argc != 4 ) { printf(&quot;input array length and the random value range.\\n&quot;); exit( 0 ); } srand( (int)time(NULL) ); int length = atoi( argv[1] ); int lowV = atoi( argv[2] ); int upV = atoi( argv[3] ); int *arr = ( int * )malloc( sizeof(int) * (length) ); int i = 1000; for ( ; i &gt; 0; i-- ) { initArr( arr, lowV, upV, length ); //print_arr( arr, length ); bucket_sort( arr, length ); //print_arr( arr, length ); check_is_inc_arr( arr, length ); } return 0; }","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://yoursite.com/tags/数据结构-算法/"}]},{"title":"计数排序-《算法导论》学习笔记八","slug":"019count-sort/index","date":"2018-06-19T12:27:08.000Z","updated":"2018-06-19T12:27:51.135Z","comments":true,"path":"2018/06/19/019count-sort/index/","link":"","permalink":"http://yoursite.com/2018/06/19/019count-sort/index/","excerpt":"","text":"计数排序：假设n个输入元素中的每一个都是在0-k区间内的一个整数(k为正整数)，对每一个输入元素x，确定小于x的元素个数，用一个0-k长度的数组做记录，例如输入数组的数为0-10长度，随机出[2,5,3,0,2,3,0,3]，可以计算出一个0-10的数组，分别表示小于等于x的数的个数，于是有：0-&gt;2,1-&gt;2,2-&gt;4,3-&gt;7,4-&gt;7,5-&gt;8,6-&gt;8,7-&gt;8,9-&gt;8,10-&gt;8，然后再倒序遍历待排序数组，根据值去0-10数组取索引，然后将数组值放入一个新的等长数组那个索引处，取过的索引值要减一，这是为了下次再取到相同值不会放在同一位置，代码： #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt; void counting_sort( int *in_arr, int *out_arr, int arr_len, int k ) { int *tmp_arr = ( int * )malloc( sizeof(int) * (k + 1) ); int i = 0, j = 0; for ( i = 0; i &lt; k; i++ ) { tmp_arr[i] = 0; } for ( j = 0; j &lt; arr_len; j++ ) { tmp_arr[in_arr[j]] = tmp_arr[in_arr[j]] + 1; } for ( i = 1; i &lt; k + 1; i++ ) { tmp_arr[i] = tmp_arr[i] + tmp_arr[i - 1]; } for ( j = arr_len - 1; j &gt;= 0; j-- ) { //printf(&quot;j:%d, in_arr[j]:%d, tmp_arr[in_arr[j]]:%d\\n&quot;, // j, in_arr[j], tmp_arr[in_arr[j]]); out_arr[tmp_arr[in_arr[j]] - 1] = in_arr[j]; tmp_arr[in_arr[j]] = tmp_arr[in_arr[j]] - 1; } free( tmp_arr ); } void check_is_inc_arr( int *arr, int len ) { int i = 0; for ( i = 0; i &lt; len; i++ ) { if ( arr[i] &lt; arr[i - 1] ) { printf(&quot;check_is_inc_arr fail.\\n&quot;); return; } } } //初始化随机数组 void initArr( int *arr, int lowV, int upV, int len ) { int i = 0; int size = upV - lowV; for ( i = 0; i &lt; len; i++ ) { arr[i] = rand() % size + lowV; } } void print_arr( int *arr, int len ) { int i = 0; printf(&quot;\\n=============================================\\n&quot;); for ( i = 0; i &lt; len; i++ ) { printf(&quot;%d &quot;, arr[i]); } printf(&quot;\\n=============================================\\n&quot;); } int main( int argc, char **argv ) { if ( argc != 4 ) { printf(&quot;input array length and the random value range.\\n&quot;); exit( 0 ); } srand( (int)time(NULL) ); int length = atoi( argv[1] ); int lowV = atoi( argv[2] ); int upV = atoi( argv[3] ); int *arr = ( int * )malloc( sizeof(int) * (length) ); int *new_arr = ( int * )malloc( sizeof(int) * length ); int i = 1000; for ( ; i &gt; 0; i-- ) { initArr( arr, lowV, upV, length ); //print_arr( arr, length ); counting_sort( arr, new_arr, length, upV ); //print_arr( new_arr, length ); check_is_inc_arr( new_arr, length ); } return 0; }","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://yoursite.com/tags/数据结构-算法/"}]},{"title":"快速排序-《算法导论》学习笔记七","slug":"018quick-sort/index","date":"2018-06-19T12:24:39.000Z","updated":"2018-06-19T12:26:47.543Z","comments":true,"path":"2018/06/19/018quick-sort/index/","link":"","permalink":"http://yoursite.com/2018/06/19/018quick-sort/index/","excerpt":"","text":"快排利用分治的思想，将问题规模切分为小的子规模问题，类似归并排序，归并是将两个待排序的子数组合并为一个有序的数组，而快排是将数组以某个数组值划分为两个子数组，一个数组的所有数比这个值小，一个数组的所有数比这个值大，然后再递归地对两个子数组再以某个数组值做切分和交换： #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt; int partition( int *arr, int p, int r ) { int x = arr[r]; int i = p - 1; int j = 0; int temp = 0; for ( j = p; j &lt; r; j++ ) { if ( arr[j] &lt;= x ) { i += 1; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } temp = arr[i + 1]; arr[i + 1] = arr[r]; arr[r] = temp; return i + 1; } void quick_sort( int *arr, int p, int r ) { int q = 0; if ( p &lt; r ) { q = partition( arr, p, r ); //printf(&quot;p-&gt;%d, q-&gt;%d, r-&gt;%d\\n&quot;, p, q, r); quick_sort( arr, p, q - 1 ); quick_sort( arr, q + 1, r ); } } void check_is_inc_arr( int *arr, int len ) { int i = 0; for ( i = 0; i &lt; len; i++ ) { if ( arr[i] &lt; arr[i - 1] ) { printf(&quot;check_is_inc_arr fail.\\n&quot;); return; } } } //初始化随机数组 void initArr( int *arr, int lowV, int upV, int len ) { int i = 0; int size = upV - lowV; for ( i = 0; i &lt; len; i++ ) { arr[i] = rand() % size + lowV; } } void print_arr( int *arr, int len ) { int i = 0; printf(&quot;\\n=============================================\\n&quot;); for ( i = 0; i &lt; len; i++ ) { printf(&quot;%d &quot;, arr[i]); } printf(&quot;\\n=============================================\\n&quot;); } int main( int argc, char **argv ) { if ( argc != 4 ) { printf(&quot;input array length and the random value range.\\n&quot;); exit( 0 ); } srand( (int)time(NULL) ); int length = atoi( argv[1] ); int lowV = atoi( argv[2] ); int upV = atoi( argv[3] ); int *arr = ( int * )malloc( sizeof(int) * (length) ); initArr( arr, lowV, upV, length ); print_arr( arr, length ); quick_sort( arr, 0, length - 1 ); print_arr( arr, length ); check_is_inc_arr( arr, length ); return 0; }","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://yoursite.com/tags/数据结构-算法/"}]},{"title":"erlang的终端带颜色输出与中文字符串输出","slug":"017erlang-shell-color/index","date":"2018-06-19T12:19:59.000Z","updated":"2018-06-19T12:21:25.453Z","comments":true,"path":"2018/06/19/017erlang-shell-color/index/","link":"","permalink":"http://yoursite.com/2018/06/19/017erlang-shell-color/index/","excerpt":"","text":"1.带颜色输出erlang终端支持带颜色输出，例如lager日志库就可以。其实就是在输出前设置一下输出属性，正常的字体是：”\\e[0;38m”下面自己弄了一些宏： -define(CONSOLE_COLOR_RED, &quot;\\e[0;31m&quot;). -define(CONSOLE_COLOR_RED_BOLD, &quot;\\e[1;31m&quot;). -define(CONSOLE_COLOR_YELLOW1, &quot;\\e[0;32m&quot;). -define(CONSOLE_COLOR_YELLOW2, &quot;\\e[0;33m&quot;). -define(CONSOLE_COLOR_BLUE, &quot;\\e[0;34m&quot;). -define(CONSOLE_COLOR_PURPLE, &quot;\\e[0;35m&quot;). -define(CONSOLE_COLOR_GREEN, &quot;\\e[0;36m&quot;). -define(CONSOLE_COLOR_GRAY, &quot;\\e[0;37m&quot;). -define(CONSOLE_COLOR_NORMAL, &quot;\\e[0;38m&quot;). 用法就是打印的字符串前后加上要设置的属性例如io:format(“~s~s~s~n”, [“\\e[0;31m”, debug, “\\e[0;38m”]).就是在输出debug之前设置字体为红色，然后输出结束后设置字体为正常白色。 2.中文输出中文输出乱码在rebar3插件里用rebar_info输出以及在ct里用io:format(user, ….)输出会遇到，带中文的字符串要转为utf8，代码形如： NewFormat = io_lib:format(Format, Args), io:format(&quot;~s&quot;, [unicode:characters_to_binary(NewFormat, utf8)]).","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"Erlang","slug":"Erlang","permalink":"http://yoursite.com/tags/Erlang/"}]},{"title":"堆排序-《算法导论》学习笔记六","slug":"016heap-sort/index","date":"2018-06-19T12:18:42.000Z","updated":"2018-06-19T12:19:36.767Z","comments":true,"path":"2018/06/19/016heap-sort/index/","link":"","permalink":"http://yoursite.com/2018/06/19/016heap-sort/index/","excerpt":"","text":"堆排序就是将一组数按二叉树层序遍历的存储顺序，经过一系列比较转移，最终变成有序的数组，这里的二叉树堆一定是完全二叉树。堆排序能进行的基础是有个最大堆的数组，最大堆性质是指树上的每个节点的子节点都比自己小或等于。因此最顶上的根节点一定是值最大的节点，有了最大堆在，堆排序就可以进行了，从层序遍历的最后一个节点开始倒序循环，交换当前节点与最顶层根节点，即最大值的节点，这样每次最大的节点都被放在层序遍历的最后位置，类似冒泡排序了，而放了最大值的节点即从堆中排除（只要堆长度减一即表示堆没有这个节点了），交换到顶点根节点的值再做一次下滤操作（以这个节点值与子树的最大值交换），保证剩余子树一定也是最大堆性质。贴代码： #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt; int parent( int ); int left( int ); int right( int ); inline int parent( int index ) { return index / 2; } inline int left( int index ) { return index * 2; } inline int right( int index ) { return index * 2 + 1; } //下滤 void max_heapify( int *arr, int heap_size, int index ) { int l = left( index ); int r = right( index ); int largest = 0; if ( l &lt;= heap_size &amp;&amp; arr[l] &gt; arr[index] ) { largest = l; } else { largest = index; } if ( r &lt;= heap_size &amp;&amp; arr[r] &gt; arr[largest] ) { largest = r; } if ( largest != index ) { int temp = arr[index]; arr[index] = arr[largest]; arr[largest] = temp; max_heapify( arr, heap_size, largest ); } } //构建最大堆 void build_max_heap( int *arr, int length, int heap_size ) { int i = 0; for ( i = length / 2; i &gt;= 1; i-- ) { max_heapify( arr, heap_size, i ); } } //开始堆排序 void heap_sort( int *arr, int length, int heap_size ) { int i = 0; build_max_heap( arr, length, heap_size ); for ( i = heap_size; i &gt;= 2; i-- ) { int temp = arr[1]; arr[1] = arr[i]; arr[i] = temp; heap_size -= 1; max_heapify( arr, heap_size, 1 ); } } void check_is_inc_arr( int *arr, int len ) { int i = 0; for ( i = 1; i &lt;= len; i++ ) { if ( arr[i] &lt; arr[i - 1] ) { printf(&quot;check_is_inc_arr fail.\\n&quot;); return; } } printf(&quot;check_is_inc_arr ok.\\n&quot;); } //初始化随机数组 void initArr( int *arr, int lowV, int upV, int len ) { int i = 0; int size = upV - lowV; for ( i = 1; i &lt; len + 1; i++ ) { arr[i] = rand() % size + lowV; } arr[0] = 0; } void print_arr( int *arr, int len ) { int i = 0; printf(&quot;\\n=============================================\\n&quot;); for ( i = 0; i &lt;= len; i++ ) { printf(&quot;%d &quot;, arr[i]); } printf(&quot;\\n=============================================\\n&quot;); } int main( int argc, char **argv ) { if ( argc != 4 ) { printf(&quot;input array length and the random value range.\\n&quot;); exit( 0 ); } srand( (int)time(NULL) ); int length = atoi( argv[1] ); int lowV = atoi( argv[2] ); int upV = atoi( argv[3] ); int *arr = ( int * )malloc( sizeof(int) * (length + 1) ); initArr( arr, lowV, upV, length ); //print_arr( arr, length ); heap_sort( arr, length, length ); //print_arr( arr, length ); check_is_inc_arr( arr, length ); return 0; } 上面代码中因为c数组从0开始的原因，因此0位置不参与存储和运算，数据形式是{0, 2, 3, 4, 5, 6}。","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://yoursite.com/tags/数据结构-算法/"}]},{"title":"n阶矩阵一般乘法-《算法导论》学习笔记五","slug":"015nmatrix/index","date":"2018-06-19T12:16:29.000Z","updated":"2018-06-19T12:18:12.130Z","comments":true,"path":"2018/06/19/015nmatrix/index/","link":"","permalink":"http://yoursite.com/2018/06/19/015nmatrix/index/","excerpt":"","text":"A、B两个矩阵均是nxn的矩阵，则两个矩阵的乘法： 一般的矩阵乘法代码： #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;time.h&gt; class SquareMatrix { public: SquareMatrix(){} SquareMatrix( int row, int col ): mRow(row), mCol(col) { Init(); } ~SquareMatrix() { for ( int i = 0; i &lt; mRow; i++ ) { delete[] mElement[i]; //printf(&quot;delete %d\\n&quot;, i); } delete[] mElement; } void Init() { mElement = new int*[mRow]; for ( int i = 0; i &lt; mCol; i++ ) { mElement[i] = new int[i]; } } void SetElement( int lowV, int upV ) { int size = upV - lowV; for ( int i = 0; i &lt; mRow; i++ ) { for ( int j = 0; j &lt; mCol; j++ ) { mElement[i][j] = rand() % size + lowV; } } } void PrintElement() { printf(&quot;=========================================\\n&quot;); for ( int i = 0; i &lt; mRow; i++ ) { for ( int j = 0; j &lt; mCol; j++ ) { printf(&quot;%d &quot;, mElement[i][j]); } printf(&quot;\\n&quot;); } printf(&quot;=========================================\\n&quot;); } public: int mRow; int mCol; int *(*mElement); }; void SquareMatrixMultiply( SquareMatrix &amp;a, SquareMatrix &amp;b, SquareMatrix &amp;c ) { int n = a.mRow; c.mRow = c.mCol = n; c.Init(); for ( int i = 0; i &lt; n; i++ ) { for ( int j = 0; j &lt; n; j++ ) { c.mElement[i][j] = 0; for ( int k = 0; k &lt; n; k++ ) { c.mElement[i][j] += a.mElement[i][k] * b.mElement[j][k]; } } } } int main( int argc, char **argv ) { if ( argc != 2 ) { printf(&quot;Usage:./binaryfile num\\n&quot;); exit( 0 ); } int n = atoi( argv[1] ); SquareMatrix smA( n, n ), smB( n, n ), smC; smA.SetElement( 1, 10 ); smA.PrintElement(); smB.SetElement( 1, 10 ); smB.PrintElement(); SquareMatrixMultiply( smA, smB, smC ); smC.PrintElement(); printf(&quot;init square matrix finished\\n&quot;); return 0; } 算法复杂度为O(n^3)，而Stranssen算法通过分治法将大矩阵切分为小矩阵进行计算，算法复杂度可以降低为O(n^2.81)，但是尝试写下代码，发现切割子矩阵时有点复杂，普通的切分会创建子矩阵并复制值，而用下标进行计算又比较复杂，下次有空再尝试写吧。","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://yoursite.com/tags/数据结构-算法/"}]},{"title":"erlang编写rebar3插件","slug":"014rebar3-plugin/index","date":"2018-06-19T12:11:35.000Z","updated":"2018-06-19T12:15:54.478Z","comments":true,"path":"2018/06/19/014rebar3-plugin/index/","link":"","permalink":"http://yoursite.com/2018/06/19/014rebar3-plugin/index/","excerpt":"","text":"1.生成插件工程假设插件名为testp，执行rebar3 new plugins testp，即生成了插件工程项目，查看目录结构如图： testp.erl文件调用初始化的代码，而插件最重要的代码在testp_prv.erl的文件，文件里提供了三个接口，分别为init/1,do/1,format_error/1，init做插件初始化的工作，初始化命名空间/初始化命令，然后将命令加入到rebar3，贴一份配置： init(State) -&gt; Provider = providers:create([ {name, compile}, % The &apos;user friendly&apos; name of the task {module, ?MODULE}, % The module implementation of the task {namespace, testp}, {bare, true}, % The task can be run by the user, always true {deps, ?DEPS}, % The list of dependencies {example, &quot;rebar3 testp compile&quot;}, % How to use the plugin {opts, []}, % list of options understood by the plugin {short_desc, &quot;rebar3 testp compiler&quot;}, {desc, &quot;rebar3 testp compiler&quot;} ]), {ok, rebar_state:add_provider(State, Provider)}. 这份配置就是为rebar3添加一个rebar3 testp compile命令，如果只输入rebar3 testp，会提示rebar3 testp compiler。第二个方法do就是主要的业务逻辑了，执行了rebar3 testp compiler命令就会调用里面的do方法。如果想添加多个命令，可以在testp.erl里多写一个命令的init调用，然后再添加一个命令类似的prv文件，写不同的do业务逻辑，就可以上传git，将git地址配置在rebar.config的plugins里了，rebar3 compile编译就自动拉取插件代码。插件还可以配置钩子(provider_hook)使用，例如添加编译前调用{provider_hooks,[{pre[{compile, {testp, compile}}]}]}，编译后调用将pre改为post即可","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"Erlang","slug":"Erlang","permalink":"http://yoursite.com/tags/Erlang/"}]},{"title":"erlang rebar3配置文件","slug":"013rebar3-conf/index","date":"2018-06-19T11:59:19.000Z","updated":"2018-06-19T12:11:02.436Z","comments":true,"path":"2018/06/19/013rebar3-conf/index/","link":"","permalink":"http://yoursite.com/2018/06/19/013rebar3-conf/index/","excerpt":"","text":"rebar3的简单使用可以参考rebar3的官方文档。以下讲解一些rebar3的配置，初入erlang，理解还不甚深刻。用rebar3进行工程创建，会生成rebar.config文件，贴一些配置的使用方法 1.编译设置%% 编译设置 {erl_opts, [ {parse_transform, lager_transform} , {parse_transform, ms_transform} , report , warn_export_all , warn_export_vars , warn_obsolete_guard , warn_shadow_vars , warn_unused_function , warn_deprecated_function %% ,warn_missing_spec , warn_unused_import ]}. {parse_transform, lager_transform}是lager依赖库的编译选项，修改抽象语法树的方式在编译期生成对应的代码，lager源代码里本身没有lager:error，lager:info等等方法 2.rebar3 shell{shell, [ {apps, [app_name, sync, recon]} , {config, “config/app_name.config”} ]}. 这个配置支持在项目根目录直接运行rebar3 shell启动一个erl shell来运行我们的app，而其配置可以指定为config目录下的某个配置文件，而不是sys.config，适合本地调试，app_name后面的app名字是需要依赖启动的app 3.rebar3插件{plugins, [ rebar3_run , rebar3_auto , {relflow, “1.0.5”} ]}. 配置我们项目需要的plugins，这里的插件可以是我们自己编写的rebar3插件 4.钩子 provider_hooks{provider_hooks, [ {pre,[ {compile, {my_plugins, do_something}} ]}, {post,[{compile,{my_plugins1, clean}}]} ]}. 例如这份配置，就是在执行rebar3 compile之前(pre)运行以my_plugins命名空间下的do_something命令，简单说就是编写了一个rebar3的插件叫my_plugins，提供一个命令叫do_something，即可以在命令行执行rebar3 my_plugins do_something的功能，只是现在配置之后自动调用了命令；post同理就是在compile之后执行那个插件的clean功能，clean功能具体干什么我们不得而知。 5.环境{profiles, [ {profile1, [ {erl_opts, [no_debug_info]}, {relx, [ {include_src, false} , {dev_mode, false} , {include_erts, true} , {system_libs, true} ]} ]}]} 例如这份配置，指定了一种环境叫profile1，编译选项erl_opts为no_debug_info，打包发布的选项为不包含源码，禁止开发模式(目录不是软连接于default环境)，包含erlang环境等，当然还可以加其它很多选项，为每种环境单独自定义需要的功能，常用default、prod、test等 6.覆盖{overrides, [{add, deps1, [{erl_opts, [no_debug_info]}]}]} 例如这份配置，就是对名为deps1的依赖的rebar.config再添加一个配置，overrides提供了add和override两种功能，第一种是加配置，第二种也就是用配置的数据去覆盖原来依赖中有的数据","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"Erlang","slug":"Erlang","permalink":"http://yoursite.com/tags/Erlang/"}]},{"title":"ubuntu16+ideaIC+rebar3搭建erlang开发环境","slug":"012erlang-system-build/index","date":"2018-06-19T11:42:44.000Z","updated":"2018-06-19T11:52:53.451Z","comments":true,"path":"2018/06/19/012erlang-system-build/index/","link":"","permalink":"http://yoursite.com/2018/06/19/012erlang-system-build/index/","excerpt":"","text":"1.ubuntu16系统2.安装各种库sudo apt-get install build-essential sudo apt-get install libncurses5-dev sudo apt-get install libssl-dev sudo apt-get install m4 sudo apt-get install unixodbc unixodbc-dev sudo apt-get install freeglut3-dev libwxgtk2.8-dev sudo apt-get install xsltproc sudo apt-get install fop sudo apt-get install tk8.5 3.安装erlang源码deb安装包：esl-erlang_19.1.3-1-ubuntu-xenial_amd64.deb dpkg -i esl-erlang_19.1.3-1-ubuntu-xenial_amd64.deb 4.安装ideaIC工具百度搜索安装ideaIC，我安装的ideaIC3.4版本，地址 5.下载rebar3rebar3地址 6.ideaIC安装erlang插件打开ideaIC，进入configure菜单进入settings进行设置：settings -&gt; Plugins -&gt; Browse repositories，然后搜索erlang，就可以安装erlang插件了 7.配置安装完后再次进入settings界面：settings -&gt; Build,Execution,Deployment -&gt; Compiler -&gt; Erlang Compiler，将”Compiler project with rebar”和”Add debug info”都打勾。 接着：settings -&gt; Other Settings -&gt; Erlang External Tools，将”rebar”的路径设置为下载的rebar3可执行路径的目录。配置完成。 8.创建、打开新工程等略","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"Erlang","slug":"Erlang","permalink":"http://yoursite.com/tags/Erlang/"}]},{"title":"分治之最大子数组-《算法导论》学习笔记四","slug":"011max-sub-arr/index","date":"2018-06-19T11:35:51.000Z","updated":"2018-06-19T11:41:36.432Z","comments":true,"path":"2018/06/19/011max-sub-arr/index/","link":"","permalink":"http://yoursite.com/2018/06/19/011max-sub-arr/index/","excerpt":"","text":"《算法导论》第4章4.1使用分治策略求最大子数组（数组包含负数，不然整个数组即使最大子数组，求解没意义）。 思路：数组头为low，尾为high，mid=(low+high)/2，这样将数组分为了两段。首先肯定存在这个最大子数组。那么子数组的位置要么处于mid左边，要么处于mid右边，要么包含mid。假设最大子数组出现在mid左边，对mid左边子数组再进行(low+high)/2切分，那么最大子数组可能在切分出的子数组中的位置又存在三种情况中的一种，这样递归地切分下去，最终切分到整个数组都变为1-2个元素的子数组，这时候的情况就像一颗二叉树，例如数组[53,-4,-73,-16,88,91,-50,-15,-15,52,-19]，切分之后的二叉树： 然后用后续遍历二叉树的方式计算、查找最大子数组。如图，节点8的子数组有53、-4、53,-4，则找出来最大子数组为[53]，后序遍历的方式遍历完左子树，返回根，到右子树，有一个节点9，则最大子数组为9，对于节点4的左右子树的最大子数组都找到，再对节点8、4、9合并的数组找位于mid的最大子数组(此时low为0，mid为1，high为2，从mid出发往左走找最大子数组，再从mid+1出发往右走找最大子数组，再将找到的两个数组合并起来，为经过mid的最大子数组)，找到为[53,-4,-73]，将[53]、[-73]，[53,-4,-73]比较，得出根节点为4的树最大数组为[53]，则再返回根节点2，再后续到节点5，对5再求最大子数组为[88,91]，再对节点2求经过mid的最大子数组为[53,-4,-73,-16,88,91]，和为139，与[53]、[88,91]比较，选[88,91]；接着返回根节点1，对右子树节点2求最大子数组，为[52]，再对节点1组成的数组求经过mid的最大子数组，为[88,91,-50,-15,-15,52]，和为151，与[88,91]、[52]比较，选[88,91]。 c代码： #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;time.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; int crossLow = 0, crossHigh = 0, crossSum = 0; int finalLeftIndex = -1; int finalRightIndex = -1; int finalSubArraySum = 0; //求经过mid的最长子数组，范围low-high void find_max_crossing_subarray( int *arr, int low, int mid, int high ) { if ( low == mid &amp;&amp; mid == high ) { crossLow = low; crossHigh = high; crossSum = arr[mid]; return ; } int lMax = -10000000, rMax = -10000000; int lTmpSum = 0, rTmpSum = 0; int i = 0; for ( i = mid; i &gt;= low; i-- ) { lTmpSum += arr[i]; if ( lTmpSum &gt; lMax ) { lMax = lTmpSum; crossLow = i; } } for ( i = mid + 1; i &lt;= high; i++ ) { rTmpSum += arr[i]; if ( rTmpSum &gt; rMax ) { rMax = rTmpSum; crossHigh = i; } } crossSum = lMax + rMax; } //分治，将数组切分子规模的待求数组 void find_maximum_subarray( int *arr, int low, int high ) { if ( high &lt;= low + 1 ) { find_max_crossing_subarray( arr, low, low, high ); if ( arr[low] &gt;= arr[high] &amp;&amp; arr[low] &gt;= crossSum ) { finalLeftIndex = low; finalRightIndex = low; finalSubArraySum = arr[low]; } else if ( arr[high] &gt;= arr[low] &amp;&amp; arr[high] &gt;= crossSum ) { finalLeftIndex = high; finalRightIndex = high; finalSubArraySum = arr[high]; } else { finalLeftIndex = low; finalRightIndex = high; finalSubArraySum = crossSum; } } else { int lLow = 0, lHigh = 0, lSum = 0; int rLow = 0, rHigh = 0, rSum = 0; //其实这里的递归就像二叉树的后续遍历，直到遍历完左子树，再开始右子树， //这样的好处假如数组有上亿的元素，不会造成栈空间不足， //解决了一个左子树就返回了递归栈，再进行右子树的展开工作 int mid = ( low + high ) / 2; find_maximum_subarray( arr, low, mid ); lLow = finalLeftIndex; lHigh = finalRightIndex; lSum = finalSubArraySum; find_maximum_subarray( arr, mid + 1, high ); rLow = finalLeftIndex; rHigh = finalRightIndex; rSum = finalSubArraySum; find_max_crossing_subarray( arr, low, mid, high ); // printf(&quot;%d %d %d/%d %d %d/%d %d %d\\n&quot;, // lLow, lHigh, lSum, // rLow, rHigh, rSum, // crossLow, crossHigh, crossSum); if ( lSum &gt;= rSum &amp;&amp; lSum &gt;= crossSum ) { finalLeftIndex = lLow; finalRightIndex = lHigh; finalSubArraySum = lSum; } else if ( rSum &gt;= lSum &amp;&amp; rSum &gt;= crossSum ) { finalLeftIndex = rLow; finalRightIndex = rHigh; finalSubArraySum = rSum; } else { finalLeftIndex = crossLow; finalRightIndex = crossHigh; finalSubArraySum = crossSum; } // printf(&quot;------%d %d %d\\n&quot;, finalLeftIndex, finalRightIndex, finalSubArraySum); } } //暴力破解法求最长子数组，不过这里用来测试我写的分治求法结果是否正确 int check_result( int *arr, int len, int lIndex, int rIndex, int Sum ) { int maxSum = -100000000; int lIndex1; int rIndex1; int i = 0, j = 0; for ( i = 0; i &lt; len; i++ ) { int tmpSum = 0; for ( j = i; j &lt; len; j++ ) { tmpSum += arr[j]; if ( tmpSum &gt; maxSum ) { maxSum = tmpSum; lIndex1 = i; rIndex1 = j; } } } if ( Sum == maxSum ) { if ( lIndex == lIndex1 &amp;&amp; rIndex == rIndex1 ) { return 0; } printf(&quot;equal!!\\n&quot;); printf(&quot;exhaustivly_find_result:lIndex-&gt;%d,rIndex-&gt;%d,Sum-&gt;%d\\n&quot;, lIndex1, rIndex1, maxSum); printf(&quot;divide_and_conquer_result:lIndex-&gt;%d,rIndex-&gt;%d,Sum-&gt;%d\\n&quot;, lIndex, rIndex, Sum); return 1; } // else { // printf(&quot;not equal!!!!!!!!!&quot;); // } return -1; } void mainLoop( int *arr, int len ) { find_maximum_subarray( arr, 0, len - 1 ); printf(&quot;----------------------------------------------------\\n&quot;); printf(&quot;lIndex:%d,rIndex:%d,subArrSum:%d\\n&quot;, finalLeftIndex, finalRightIndex, finalSubArraySum); printf(&quot;----------------------------------------------------\\n&quot;); } void stepLoop( int *arr, int len ) { time_t tt0 = time( NULL ); printf(&quot;before:%s&quot;, ctime(&amp;tt0)); mainLoop( arr, len ); time_t tt1 = time( NULL ); printf(&quot;after:%s&quot;, ctime(&amp;tt1)); printf(&quot;cost %d(sec),%d(min)\\n&quot;, (int)(tt1 - tt0), (int)((tt1 - tt0) / 60)); } //初始化随机数组 void initArr( int *arr, int lowV, int upV, int len ) { int i = 0; int size = upV - lowV; for ( ; i &lt; len; i++ ) { arr[i] = rand() % size + lowV; } } //打印数组 void printArr( int *arr, int len ) { int i = 0; for ( ; i &lt; len; i++ ) printf(&quot;%d &quot;, arr[i]); printf(&quot;\\n&quot;); } int main( int argc, char **argv ) { srand( (int)time(NULL) ); if ( argc != 4 ) { printf(&quot;usage: ./execfile lowV upV len\\n&quot;); return 0; } int lowV = atoi( argv[1] ); int upV = atoi( argv[2] ); unsigned int len = atoi( argv[3] ); int *arr = NULL; arr = ( int *) malloc( len * sizeof(int) ); // int len = 10; // int arr[10] = {7, 0, -86, 61, -72, 50, -38, -25, -70, -76}; int i = 0; //随机10000个数组求最大子数组，然后检测结果是否正确 for ( i = 0; i &lt; 10000; i++ ) { initArr( arr, lowV, upV, len ); printArr( arr, len ); // stepLoop( arr, len ); usleep(1000); find_maximum_subarray( arr, 0, len - 1 ); int ret = check_result( arr, len, finalLeftIndex, finalRightIndex, finalSubArraySum ); if ( ret &lt; 0 ) { printf(&quot;failed!!\\n&quot;); return 0; } printf(&quot;-------------equal:%d\\n&quot;, i); } free( arr ); arr = NULL; return 0; } 以上代码定义了几个全局变量，与《算法导论》的代码有点出入，书上的函数块返回3个值，例如：(left-low,left-high,left-sum) = FIND-MAXIMUM-SUBARRAY(A, low, mid)，这里可能用其它编程语言更好描述算法，erlang/golang/python的函数就可以返回一个元组并接收{LeftLow, LeftHigh, LeftSum} = FIND….()。","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://yoursite.com/tags/数据结构-算法/"}]},{"title":"递归插入排序-《算法导论》学习笔记三","slug":"010recu-insert-sort/index","date":"2018-06-15T12:15:00.000Z","updated":"2018-06-19T11:50:06.319Z","comments":true,"path":"2018/06/15/010recu-insert-sort/index/","link":"","permalink":"http://yoursite.com/2018/06/15/010recu-insert-sort/index/","excerpt":"","text":"算法导论第二章结尾练习2.3-4提到将插入排序写递归版本，然后尝试写了个，本来写了就好了，但是调试的时候排序10w个数可以，排序100w个数就段错误，分析了一下，把结果放上来以后查看，先贴代码： #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;time.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; void insert_sort0( int *arr, int index ) { int i, tmp = arr[index]; //printf(&quot;index:%d\\n&quot;, index); for ( i = index - 1; i &gt;= 0; i-- ) { if ( arr[i] &gt; tmp ) { arr[i + 1] = arr[i]; } else { arr[i + 1] = tmp; return; } } arr[i + 1] = tmp; } void insert_sort( int *arr, int index ) { //printf(&quot;index:%d\\n&quot;, index); if ( index &gt; 0 ) { insert_sort( arr, index - 1 ); //printf(&quot;index:%d\\n&quot;, index); insert_sort0( arr, index ); } } void sortLoop0( int *arr, int len ) { //sleep( 20 ); insert_sort( arr, len - 1 ); } //排序前后做时间对比，精度sec void sortLoop( int *arr, int len ) { time_t tt0 = time( NULL ); printf(&quot;\\tbefore sort:%s&quot;, ctime(&amp;tt0)); sortLoop0( arr, len ); time_t tt1 = time( NULL ); printf(&quot;\\tafter sort:%s&quot;, ctime(&amp;tt1)); printf(&quot;\\tsort the array cost %d(sec),%d(min)\\n&quot;, (int)(tt1 - tt0), (int)((tt1 - tt0) / 60)); } //初始化随机数组 void initArr( int *arr, int lowV, int upV, int len ) { srand( (int)time(NULL) ); int i = 0; int size = upV - lowV; for ( ; i &lt; len; i++ ) { arr[i] = rand() % size + lowV; } } //打印数组 void printArr( int *arr, int len ) { int i = 0; for ( ; i &lt; len; i++ ) printf(&quot;%d &quot;, arr[i]); printf(&quot;\\n&quot;); } //这里写了个简单得数组检查，检查是否 //是正确的递增序列(怕自己的代码没检查 //边界条件偶尔有错误的排序数组) int check_arr_increase( int *arr, int len ) { int i = 0; for ( ; i &lt; len - 1; i++ ) { if ( arr[i] &lt;= arr[i + 1] ) continue; else { printf(&quot;array isn&apos;t increase!!!\\n&quot;); return -1; } } printf(&quot;array is increase!!!!\\n&quot;); return 0; } int main( int argc, char **argv ) { if ( argc != 4 ) { printf(&quot;usage: ./execfile lowV upV len\\n&quot;); return 0; } int lowV = atoi( argv[1] ); int upV = atoi( argv[2] ); unsigned int len = atoi( argv[3] ); int *arr = NULL; arr = ( int *) malloc( len * sizeof(int) ); initArr( arr, lowV, upV, len ); //printArr( arr, len ); sortLoop( arr, len ); check_arr_increase( arr, len ); //printArr( arr, len ); free( arr ); arr = NULL; return 0; } 开始一直以为是代码有数组越界或者边界条件没考虑到，后来看了代码许久没发现问题。然后gdb看core文件，bt看调用栈发现段在递归向下大概70w-80w的位置，而递归栈还没返回，执行过程很正常没出问题，想了想是栈溢出，每次自顶向下调用一次自身函数就要在栈里保存一次函数地址和参数。 用ulimit -a|grep stack看了一下默认的栈空间大小为8192kb=8m=810241024=8388608byte。网上查了下说一次函数调用每次占用栈内存为：4返回地址 + 4参数个数 + 4寄存器保护 + 4局部变量数（未验证准确与否），我的排序占用4+42+12=24字节，但根据我每次设置栈大小调试程序，设置到31256kb时程序没有段错误，也就是312561024/1000000=32字节，这里的一次函数调用为32字节。 用ulimit -s 102400修改了栈空间大小100M（暂时修改），再次运行程序排序100w个数，发现打印正常，程序也没段错误了，只是递归栈开始返回等了好久。 对归并排序的思考：以前也有用归并排序排1亿个数（http://blog.csdn.net/u012785877/article/details/52475023），没有出现栈溢出，里面也是用递归的方法，因此仔细看了下归并排序（算法导论里有提到归并排序的递归树，可以算出数量，但是我看着头大，准备略过这些数学问题，先照着把代码写出来，看完了再回头深入看一遍），模拟了一下递归的栈过程如下： 假设有134217728个数待排序(2^27)。因此递归树根节点为2^27；递归第一次递归树有二层，两个节点分别为2^26、2^26；递归第三次递归树为有三层，四个节点分别为2^25、2^25、2^25、2^25……这样一直推到递归树叶子节点为2^1，此递归树有27层，2^(floor - 1) + 1 = 2^(26 -1) + 1 = 67108865个节点，也就是要维护67108865*30约为20亿的函数调用栈空间，为什么没有栈溢出呢？。通过调试归并排序，排序4个数时，是将0-3分为0-1，在将0-1分为0，对0再分发现不能分了，则此次递归返回到父节点，划分右子树1，对1再分发现不能分了，于是调用排序，将0、1排为0-1，再回归0-1的父节点，再对右子树2-3递归进行此过程。其实排序4个数最大只需要5次递归函数调用（即递归树走到最深度），如果排序n层递归树，最大需要n+1次。回到以上排序2^27个数，则最大同时需要28次递归函数调用，其余时候都是栈空间在不断出栈入栈。 上面写得有点昏，无奈不是学文科的，又不想画图，额。这个归并排序的分析结果只花了2个小时分析，也不能确定准不准确，如果错了欢迎批评指正。","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://yoursite.com/tags/数据结构-算法/"}]},{"title":"c半同步半异步进程池模型之cgi服务器","slug":"009cgiserver/index","date":"2018-06-15T10:47:28.000Z","updated":"2018-06-19T02:02:56.131Z","comments":true,"path":"2018/06/15/009cgiserver/index/","link":"","permalink":"http://yoursite.com/2018/06/15/009cgiserver/index/","excerpt":"","text":"对半同步半异步进程池模型垂涎已久，这次中秋放假撸了下代码。 模型的简单介绍：主进程创建几个子进程作为工作进程，主进程监听客户端connect事件，一旦有连接事件，即通过round robin(简单轮询)选取一个子进程， 通过父子进程间的通信管道通知子进程有连接事件，子进程epoll监听到管道通信时间，即知道有客户端连接，因此进程accept，并将客户端连接套接字加入epoll监听事件，客户端浏览器发送get请求，客户端监听到请求事件，即调用封装好的客户端事件进行处理，本例子的客户端处理为recv客户的请求，从中提取文件名(now.cgi)，并重定向客户端连接套接字到stdout，然后执行对应cgi文件，cgi文件打印html页面字符串，因为重定向的缘故，打印的html字符串发送给客户端，客户端浏览器即显示了html页面。 代码写了几个模块，分别是： util：封装了套接字创建、unix族socket管道创建、中断信号、简单屏幕输出(可自行替换为日志文件输出) epoll_wrapper：封装了epoll相关操作包括创建epfd、添加epoll监听事件、删除epoll监听事件 myhshappool(我的半同步半异步进程池 - -!…)：封装了进程池初始化、启动进程池进行事件监听 client_handle：进程池监听到客户事件、即调用client_handle封装的处理事件，这里封装的是执行cgi文件向客户端浏览器返回服务器时间(最近在看unix网络编程，里面都是时间获取的服务器，借鉴下拿来搞事，当然，嵌入式里拿来控制个灯泡开关想来特别带劲，用android做个网页app，板子接wifi模块接智能灯，cgi负责开关灯泡 。。) cgisrv：入口，初始化进程池，启动进程池 代码快1k行，不知道一个博客文章能不能写下，这种玩具demo代码就不往github放了。代码中凑合写了注释(有时候不想切换中英文因此用了蹩脚的英文注释)，限(wo)于(tai)篇(lan)幅(le)没有写文件头注释和函数头注释。 util.h： #ifndef _UTIL_H #define _UTIL_H #include &lt;stdio.h&gt; #include &lt;signal.h&gt; #include &lt;string.h&gt; #include &lt;errno.h&gt; #include &lt;sys/socket.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;stdlib.h&gt; #include &lt;fcntl.h&gt; //这里不用 #转字符串了，不方便管理等级 #ifdef LEVELNUMPRINT #define LEVEL0 &quot;LEVEL0&quot; #define LEVEL1 &quot;LEVEL1&quot; #define LEVEL2 &quot;LEVEL2&quot; #define LEVEL3 &quot;LEVEL3&quot; #define LEVEL4 &quot;LEVEL4&quot; #define LEVEL4 &quot;LEVEL5&quot; #else #define LEVEL0 &quot;DEBUG&quot; #define LEVEL1 &quot;INFO&quot; #define LEVEL2 &quot;NOTICE&quot; #define LEVEL3 &quot;WARN&quot; #define LEVEL4 &quot;ERROR&quot; #define LEVEL5 &quot;FATAL&quot; #endif #define PRINTINFO( LEVEL, format, args... ) \\ do { \\ printf(&quot;[%s]:(pid:%d)/(file:%s)/(func:%s)/(line:%d)&quot;, \\ LEVEL, getpid(), __FILE__, __func__, __LINE__); \\ /*printf(&quot;\\t&quot; #LEVEL &quot;:&quot;);*/ \\ printf(&quot;--|--&quot;); \\ printf( format, ##args ); \\ printf(&quot;\\n&quot;); \\ } while( 0 ) #define PRINTINFO_ERR( LEVEL, format, args... ) \\ do { \\ printf(&quot;[%s]:(pid:%d)/(file:%s)/(func:%s)/(line:%d)&quot;, \\ LEVEL, getpid(), __FILE__, __func__, __LINE__); \\ /*printf(&quot;\\t&quot; #LEVEL &quot;:&quot;);*/ \\ printf(&quot;--|--&quot;); \\ printf( format, ##args ); \\ printf(&quot;(errmsg:%s)&quot;, strerror(errno)); \\ printf(&quot;\\n&quot;); \\ } while( 0 ) void Add_sig( int sig, void (*handler)(int), int restart_syscall ); void Socketpair( int *pairpipefd ); int Socket_create( char *ipaddr, int port ); void Setnonblocking( int fd ); #endif util.c: #include &quot;util.h&quot; static int add_sig( int sig, void (*handler)(int), int restart_syscall ) { struct sigaction act; bzero( &amp;act, sizeof(act) ); act.sa_handler = handler; act.sa_flags = 0; //早期unix系统对于进程在执行一个低速系统调用(如ioctl、 //read、write、wait)而阻塞期间捕捉到一个信号，则系统 //调用被中断不再执行，该系统调用返回错误，设置errno为 //EINTR，随后的bsd系统引入了自动重启，即再次进行此系统 //调用。unix衍生系统默认的方式可能为可选、总是等，类 //unix系统的linux系统可能默认为不重启，因此添加重启标识 if ( restart_syscall ) { act.sa_flags |= SA_RESTART; } //宏定义： //#define sigfillset(*p) (*p) = ~(0,0) sigfillset( &amp;act.sa_mask ); if ( -1 == sigaction(sig, &amp;act, NULL) ) { PRINTINFO_ERR( LEVEL4, &quot;sigaction error&quot; ); return -1; } return 0; } void Add_sig( int sig, void (*handler)(int), int restart_syscall ) { if ( add_sig(sig, handler, restart_syscall) &lt; 0 ) { PRINTINFO( LEVEL5, &quot;add_sig error&quot; ); exit( 0 ); } } void Socketpair( int *pairpipefd ) { int ret; ret = socketpair( PF_UNIX, SOCK_STREAM, 0, pairpipefd ); if ( ret &lt; 0 ) { PRINTINFO_ERR( LEVEL5, &quot;socketpair error!!&quot; ); exit( 0 ); } } static int socket_create( char *ipaddr, int port, int backlog ) { int sockfd; int ret; sockfd = socket( AF_INET, SOCK_STREAM, 0 ); if ( sockfd &lt; 0 ) { PRINTINFO_ERR( LEVEL4, &quot;socket error!!!&quot; ); return -1; } struct sockaddr_in addr; bzero( &amp;addr, sizeof(addr) ) ; addr.sin_family = AF_INET; addr.sin_port = htons( port ); inet_pton( AF_INET, ipaddr, &amp;addr.sin_addr ); int reuseaddr = 1; setsockopt( sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuseaddr, sizeof(int) ); ret = bind( sockfd, (struct sockaddr *)&amp;addr, (socklen_t)sizeof(addr) ) ; if ( ret &lt; 0 ) { PRINTINFO_ERR( LEVEL4, &quot;bind error!!!&quot; ); return -1; } ret = listen( sockfd, backlog ); if ( ret &lt; 0 ) { PRINTINFO_ERR( LEVEL4, &quot;listen error!!!&quot; ); return -1; } return sockfd; } int Socket_create( char *ipaddr, int port ) { int ret; ret = socket_create( ipaddr, port, 5 ); if ( ret &lt; 0 ) { PRINTINFO( LEVEL5, &quot;socket_creaet error!!!&quot; ); exit( 0 ); } return ret; } static int setnonblocking( int fd ) { int old_opt = fcntl( fd, F_GETFL ); int new_opt = old_opt | O_NONBLOCK; fcntl( fd, F_SETFL, new_opt ); return old_opt; } void Setnonblocking( int fd ) { setnonblocking( fd ); } int Send ( int socket_fd, const unsigned char * send_buf, int buf_size, int flag ) { int snd_bytes = 0; int snd_total_bytes = 0; int snd_count = 3; while ( snd_count -- ) { snd_bytes = send( socket_fd, send_buf, buf_size, flag ); if ( snd_bytes &lt;= 0 ) { if ( EAGAIN == errno || EINTR == errno || EWOULDBLOCK == errno ) { //暂时发送失败，需要重复发送 usleep( 50 ); continue; }else { //连接不正常，返回-1交由上层清理此套接字 PRINTINFO_ERR( LEVEL4, &quot;send return error!!!&quot; ); return -1; } } snd_total_bytes += snd_bytes; if ( snd_total_bytes &gt;= buf_size ) { break; } } if ( !snd_count ) { PRINTINFO( LEVEL4, &quot;send timeout!!!&quot; ); return -1; } return snd_total_bytes; } #if 0 int main() { PRINTINFO( LEVEL0, &quot;likun:%d&quot;, 123 ); PRINTINFO( LEVEL1, &quot;likun:&quot; ); //PRINTINFO( likun, &quot;likun:&quot; ); return 0; } #endif epoll_wrapper.h: #ifndef _EPOLL_WRAPPER_H #define _EPOLL_WRAPPER_H #include &lt;sys/epoll.h&gt; #include &lt;stdlib.h&gt; int Epoll_create( int size ); int Epoll_wait( int epfd, struct epoll_event *events, int maxevents, int timeout ); void Epoll_add_fd( int epfd, int fd ); void Epoll_del_fd( int epfd, int fd ); #endif epoll_wrapper.c: #include &quot;epoll_wrapper.h&quot; #include &quot;util.h&quot; static int epoll_create0( int size ) { int ret; ret = epoll_create( size ); if ( ret &lt;= 0 ) { PRINTINFO_ERR( LEVEL3, &quot;epoll_create error!!!&quot; ); return -1; } return ret; } int Epoll_create( int size ) { int ret; if ( (ret = epoll_create0(size)) &lt; 0 ) { PRINTINFO( LEVEL5, &quot;epoll_create0 error!!!&quot; ); exit( 0 ); } return ret; } int Epoll_wait( int epfd, struct epoll_event *events, int maxevents, int timeout ) { return epoll_wait( epfd, events, maxevents, timeout ); } static int epoll_add_fd( int epfd, int fd ) { struct epoll_event event; event.data.fd = fd; event.events = EPOLLIN | EPOLLET; epoll_ctl( epfd, EPOLL_CTL_ADD, fd, &amp;event ); Setnonblocking( fd ); return 0; } void Epoll_add_fd( int epfd, int fd ) { epoll_add_fd( epfd, fd ); } void Epoll_del_fd( int epfd, int fd ) { epoll_ctl( epfd, EPOLL_CTL_DEL, fd, NULL ); } #if 0 int main() {} #endif myhshappool.h: #ifndef _MY_HS_HA_P_POOL_H #define _MY_HS_HA_P_POOL_H #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;assert.h&gt; #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/epoll.h&gt; #include &lt;signal.h&gt; #include &lt;sys/wait.h&gt; #include &lt;sys/stat.h&gt; #include &lt;libgen.h&gt; typedef struct process { //当前进程id号 pid_t pid; //与父进程通信用的管道 //0端父进程写 //1端子进程读 int pipefd[2]; } process; typedef struct processpool { //进程池最大进程数 int max_process_num; //每个进程最大处理客户数量 int max_user_num; //epoll最多处理的事件数 int max_epoll_event; //当前进程池进程总数 int cur_process_num; //当前子进程在进程池序号，从0开始 int index; //每个进程一个epoll内核事件表 int epollfd; //监听socket int listenfd; //停止线程池 int stop; //进程池子进程管理 struct process *sub_process; } processpool; int init_process_pool( processpool *ppool, int maxpnum, int maxunum, int maxeevent, int curpnum, int listenfd ); void run( processpool *ppool ); #endif myhshappool.c: #include &quot;myhshappool.h&quot; #include &quot;client_handle.h&quot; #include &quot;util.h&quot; //用于信号中断时主进程通信， //统一处理事件，即将客户端连接 //事件、信号事件都统一用epoll //监听处理，0端信号处理函数写， //1端进程读 static int sig_pipefd[2]; static void sig_handler( int sig ) { //保存旧的errno，对后续的send不 //进行错误判定，但send假如返回 //失败会设置errno，信号中断调用 //结束后影响进程其它模块判断 int old_errno = errno; char signo = (char)sig; send( sig_pipefd[0], (char *)&amp;signo, 1, 0 ); errno = old_errno; } static void init_signal( processpool *ppool ) { Socketpair( sig_pipefd ); Setnonblocking( sig_pipefd[0] ); //Epoll_add_fd( ppool-&gt;epollfd, sig_pipefd[1] ); Add_sig( SIGCHLD, sig_handler, 1 ); Add_sig( SIGTERM, sig_handler, 1 ); Add_sig( SIGINT, sig_handler, 1 ); Add_sig( SIGPIPE, SIG_IGN, 1 ); } int init_process_pool( processpool *ppool, int maxpnum, int maxunum, int maxeevent, int curpnum, int listenfd ) { if ( !ppool ) { PRINTINFO( LEVEL4, &quot;ppool is null!!!&quot; ); return -1; } ppool-&gt;max_process_num = maxpnum; ppool-&gt;max_user_num = maxunum; ppool-&gt;max_epoll_event = maxeevent; ppool-&gt;cur_process_num = curpnum; ppool-&gt;listenfd = listenfd; // ppool-&gt;epollfd = Epoll_create( 5 ); ppool-&gt;index = -1; ppool-&gt;stop = 0; ppool-&gt;sub_process = (process *)calloc( sizeof(process), curpnum ); if ( !ppool-&gt;sub_process ) { PRINTINFO( LEVEL4, &quot;sub_process calloc error!!!&quot; ); return -1; } int i = 0; int pid; //先模拟一下进程池创建之前的情况，假设终端 //bash shell进程id为1000，运行此程序进程id //为1001，其父进程为1000，fork之后主进程不 //变，子进程id为1002，其父进程为1001，因此 //明白fork的过程，下面可以走一下进程池创建 //的流程（条件均为以上假设）： //第一次fork:创建亲缘进程的管道，父进程1001 //，子进程1002，其父进程为1001，子进程不再 //执行for循环，且主进程与1002子进程有单独通 //信的管道 //第二次fork:创建亲缘进程的管道，父进程1001 //，子进程1003，其父进程为1001，子进程不再 //执行for循环，且主进程与1003子进程有单独通 //信的管道 //第三次fork .....1004..... // ........ //通过以上过程，可以看到for循环次数为创建的 //子进程数量，且每个子进程可以单独与父进程 //通信 // //这里进程创建，没有脱离当前终端的会话， //我觉得可以setsid()来摆脱终端影响 for ( ; i &lt; curpnum; i++ ) { Socketpair( ppool-&gt;sub_process[i].pipefd ); pid = fork(); if ( pid &gt; 0 ) { //parent fork close( ppool-&gt;sub_process[i].pipefd[1] ); ppool-&gt;sub_process[i].pid = pid; Setnonblocking( ppool-&gt;sub_process[i].pipefd[0] ); continue; } else if ( pid == 0 ) { //child ppool-&gt;index = i; PRINTINFO( LEVEL0, &quot;child(%d):%d\\tparent:%d&quot;, i + 1, getpid(), getppid() ); close( ppool-&gt;sub_process[i].pipefd[0] ); //每次只由父进程去创建进程 break; } else { PRINTINFO( LEVEL5, &quot;fork error!!!&quot; ); exit( 0 ); } } } static int client_signal_handle( processpool *ppool, char *signals, int signals_num ) { int i = 0; for ( ; i &lt; signals_num; i++ ) { switch( signals[i] ) { case SIGCHLD: { PRINTINFO( LEVEL0, &quot;child receive a SIGCHLD signal&quot; ); pid_t pid; int stat; //catch SIGCHLD while ( (pid = waitpid(-1, &amp;stat, WNOHANG)) &gt; 0 ) { continue; } break; } case SIGTERM: { PRINTINFO( LEVEL0, &quot;child receive a SIGTERM signal&quot; ); ppool-&gt;stop = 1; break; } case SIGINT: { PRINTINFO( LEVEL0, &quot;child receive a SIGINT signal&quot; ); ppool-&gt;stop = 1; break; } default: { break; } } } } static void run_child( processpool *ppool ) { if ( !ppool ) { PRINTINFO( LEVEL4, &quot;ppool is null!!!&quot; ); return; } init_signal( ppool ); ppool-&gt;epollfd = Epoll_create( 5 ); PRINTINFO( LEVEL0, &quot;child cur process:%d&quot;, ppool-&gt;cur_process_num ); int pipefd = ppool-&gt;sub_process[ppool-&gt;index].pipefd[1]; Epoll_add_fd( ppool-&gt;epollfd, pipefd ); Epoll_add_fd( ppool-&gt;epollfd, sig_pipefd[1] ); struct epoll_event *events = (struct epoll_event *) calloc( sizeof(struct epoll_event), ppool-&gt;max_epoll_event ); if ( !events ) { PRINTINFO( LEVEL5, &quot;calloc error!!!&quot; ); goto _free_source; } struct client_param *cparam = NULL; cparam = (struct client_param *) calloc( sizeof(struct client_param), ppool-&gt;max_user_num ); if ( !cparam ) { PRINTINFO( LEVEL5, &quot;calloc error!!!&quot; ); goto _free_source; } int event_num, event_fd; int i, j, ret, onebyte; while ( !ppool-&gt;stop ) { event_num = Epoll_wait( ppool-&gt;epollfd, events, ppool-&gt;max_epoll_event, -1); //PRINTINFO( LEVEL0, &quot;child event num:%d&quot;, event_num ); if ( (event_num &lt; 0) &amp;&amp; (errno != EINTR) ) { PRINTINFO_ERR( LEVEL4, &quot;Epoll_wait error!!!&quot; ); ppool-&gt;stop = 1; break; } for ( i = 0; i &lt; event_num; i++ ) { event_fd = events[i].data.fd; //parent process notify that there is a new client connect to. if ( event_fd == pipefd &amp;&amp; events[i].events &amp; EPOLLIN ) { PRINTINFO( LEVEL0, &quot;receive signal from parent there is a new client connection&quot; ); ret = recv( event_fd, (char *)&amp;onebyte, 1, 0 ); if ( ret &lt;= 0 ) { continue; } else { struct sockaddr_in clientaddr; socklen_t addrlen = sizeof(clientaddr); bzero( &amp;clientaddr, addrlen ); int connfd = accept( ppool-&gt;listenfd, (struct sockaddr *)&amp;clientaddr, &amp;addrlen ); if ( connfd &lt; 0 ) { PRINTINFO_ERR( LEVEL3, &quot;accept a new client error!!!&quot; ); continue; } PRINTINFO( LEVEL0, &quot;one client conntect(fd:%d)&quot;, connfd ); Epoll_add_fd( ppool-&gt;epollfd, connfd ); client_param_init( &amp;cparam[connfd], connfd, &amp;clientaddr ); } } //process catch a signal else if ( event_fd == sig_pipefd[1] &amp;&amp; events[i].events &amp; EPOLLIN ) { int sig; char signals[1024] = {0}; ret = recv( sig_pipefd[1], signals, sizeof(signals), 0 ); if ( ret &lt;= 0 ) { continue; } client_signal_handle( ppool, signals, ret ); } //client socket fd has readable event,maybe a //request else if ( events[i].events &amp; EPOLLIN ) { client_handle( &amp;cparam[event_fd] ); } else { continue; } } } _free_source: free( events ); events = NULL; free( cparam ); cparam = NULL; close( pipefd ); close( ppool-&gt;epollfd ); } static int parent_signal_handle( processpool *ppool, char *signals, int signals_num ) { int i = 0, j = 0; for ( ; i &lt; signals_num; i++ ) { switch( signals[i] ) { case SIGCHLD: { PRINTINFO( LEVEL0, &quot;parent receive SIGCHLD signal&quot; ); pid_t pid; int stat; while ( (pid = waitpid(-1, &amp;stat, WNOHANG)) &gt; 0 ) { PRINTINFO( LEVEL0, &quot;parent receive SIGCHLD signal(pid:%d)&quot;, pid ); for ( j = 0; j &lt; ppool-&gt;cur_process_num; j++ ) { if ( ppool-&gt;sub_process[j].pid == pid ) { PRINTINFO( LEVEL3, &quot;child process(%d) exit.&quot;, pid ); close( ppool-&gt;sub_process[j].pipefd[1] ); ppool-&gt;sub_process[j].pid = -1; } } } ppool-&gt;stop = 1; for ( j = 0; j &lt; ppool-&gt;cur_process_num; j++ ) { PRINTINFO( LEVEL0, &quot;pid:%d&quot;, ppool-&gt;sub_process[j].pid ); if ( ppool-&gt;sub_process[j].pid != -1 ) { ppool-&gt;stop = 0; break; } } break; } case SIGTERM: case SIGINT: { PRINTINFO( LEVEL2, &quot;recv SIGINT/SIGTERM, kill all child process now.&quot; ); //PRINTINFO( LEVEL0, &quot;cur_process_num:%d&quot;, ppool-&gt;cur_process_num ); for ( i = 0; i &lt; ppool-&gt;cur_process_num; i++ ) { int pid = ppool-&gt;sub_process[i].pid; if ( pid != -1 ) { PRINTINFO( LEVEL0, &quot;kill process:%d&quot;, pid ); ppool-&gt;sub_process[i].pid = -1; kill( pid, SIGTERM ); } } ppool-&gt;stop = 1; break; } default: { break; } } } } static void run_parent( processpool *ppool ) { if ( !ppool ) { PRINTINFO( LEVEL4, &quot;ppool is null!!!&quot; ); return; } init_signal( ppool ); ppool-&gt;epollfd = Epoll_create( 5 ); Epoll_add_fd( ppool-&gt;epollfd, ppool-&gt;listenfd ); Epoll_add_fd( ppool-&gt;epollfd, sig_pipefd[1] ); struct epoll_event *events = NULL; events = (struct epoll_event *) calloc( sizeof(struct epoll_event), ppool-&gt;max_epoll_event ); if ( !events ) { PRINTINFO( LEVEL5, &quot;calloc error!!!&quot; ); char sig = SIGINT; parent_signal_handle( ppool, &amp;sig, 1 ); goto _free_source; } int event_num; int i, onebyte = 1, ret, j; //p_idx specifies current dispatched child process. //roll_index specifies the next child process. int p_idx , roll_index = 0; //PRINTINFO( LEVEL0, &quot;epollfd:%d&quot;, ppool-&gt;epollfd ); while ( !ppool-&gt;stop ) { //Specifying a timeout of -1 causes epoll_wait() //to block indefinitely. event_num = Epoll_wait( ppool-&gt;epollfd, events, ppool-&gt;max_epoll_event, -1 ); if ( event_num &lt; 0 &amp;&amp; errno != EINTR ) { PRINTINFO_ERR( LEVEL5, &quot;Epoll_wait error!!!&quot; ); ppool-&gt;stop = 1; break; } //PRINTINFO( LEVEL0, &quot;event_num:%d&quot;, event_num ); for ( i = 0; i &lt; event_num; i++ ) { int event_fd = events[i].data.fd; //listenfd,there is a new client connection. //notify child process to accept if ( event_fd == ppool-&gt;listenfd ) { PRINTINFO( LEVEL0, &quot;event:parent listenfd&quot; ); //round robin dispatch //easily roll polling p_idx = roll_index; do { if ( ppool-&gt;sub_process[p_idx].pid != -1 ) { break; } p_idx = ( p_idx + 1 ) % ppool-&gt;cur_process_num; } while ( p_idx != roll_index ); //roll polling all the child process,but they are //all run error.so p_idx equals to roll_index. if ( ppool-&gt;sub_process[p_idx].pid &lt; 0 ) { ppool-&gt;stop = 1; break; } roll_index = ( p_idx + 1 ) % ppool-&gt;cur_process_num; if ( Send( ppool-&gt;sub_process[p_idx].pipefd[0], (char *)&amp;onebyte, 1, 0 ) &lt; 0 ) { PRINTINFO( LEVEL5, &quot;Send error!!!&quot; ); ppool-&gt;stop = 1; break; } } //receive signal from signal handler. else if ( (event_fd == sig_pipefd[1]) &amp;&amp; (events[i].events &amp; EPOLLIN) ) { PRINTINFO( LEVEL0, &quot;event:parent receive signal&quot; ); int sig; char signals[1024]; ret = recv( sig_pipefd[1], signals, sizeof(signals), 0 ); if ( ret &lt;= 0 ) { continue; } else { parent_signal_handle( ppool, signals, ret ); } } } } _free_source: free( events ); events = NULL; close( ppool-&gt;epollfd ); } void run( processpool *ppool ) { if ( ppool-&gt;index != -1 ) { run_child( ppool ); return; } run_parent( ppool ); } client_handle.h: #ifndef _CLIENT_HANDLE_H #define _CLIENT_HANDLE_H #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/socket.h&gt; #include &lt;sys/types.h&gt; #include &lt;arpa/inet.h&gt; #define MAXRECVBUF 1024 typedef struct client_param { //用于recv返回出错移除sockfd int epollfd; int sockfd; struct sockaddr_in addr; char buf[ MAXRECVBUF ]; } client_param; void client_param_init( client_param *cparam, int connfd, struct sockaddr_in *addr ); void client_handle( client_param *cparam ); #endif client_handle.c: #include &quot;client_handle.h&quot; #include &quot;util.h&quot; void client_param_init( client_param *cparam, int connfd, struct sockaddr_in *addr ) { if ( !cparam ) { PRINTINFO( LEVEL4, &quot;cparam is null!!!&quot; ); return; } cparam-&gt;sockfd = connfd; memcpy( &amp;cparam-&gt;addr, addr, sizeof(struct sockaddr_in) ); memset( cparam-&gt;buf, 0, sizeof(cparam-&gt;buf) ); } void client_handle( client_param *cparam ) { int i, ret; while ( 1 ) { memset( cparam-&gt;buf, 0, sizeof(cparam-&gt;buf) ); ret = recv( cparam-&gt;sockfd, cparam-&gt;buf, sizeof(cparam-&gt;buf), 0 ); if ( ret &lt; 0 ) { if ( errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK &amp;&amp; errno != EINTR ) { Epoll_del_fd( cparam-&gt;epollfd, cparam-&gt;sockfd ); } close( cparam-&gt;sockfd ); break; } else if ( 0 == ret ) { Epoll_del_fd( cparam-&gt;epollfd, cparam-&gt;sockfd ); close( cparam-&gt;sockfd ); break; } else { if ( ret &lt; 15 ) { close( cparam-&gt;sockfd ); break; } //PRINTINFO( LEVEL0, &quot;child receive buf:\\n%s&quot;, cparam-&gt;buf ); fflush(stdout); char *p_get = strstr( cparam-&gt;buf, &quot;GET&quot; ); if ( !p_get ) { close( cparam-&gt;sockfd ); break; } char *p_http = strstr( cparam-&gt;buf, &quot;HTTP&quot; ); if ( !p_http ) { close( cparam-&gt;sockfd ); break; } cparam-&gt;buf[ret] = &apos;\\0&apos;; //GET filename HTTP/1.1 ..... char file_name[20] = {0}; int file_name_len = p_http - p_get - 6; memcpy( file_name, p_get + 5, file_name_len ); if ( access( file_name, F_OK ) == -1 ) { PRINTINFO( LEVEL3, &quot;file:(%s) dosen&apos;t exist!!&quot;, file_name ); Epoll_del_fd( cparam-&gt;epollfd, cparam-&gt;sockfd ); close( cparam-&gt;sockfd ); break; } PRINTINFO( LEVEL0, &quot;file name:%s--&quot;, file_name ); ret = fork(); if ( ret == -1 ) { Epoll_del_fd( cparam-&gt;epollfd, cparam-&gt;sockfd ); close( cparam-&gt;sockfd ); break; } else if ( ret &gt; 0 ) { Epoll_del_fd( cparam-&gt;epollfd, cparam-&gt;sockfd ); close( cparam-&gt;sockfd ); break; } else { close( STDOUT_FILENO ); //relocate the stdou to sockfd PRINTINFO( LEVEL0, &quot;sockfd:%d&quot;, cparam-&gt;sockfd ); dup( cparam-&gt;sockfd ); //printf(&quot;likun\\n&quot;); execl( file_name, file_name, NULL ); fflush(stdout); Epoll_del_fd( cparam-&gt;epollfd, cparam-&gt;sockfd ); close( cparam-&gt;sockfd ); exit( 0 ); } } } } cgisrv.c: #include &quot;myhshappool.h&quot; #include &quot;client_handle.h&quot; #include &quot;util.h&quot; #include &quot;epoll_wrapper.h&quot; //进程池最大数量 #define MAXPROCESSNUMBER 16 //每个进程支持客户连接任务 #define USERPERPROCESS 65535 //epool最大支持的监听事件数 #define MAXEPOLLEVENT 10000 processpool ppool; int main() { int listenfd = Socket_create( &quot;192.168.1.250&quot;, 8888 ); init_process_pool( &amp;ppool, MAXPROCESSNUMBER, USERPERPROCESS, MAXEPOLLEVENT, 5, listenfd ); run( &amp;ppool ); close( listenfd ); return 0; } 贴一下makefile： CC = gcc ROOTDIR = $(shell pwd) OBJ = util.o myhshappool.o epoll_wrapper.o \\ client_handle.o cgisrc.o BIN = cgisrv.bin CFLAG = -Wall -O2 -I./ LDFLAG += -c $(BIN):${OBJ} $(CC) $(CFLAG) -o $@ $^ %:%.c $(CC) $(CFLAG) -o $@ $&lt; $(LDFLAG) .PHONY:clean clean: rm $(OBJ) $(BIN) -rf 还有cgi执行程序： #include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;string.h&gt; /* &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;u&gt;&lt;font color=00ff00&gt;..&lt;/font&gt;&lt;/u&gt;&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; */ int main( int argc, char **argv ) { time_t tt = time(NULL); printf(&quot;&lt;!DOCTYPE html&gt;&quot;); printf(&quot;&lt;html&gt;&quot;); printf(&quot;&lt;head&gt;&quot;); printf(&quot;&lt;meta charset=\\&quot;utf-8\\&quot;&gt;&quot;); printf(&quot;&lt;title&gt;get now time&lt;/title&gt;&quot;); printf(&quot;&lt;/head&gt;&quot;); printf(&quot;&lt;body&gt;&quot;); printf(&quot;&lt;h1&gt;&lt;u&gt;&lt;font color=00ff00&gt;&quot;); printf(&quot;当前服务器时间:%s&quot;, ctime(&amp;tt)); printf(&quot;&lt;/font&gt;&lt;/u&gt;&lt;/h1&gt;&quot;); printf(&quot;&lt;/body&gt;&quot;); printf(&quot;&lt;/html&gt;&quot;); return 0; } 测试：代码编译了，即可执行cgisrv.bin，主进程处于监听客户端连接情况，打开浏览器输入: http://xxx.xxx.xxx.xxx:8888/now.cgi，可以看到出现一行加下划线的绿字：当前服务器时间:Sat Sep 17 21:49:07 2016。 ip、端口、进程池数、最大epoll监听事件数等在入口模块(cgisrv)可以改。 本例子写完，调试了几个地方，运行几个客户端发送get请求就没有做测试了，练手的玩具demo ^_^。","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"}]},{"title":"归并排序-《算法导论》学习笔记二","slug":"008merge-sort/index","date":"2018-06-15T10:40:26.000Z","updated":"2018-06-19T02:02:56.123Z","comments":true,"path":"2018/06/15/008merge-sort/index/","link":"","permalink":"http://yoursite.com/2018/06/15/008merge-sort/index/","excerpt":"","text":"算法导论第二章3小节讲到分治法，即将大问题化解为规模小一些的同类问题，这样先处理小问题，再合并两个小问题再解决，递归的思路。按照书上的伪代码，写了c算法。 #include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt; void merge( int *arr, int p, int q, int r ) { int arrlen = r - p + 1; int *tmparr = (int *)malloc( sizeof(int) * arrlen ); int i, j, k, tmp; for ( i = 0; i &lt; arrlen; i++ ) tmparr[i] = arr[i + p]; j = 0; k = q - p + 1; for ( i = p; i &lt; r + 1; i++ ) { if ( tmparr[j] &gt; tmparr[k] ) { arr[i] = tmparr[k]; k++; } else { arr[i] = tmparr[j]; j++; } if ( j == q - p + 1 || k == r - p + 1 ) { i++; break; } } for ( ; i &lt; r + 1; i++ ) { if ( j &lt; q - p + 1 ) { arr[i] = tmparr[j]; j++; continue; } if ( k &lt; r - p + 1 ) { arr[i] = tmparr[k]; k++; continue; } } free( tmparr ); tmparr = NULL; } void mergeSort( int *arr, int p, int r ) { int q; if ( p &lt; r ) { q = ( p + r ) / 2; mergeSort( arr, p, q ); mergeSort( arr, q + 1, r ); merge( arr, p, q, r ); } } void sortLoop0( int *arr, int len ) { mergeSort( arr, 0, len - 1 ); } //排序前后做时间对比，精度sec void sortLoop( int *arr, int len ) { time_t tt0 = time( NULL ); printf(&quot;\\tbefore sort:%s&quot;, ctime(&amp;tt0)); sortLoop0( arr, len ); time_t tt1 = time( NULL ); printf(&quot;\\tafter sort:%s&quot;, ctime(&amp;tt1)); printf(&quot;\\tsort the array cost %d(sec),%d(min)\\n&quot;, (int)(tt1 - tt0), (int)((tt1 - tt0) / 60)); } //初始化随机数组 void initArr( int *arr, int lowV, int upV, int len ) { srand( (int)time(NULL) ); int i = 0; int size = upV - lowV; for ( ; i &lt; len; i++ ) { arr[i] = rand() % size + lowV; } } //打印数组 void printArr( int *arr, int len ) { int i = 0; for ( ; i &lt; len; i++ ) printf(&quot;%d &quot;, arr[i]); printf(&quot;\\n&quot;); } //这里写了个简单得数组检查，检查是否 //是正确的递增序列(怕自己的代码没检查 //边界条件偶尔有错误的排序数组) int check_arr_increase( int *arr, int len ) { int i = 0; for ( ; i &lt; len - 1; i++ ) { if ( arr[i] &lt;= arr[i + 1] ) continue; else { printf(&quot;array isn&apos;t increase!!!\\n&quot;); return -1; } } printf(&quot;array is increase!!!!\\n&quot;); return 0; } int main( int argc, char **argv ) { if ( argc != 4 ) { printf(&quot;usage: ./execfile lowV upV len\\n&quot;); return 0; } int lowV = atoi( argv[1] ); int upV = atoi( argv[2] ); unsigned int len = atoi( argv[3] ); int *arr = NULL; arr = ( int *) malloc( len * sizeof(int) ); initArr( arr, lowV, upV, len ); //printArr( arr, len ); sortLoop( arr, len ); check_arr_increase( arr, len ); //printArr( arr, len ); free( arr ); arr = NULL; return 0; } 分治法的算法复杂度可以计算，效率是很恐怖的，排序取值10-1000000值长度1000万的数组用时4s： 排序取值10-1000000值长度1亿的数组用时85s：","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://yoursite.com/tags/数据结构-算法/"}]},{"title":"插入排序-《算法导论》学习笔记一","slug":"007insert-sort/index","date":"2018-06-15T10:37:04.000Z","updated":"2018-06-19T02:02:56.123Z","comments":true,"path":"2018/06/15/007insert-sort/index/","link":"","permalink":"http://yoursite.com/2018/06/15/007insert-sort/index/","excerpt":"","text":"算法导论第二章的第一小节是插入排序，也就是像打扑克牌整理扑克一样，从左边第二张开始，每张与前边排好序的扑克牌比较，比较到能插入的位置就插入，算法比较简单。 #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;time.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; void insert_sort0( int* arr, int idx ) { int i = idx - 2; int tmp = arr[idx]; arr[idx] = arr[idx - 1]; for ( ; i &gt;= 0; i-- ) { if ( arr[i] &gt; tmp ) arr[i + 1] = arr[i]; else { arr[i + 1] = tmp; break; } } if ( i &lt; 0 ) arr[0] = tmp; } int insert_sort( int* arr, int len) { time_t t_old, t_new; t_old = time(NULL); if ( arr[0] &gt; arr[1] ) { int tmp = arr[0]; arr[0] = arr[1]; arr[1] = tmp; } int i = 1; for ( ; i + 1&lt; len; i++ ) { if ( arr[i + 1] &lt; arr[i] ) { insert_sort0( arr, i + 1 ); } } t_new = time(NULL); return (int)(t_new - t_old); } void sortLoop0( int *arr, int len ) { insert_sort( arr, len ); } //排序前后做时间对比，精度sec void sortLoop( int *arr, int len ) { time_t tt0 = time( NULL ); printf(&quot;\\tbefore sort:%s&quot;, ctime(&amp;tt0)); sortLoop0( arr, len ); time_t tt1 = time( NULL ); printf(&quot;\\tafter sort:%s&quot;, ctime(&amp;tt1)); printf(&quot;\\tsort the array cost %d(sec),%d(min)\\n&quot;, (int)(tt1 - tt0), (int)((tt1 - tt0) / 60)); } //初始化随机数组 void initArr( int *arr, int lowV, int upV, int len ) { srand( (int)time(NULL) ); int i = 0; int size = upV - lowV; for ( ; i &lt; len; i++ ) { arr[i] = rand() % size + lowV; } } //打印数组 void printArr( int *arr, int len ) { int i = 0; for ( ; i &lt; len; i++ ) printf(&quot;%d &quot;, arr[i]); printf(&quot;\\n&quot;); } //这里写了个简单得数组检查，检查是否 //是正确的递增序列(怕自己的代码没检查 //边界条件偶尔有错误的排序数组) int check_arr_increase( int *arr, int len ) { int i = 0; for ( ; i &lt; len - 1; i++ ) { if ( arr[i] &lt;= arr[i + 1] ) continue; else { printf(&quot;array isn&apos;t increase!!!\\n&quot;); return -1; } } printf(&quot;array is increase!!!!\\n&quot;); return 0; } int main( int argc, char **argv ) { if ( argc != 4 ) { printf(&quot;usage: ./execfile lowV upV len\\n&quot;); return 0; } int lowV = atoi( argv[1] ); int upV = atoi( argv[2] ); unsigned int len = atoi( argv[3] ); int *arr = NULL; arr = ( int *) malloc( len * sizeof(int) ); initArr( arr, lowV, upV, len ); //printArr( arr, len ); sortLoop( arr, len ); check_arr_increase( arr, len ); //printArr( arr, len ); free( arr ); arr = NULL; return 0; } 我的ubuntu虚拟机环境是双核3代i5,2G内存，排序10-100000的随机10万的数组如下情况： 如果是100万的数组，耗时10几分钟；如果是1000万的数组，挂着跑了一晚上都没排好序。 对插入排序的一点思考：在写排序的时候想到当前数可以从排好序数组后往前比较，也可以从前往后比较，前一种比较一个不符合即可将比较的数组值后移一位，给待插入值让位，这样就在比较重顺便后移，如果是后一种比较插入方法，则是遍历排好序数组，直到找到符合的索引位置，将位置后边的数组后移，这样相当于每次都要遍历一遍排好序数组，因此不用此方法。","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://yoursite.com/tags/数据结构-算法/"}]},{"title":"C时间堆","slug":"006time-heap/index","date":"2018-06-15T07:46:30.000Z","updated":"2018-06-19T02:02:56.115Z","comments":true,"path":"2018/06/15/006time-heap/index/","link":"","permalink":"http://yoursite.com/2018/06/15/006time-heap/index/","excerpt":"","text":"跟上一篇，这里写一下时间堆： 时间轮的滴答是固定以指定的槽间隔触发，而时间堆是以定时器堆中的最小到期时间做定时，也就是alarm(minTimeout)，一旦定时器被触发，那么就删除此定时器，更新时间堆，将新的最小到期时间定时器作为新的定时。 然后是时间堆的数据结构，这里用了二叉树，将二叉树的根节点作为最小最小到期时间，每次滴答就取根节点，并且是完全二叉树，因此比较容易理解，我也懒得画图了，截了书上的图： 从图中可以看到，对时间堆的关键操作其实就是上滤和下滤，上滤也就是简单的将完全二叉树待添加的定时器最为最后一个节点并与父节点比较，如果小于，则交换两节点位置，再将此节点与父节点比较，直到待插入节点值大于父节点值或者已经是根节点即停止；下滤就是触发一个定时器之后删除此定时器，然后取完全二叉树的深度最大一排的最后一个叶子节点作为根节点，然后用此根节点与两个儿子节点比较，若根节点值大于儿子节点中最大者，则交换这两个节点，再以这个节点做同样的下滤，如果对于任意完全二叉树，这样简单的下滤不能找出最小节点，但是配合定时器添加时的上滤操作后的完全二叉树，这样就可行。 下面贴自己改的代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;signal.h&gt; #include &lt;time.h&gt; typedef struct client_data { char buf[512]; time_t tt; void* data; } client_data; typedef struct heap_timer { //单个定时器设置绝对时间 time_t expire; //加的设置的定时器到时秒数 int timeout; //到时回调函数 void (*cb_func)( void* ); //回调函数参数 struct client_data* user_data; } heap_timer ; typedef struct h_t_manager { //定时器指针数组 struct heap_timer** array; //当前定时管理器支持的最大定时器个数 int capacity; //当前定时管理器上的定时器个数 int cur_size; } h_t_manager ; void cb_func( void* param ) { time_t tt = time(NULL); printf(&quot;\\n-----------------------------------------------\\n&quot;); printf(&quot;\\tontime,cur time - old time:%d\\n&quot;, (int)(tt - ((client_data*)param)-&gt;tt)); printf(&quot;\\toldtime:%s&quot;, ctime(&amp;(((client_data*)param)-&gt;tt))); printf(&quot;\\tcurtime:%s&quot;, ctime(&amp;tt)); printf(&quot;-----------------------------------------------\\n&quot;); } static void percolate_down( h_t_manager* tmanager, int hole ) { heap_timer* temp = tmanager-&gt;array[hole]; int flag = 0; int child = 0; for ( ; ((hole*2+1) &lt;= (tmanager-&gt;cur_size-1)); hole = child ) { flag = 0; child = hole * 2 + 1; //这里找出当前节点最小儿子节点 if ( (child &lt; (tmanager-&gt;cur_size-1)) &amp;&amp; (tmanager-&gt;array[child+1]-&gt;expire) &lt; tmanager-&gt;array[child]-&gt;expire ) { ++child; } //比较待删除节点和最小儿子节点，若大于就交换 if ( tmanager-&gt;array[child]-&gt;expire &lt; temp-&gt;expire ) { //这里的交换其实该用内存拷贝比较好 int tmp_expire = tmanager-&gt;array[hole]-&gt;expire; int tmp_timeout = tmanager-&gt;array[hole]-&gt;timeout; tmanager-&gt;array[hole]-&gt;expire = tmanager-&gt;array[child]-&gt;expire; tmanager-&gt;array[hole]-&gt;timeout = tmanager-&gt;array[child]-&gt;timeout; tmanager-&gt;array[child]-&gt;expire = tmp_expire; tmanager-&gt;array[child]-&gt;timeout = tmp_timeout; } else { break; } //新的下滤比较 temp = tmanager-&gt;array[child]; //tmanager-&gt;array[hole] = temp; } } //将堆数组的容量扩大1倍 static int resize( h_t_manager* tmanager ) { heap_timer** temp = (heap_timer**) malloc( 2 * tmanager-&gt;capacity * sizeof(h_t_manager) ); int i = 0; for ( ; i &lt; 2 * tmanager-&gt;capacity; ++i ) { temp[i] = NULL; } if ( !temp ) { return -1; } tmanager-&gt;capacity = 2 * tmanager-&gt;capacity; for ( i = 0; i &lt; tmanager-&gt;cur_size; ++i ) { temp[i] = tmanager-&gt;array[i]; free(tmanager-&gt;array[i]); tmanager-&gt;array[i] = NULL; } tmanager-&gt;array = temp; return 0; } int init_ht_manager_0( h_t_manager* tmanager, int cap ) { tmanager-&gt;capacity = cap; tmanager-&gt;cur_size = 0; tmanager-&gt;array = (heap_timer**)malloc(cap * sizeof(h_t_manager)); int i = 0; for ( ; i &lt; cap; ++i ) { tmanager-&gt;array[i] = NULL; } } //添加定时器 int add_timer( h_t_manager* tmanager, int timeout ) { if ( !tmanager || timeout &lt;= 0) { return -1; } if ( tmanager-&gt;cur_size &gt;= tmanager-&gt;capacity ) { resize( tmanager ); } int hole = tmanager-&gt;cur_size++; int parent = 0; heap_timer* timer = (heap_timer*)malloc(sizeof(heap_timer)); time_t tt = time(NULL); timer-&gt;expire = (int)tt + timeout; timer-&gt;timeout = timeout; timer-&gt;user_data = (client_data*)malloc(sizeof(client_data)); timer-&gt;user_data-&gt;tt = time(NULL); timer-&gt;cb_func = cb_func; for ( ; hole &gt; 0; hole = parent ) { parent = ( hole - 1 ) / 2; if ( tmanager-&gt;array[parent]-&gt;expire &lt;= timer-&gt;expire ) { break; } tmanager-&gt;array[hole] = tmanager-&gt;array[parent]; } tmanager-&gt;array[hole] = timer; return 0; } int del_timer( h_t_manager* tmanager, heap_timer* timer ) { if ( !tmanager || !timer ) { return -1; } timer-&gt;cb_func = NULL; } int empty( h_t_manager* tmanager ) { return tmanager-&gt;cur_size == 0; } heap_timer* top( h_t_manager* tmanager ) { if ( empty(tmanager) ) { printf(&quot;!!!!!!!top-&gt;empty cur size\\n&quot;); return NULL; } return tmanager-&gt;array[0]; } int pop_timer( h_t_manager* tmanager ) { if ( empty( tmanager ) ) { printf(&quot;!!!!!!!pop_timer-&gt;empty cur size\\n&quot;); return -1; } if ( tmanager-&gt;array[0] ) { free( tmanager-&gt;array[0] ); tmanager-&gt;array[0] = NULL; tmanager-&gt;array[0] = tmanager-&gt;array[--tmanager-&gt;cur_size]; percolate_down( tmanager, 0 ); } return 0; } void tick( h_t_manager* tmanager ) { heap_timer* tmp = tmanager-&gt;array[0]; time_t cur = time( NULL ); while ( !empty(tmanager) ) { if ( !tmp ) { break; } if ( tmp-&gt;expire &gt; cur ) { break; } if ( tmanager-&gt;array[0]-&gt;cb_func ) { printf(&quot;timer on time,heap:&quot;); int i = 0; for ( ; i &lt; 10; i++ ) { if ( tmanager-&gt;array[i] ) printf(&quot;%d:%d &quot;, i, tmanager-&gt;array[i]-&gt;timeout); } tmanager-&gt;array[0]-&gt;cb_func( tmanager-&gt;array[0]-&gt;user_data ); } pop_timer( tmanager ); tmp = tmanager-&gt;array[0]; printf(&quot;after timer on time,heap:&quot;); int i = 0; for ( ; i &lt; 10; i++ ) { if ( tmanager-&gt;array[i] ) printf(&quot;%d:%d &quot;, i, tmanager-&gt;array[i]-&gt;timeout); } printf(&quot;\\n&quot;); if ( tmanager-&gt;array[0] ) printf(&quot;the next alarm is:%d\\n&quot;, (int)(tmanager-&gt;array[0]-&gt;timeout)); printf(&quot;current timer count:%d\\n&quot;, tmanager-&gt;cur_size); } } h_t_manager tmanager; void alarm_handler( int sig ) { tick( &amp;tmanager ); alarm( tmanager.array[0]-&gt;expire - time(NULL) ); } int main() { printf(&quot;start timer 。。。。。。。\\n&quot;); init_ht_manager_0( &amp;tmanager, 20 ); add_timer( &amp;tmanager, 11 ); add_timer( &amp;tmanager, 5 ); add_timer( &amp;tmanager, 11 ); // add_timer( &amp;tmanager, 22 ); add_timer( &amp;tmanager, 6 ); add_timer( &amp;tmanager, 9 ); // add_timer( &amp;tmanager, 23 ); // add_timer( &amp;tmanager, 33 ); // add_timer( &amp;tmanager, 28 ); // add_timer( &amp;tmanager, 1 ); // add_timer( &amp;tmanager, 66 ); // add_timer( &amp;tmanager, 77 ); // add_timer( &amp;tmanager, 88 ); // add_timer( &amp;tmanager, 55 ); signal( SIGALRM, alarm_handler ); time_t tt = time(NULL); printf(&quot;current time:%s&quot;, ctime(&amp;tt)); alarm( tmanager.array[0]-&gt;expire - time(NULL) ); while(1) sleep(5); return 0; } 因为用的完全二叉树，比较简单，跟上一篇时间轮一样，存在注意某些使用问题，整理的时候发现时间堆代码的注释还没写，想着自己加一点，发现很久前写的代码了，有点忘了，加了点也困了，打完羽毛球回来又连撸两篇博客 ，还被蚊子咬，一挠还挠死个咬得比我写博客还专注的蚊子 ，醉了 ~","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"}]},{"title":"C时间轮","slug":"005time-wheel/index","date":"2018-06-15T07:41:11.000Z","updated":"2018-06-19T02:02:56.087Z","comments":true,"path":"2018/06/15/005time-wheel/index/","link":"","permalink":"http://yoursite.com/2018/06/15/005time-wheel/index/","excerpt":"","text":"看完了《linux高性能服务器编程》对里面的定时器很感兴趣。书中提到三种定时器，分别是：基于升序链表的定时器，基于时间轮的定时器，基于时间堆的定时器。三种定时器的实现书中均是给了C++代码，不过我对C++不太感兴趣，虽然现在在做C++开发，因此写了C版本的。书中定时器只给了封装的定时器类，没有给调用层代码，我是估摸着写了调用层代码。这里做个总结，以后可以翻翻： 基于升序链表的定时器没太大难度，因此也懒得总结了。 说一下时间轮，下面是截的书中的图片： 时间轮，像轮子一样滚动定时，每滚一个刻度，指针就走一个滴答，滚完一圈，就进入下一圈。因此有了这个概念，时间轮的结构也就出来了：1.齿轮（槽slot），用来标识一个滴答；2.槽间隔（slot interval ），当前槽经过多长时间到下一个槽；3.一圈的槽数量（N）；4.当前指针，走一个滴答加一，走完一圈又回到初始位置。 再深入一点，定时器以什么方式添加到槽上？可以看图，每一个槽其实就是一个链表头结点，定时器即添加到所属槽的链表后。这样我们可以对时间轮性能进行分析，SI越小，定时精度越高，如果SI=10s，那么我们指定的定时器只能是10s的倍数；如果N越大，定时器效率越高，这也很好理解，N越小，一圈槽数量越少，那么我们同样添加100个定时器，分配到每个头结点的定时器越多，每一次滴答到时，就遍历当前槽，遍历一次所花时间越多。 如何确定定时器位置？根据定时器到时时间可以计算，例如：定时器超时时间timeout=21s(即21s后触发定时器)，当前间隔SI=2s，一圈槽数量N=70，当前指针cur_slot指向第5个槽，我们可以计算出定时器放置的位置，这里需要两个变量，一个rotation指定定时器处于第几圈，一个slot指定定时器处于第几个槽，因此slot = ( cur_slot + timeout / SI ) % N = 15, rotation = timeout / SI / N = 0，即此定时器被放置于15槽的链表后，至于是链表头插还是尾插这个随意，指针滴答到了15槽即触发15槽到时，遍历15槽链表，若rotation=0的表示为当前该触发定时器，若rotation&gt;0的定时器对rotation–（其实很好理解，cur_slot在转当前轮，则不处理后面的轮，只对它的rotation减一就跳过，等到cur_slot转下一圈再判断此定时器）。根据这个计算，如果其它参数不变，现在有一个timeout=161s的定时器，cur_slot=5,我们可以计算出这个定时器的slot=15，rotation=1，正好处于第15槽，但是是下一转触发该触发。 也就是说，如果我们根据以上参数，同时添加一个15s和一个161s定时器，他们都会随时间轮轮转触发到，只不过指针第一次只想15槽时，判断15s的定时器rotation为0，则触发定时器，然后删除定时器，遍历到161s定时器时，rotation=1，执行减1，跳过继续轮转，当cur_slot=70的时候也就是时间轮走过652=130s时，时间轮转一圈，cur_slot=0，继续下一圈开始，再走过142=28s后，到达15槽，判断161s定时器，rotation=0，触发定时器。 有了这些分析，下面直接贴代码： #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;time.h&gt; #include &lt;unistd.h&gt; #include &lt;signal.h&gt; #include &lt;stdlib.h&gt; typedef struct client_data { int fd; time_t tt; char buf[512]; void* data; }client_data; typedef struct tw_timer { //处于时间轮第几转，即时间轮转多少转 //此定时器可以处于当前转，若再加上槽 //即可确定此定时器所处时间轮位置 int rotation; //处于当前时间轮转的第几个槽 int slot; //定时器到时执行的回调函数 void* (*cb_func)( void* param ); //用户数据，触发回调任务函数的参数 struct client_data c_data; //这里只需要单向不循环链表即可 //struct tw_timer* prev; struct tw_timer* next; }tw_timer; typedef struct timer_manager { //时间轮当前槽，每经过一个间隔时间，加一实现轮转动， //超过总槽数即归零表示当前轮转完 int cur_slot; //时间轮一转的总槽数，总槽数越大槽链表越短，效率越高 int slot_num_r; //相邻时间槽间隔时间，即时间轮转到下一个槽需要时间， //间隔时间越短，精度越高，例如10s，表示定时器支持10s //间隔定时器添加，最小支持1s int slot_interval; //每个时间槽链表头结点，即一个槽管理一条链表，链表 //添加相同槽数的结点，但转数可能不同 struct tw_timer* slots_head[512]; }timer_manager; timer_manager tmanager; void* ontime_func( void* param ) { client_data* data = (client_data*)param; time_t tt = time(NULL); printf(&quot;\\n----------------------------------------------------\\n&quot;); printf(&quot;\\tontime,interval:%d\\n&quot;, (int)(tt - data-&gt;tt)); printf(&quot;\\told time:%s&quot;, ctime(&amp;data-&gt;tt)); printf(&quot;\\t%s&quot;, data-&gt;buf); printf(&quot;\\tcur time:%s&quot;, ctime(&amp;tt)); //getchar(); printf(&quot;----------------------------------------------------\\n&quot;); return NULL; } int add_timer( timer_manager* tmanager, int timeout, client_data* c_data ) { if ( timeout &lt; 0 || !tmanager ) return -1; int tick = 0; //转动几个槽触发 int rotation = 0; //处于时间轮第几转 int slot = 0; //距离当前槽相差几个槽 if ( timeout &lt; tmanager-&gt;slot_interval ) tick = 0; else tick = timeout / tmanager-&gt;slot_interval; rotation = tick / tmanager-&gt;slot_num_r; slot = ( tmanager-&gt;cur_slot + tick % tmanager-&gt;slot_num_r ) % tmanager-&gt;slot_num_r - 1; printf(&quot;addtimer--&gt;timeout:%d, rotation:%d,slot:%d\\n&quot;, timeout, rotation, slot); tw_timer* tmp_t = (tw_timer*)malloc(sizeof(tw_timer)); tmp_t-&gt;rotation = rotation; char buf[100] = {0}; time_t tt = time(NULL) + timeout; sprintf( buf, &quot;set time:%s&quot;, ctime(&amp;tt)); memset( tmp_t-&gt;c_data.buf, 0, sizeof(tmp_t-&gt;c_data.buf)); strcpy( tmp_t-&gt;c_data.buf, buf ); tmp_t-&gt;slot = slot; tmp_t-&gt;c_data.tt = time(NULL); tmp_t-&gt;cb_func = ontime_func; if ( !tmanager-&gt;slots_head[slot] ) { tmanager-&gt;slots_head[slot] = tmp_t; tmp_t-&gt;next = NULL; //printf(&quot;[line]:%d\\n&quot;, __LINE__); return 0; } //printf(&quot;[line]:%d\\n&quot;, __LINE__); tmp_t-&gt;next = tmanager-&gt;slots_head[slot]-&gt;next; tmanager-&gt;slots_head[slot]-&gt;next = tmp_t; return 0; } int del_all_timer( timer_manager* tmanager ) { //清除、释放所有定时器，懒得写了 } int tick( timer_manager* tmanager ) { if ( !tmanager ) return -1; tw_timer* tmp = tmanager-&gt;slots_head[tmanager-&gt;cur_slot]; tw_timer* p_tmp; while ( tmp ) { //rotation减一，当前时间轮转不起作用 //假设这个tmp指向第0个槽的头，链中某个结点的rotaion为下一圈， //即rotation=1，所以这个定时器不起作用，而因为cur_slot不断 //走动，tmp在当前转不可能再指向这个定时器，下一圈cur_slot //为0时能继续判断这个定时器，故实现了定时器处于不同转的判断 if ( tmp-&gt;rotation &gt; 0 ) { tmp-&gt;rotation--; p_tmp = tmp; tmp = tmp-&gt;next; } else { //否则定时器到时，触发回调函数 tmp-&gt;cb_func( &amp;tmp-&gt;c_data ); //删除此定时器结点 //吃了没用双向链表的亏，写这么low if ( tmp == tmanager-&gt;slots_head[tmanager-&gt;cur_slot] ) { //printf(&quot;[line]:%d\\n&quot;, __LINE__); tmanager-&gt;slots_head[tmanager-&gt;cur_slot] = tmp-&gt;next; p_tmp = tmp; tmp = tmp-&gt;next; free( p_tmp ); p_tmp = NULL; p_tmp = tmp; //printf(&quot;[line]:%d\\n&quot;, __LINE__); } else { p_tmp-&gt;next = p_tmp-&gt;next-&gt;next; free( tmp ); tmp = NULL; tmp = p_tmp-&gt;next; } } } //更新时间轮，转动一个槽，转一圈又从开始转 tmanager-&gt;cur_slot = ++tmanager-&gt;cur_slot % tmanager-&gt;slot_num_r; return 0; } int init_t_manager( timer_manager* tmanager, int slot_num_r, int slot_interval ) { tmanager-&gt;cur_slot = 0; tmanager-&gt;slot_num_r = slot_num_r; tmanager-&gt;slot_interval = slot_interval; return 0; } //自己试着写的调用层代码 void alarm_handler( int sig ) { time_t tt = time(NULL); //printf(&quot;timer tick:%s&quot;, ctime(&amp;tt)); int ret = tick( &amp;tmanager ); if ( ret &lt; 0 ) printf(&quot;tick error\\n&quot;); alarm( tmanager.slot_interval ); } int main() { time_t tt = time(NULL); signal( SIGALRM, alarm_handler ); //init_t_manager( &amp;tmanager, 60, 10 ); init_t_manager( &amp;tmanager, 60, 1 ); add_timer( &amp;tmanager, 6, NULL ); add_timer( &amp;tmanager, 11, NULL ); add_timer( &amp;tmanager, 22, NULL ); add_timer( &amp;tmanager, 33, NULL ); add_timer( &amp;tmanager, 44, NULL ); add_timer( &amp;tmanager, 55, NULL ); add_timer( &amp;tmanager, 66, NULL ); add_timer( &amp;tmanager, 77, NULL ); add_timer( &amp;tmanager, 88, NULL ); add_timer( &amp;tmanager, 99, NULL ); add_timer( &amp;tmanager, 111, NULL ); add_timer( &amp;tmanager, 122, NULL ); add_timer( &amp;tmanager, 133, NULL ); add_timer( &amp;tmanager, 144, NULL ); printf(&quot;start time:%s\\n&quot;, ctime(&amp;tt)); alarm( tmanager.slot_interval ); while ( 1 ) sleep( 5 ); return 0; } 看以上代码，main函数开始即指定了SI=1s，N=60，并添加了很多定时器，然后开始以SI执行定时，每一次到时就触发滴答函数tick()，如此循环定时触发到时信号就实现了时间轮轮转。 关于代码的思考：这里用了SIGALRM信号，每一次到时，主线程暂停，去执行信号函数内容，如果信号SIGALRM的处理函数太庞大，会影响主线程的任务卡顿，虽然以上代码执行量不大，但为了扩展，我觉得可以将定时器触发执行的操作改为添加任务结点到任务链，这样配合线程池效率会高一点，线程池本身会从任务链取任务结点执行，如果我们的定时处理函数只是往任务链放任务，那性能会高很多，而不是往cb_func里执行具体业务逻辑。 下一篇上时间堆。","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"}]},{"title":"Linux daemon守护进程的创建","slug":"004deamon/index","date":"2018-06-14T13:31:50.000Z","updated":"2018-06-19T02:02:56.055Z","comments":true,"path":"2018/06/14/004deamon/index/","link":"","permalink":"http://yoursite.com/2018/06/14/004deamon/index/","excerpt":"","text":"今天在看《UNIX网络编程》的时候，看到了守护进程的创建，代码中fork了两次，并且第一次fork后对子进程调用setsid()，有些懵。当时搜了下setsid也是看得有点云里雾里。后来折腾了一下午，才算有点明白，这里把自己的一点分析心得写上来，以后忘了可以翻翻： 这里我用ssh登陆ubuntu，在终端用vim编写。 第一次fork我们先写一个简单的代码来fork并创建一个后台程序，代码如下： //testdaemon1.c #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;signal.h&gt; int main() { pid_t pid; if ( (pid = fork()) &lt; 0 ) return -1; else if ( pid ) exit( 0 ); signal( SIGHUP, SIG_IGN ); int i = 10; while ( i-- ) sleep( 5 ); return 0; } 编译gcc -o testdaemon1 testdaemon1.c运行./testdaemon1 然后我们用ps查看程序:ps axjf | grep testdaemon1 1 28511 28510 28168 pts/18 28168 S 0 0:00 ./testdaemon1 这里看第二列是进程id(28511)，第四列是sessionId(28168)，第五列是控制终端(pts/18)，代码中子进程fork而来，会默认继承父进程的控制终端以及会话组。而如果我们查看linux后台守护进程的话，会发现进程控制终端为“？”，因此这个代码距离标准的守护进程还有距离，后面逐一分析。 什么是会话session呢？我大概的理解就是linux下进程组织结构分很多会话，一个会话有很多进程，会话的首进程会有一个控制终端，一个会话只能有一个控制终端。而我们现在用ssh登陆ubuntu创建了一个会话，此会话首进程id号就是28168,如果我们运行ps aux | grep 28168会输出下面值: root 28168 0.0 0.4 6904 4640 pts/18 Ss+ 16:06 0:00 -bash 可以看到这个进程是 bash进程shell终端，其控制终端是pts/18，此后我们在此终端运行的进程都属于以这个首进程id为sessionId的会话组，我们可以运行一个后台的top程序:top &amp;ps axjf | grep top得到下面输出： 28168 28670 28670 28168 pts/18 28672 T 0 0:00 _ top 再看28168的会话组： ps axjf | grep 28168得到下面输出： 28141 28168 28168 28168 pts/18 28693 Ss 0 0:00 _ -bash 28168 28670 28670 28168 pts/18 28693 T 0 0:00 _ top 28168 28693 28693 28168 pts/18 28693 R+ 0 0:00 _ ps axjf 28168 28694 28693 28168 pts/18 28693 S+ 0 0:00 _ grep –color=auto 28168 1 28691 28690 28168 pts/18 28693 S 0 0:00 ./testdaemon1 可以看到运行的几个后台程序sid都是28168。 说了这么多，这个会话组有什么作用呢？我们就要提到SIGHUP信号了，SIGHUP信号会在终端关闭时或者会话首进程退出时发送给会话组的其它进程，当其它进程收到此信号时如果不捕获或者忽略信号的话，默认会退出。如果现在点击ssh窗口的×关闭终端界面或者kill -9 28618的话，下面所属的进程都会退出。 因此，我们在代码中要调用setsid()，将子进程与父进程会话分离、终端分离，我们加入setsis再编译执行： ./testdaemon1执行ps axjf | grep testdaemon1 1 28891 28891 28891 ? -1 Ss 0 0:00 ./testdaemon1 看到其所属会话组已经变成新的（它自己为首进程）会话组，而终端也变为？，这正是我们看linux下其他守护进程的状态。 第二次fork第一次fork还不够，因为我们setsid之后，第一子进程变为新会话首进程，它有权限重新申请打开一个终端，为了避免这种情况，可以通过使进程不再成为会话组长来禁止进程重新打开控制终端，这就需要第二次调用fork()函数 改变工作路径第二次fork之后，我们在第二子进程里可以进行一些守护进程属性设置了， 改变工作路径可以用chdir(“/”)，为什么要改变工作路径呢？《unix网络编程》中Stevens大神说得很清楚，这里搬过来“守护进程可能是在某个任意的文件系统中启动，如果仍然在其中，那么该文件系统就无法拆卸(unmounting)，除非使用潜在的破坏性的强制措施。” 关闭所有打开的文件描述符守护进程从执行它的进程(当前的shell)继承所有打开的描述符。但没有现成的函数提供来检测打开的文件描述符，Stevens大神的解决办法是关闭前64个，而我在网上找到的有用getdtablesize()，有用NOFILE宏(sys/param.h)的，我的ubuntu前者为1024，后者为256，也不想去深究了。 重定向stdin、stdout、stderr上一步关闭了0开始的描述符，而stdin stdout stderr分别对应0 1 2，因此关闭之后如果不进行重定向，守护进程分配文件描述符会从0开始，因此stevens大神打开/dev/null三次，分配了三次描述符，分别为012，都对应/dev/null #贴上整个代码吧（跟《UNIX网络编程》里代码有些出入，某些东西也懒得深究了）： #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;signal.h&gt; int main() { pid_t pid; //原代码的fork用的封装函数Fork，其实多了对fork查错 if ( (pid = fork()) &lt; 0 ) return -1; else if ( pid ) exit( 0 ); setsid(); //原代码用的封装函数Sianal，这里懒得写了 //父进程退出，会给所有子进程发一个SIGHUP信号，进程接收到此信号如果不做捕获处理默认会退出 signal( SIGHUP, SIG_IGN ); if ( (pid = fork()) &lt; 0 ) return -1; else if ( pid ) exit( 0 ); //daemon_proc = 1;//原代码有这句 chdir(&quot;/&quot;); int i = 0; for ( ; i &lt; 64; i++ ) close( i ); open(&quot;/dev/null&quot;, O_RDONLY); open(&quot;/dev/null&quot;, O_RDWR); open(&quot;/dev/null&quot;, O_RDWR); //原代码有这句，就是往syslog里写运行本程序的日志，加上进程id，输出等级为facilit(LOG_WARN这样子) //openlog(pname, LOG_PID, facility); return 0; }","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"编译60个小程序之makefile","slug":"003makefile/index","date":"2018-06-13T19:39:08.000Z","updated":"2018-06-19T02:02:56.047Z","comments":true,"path":"2018/06/14/003makefile/index/","link":"","permalink":"http://yoursite.com/2018/06/14/003makefile/index/","excerpt":"","text":"公司有个任务需要编译60个c语言小程序，工程目录结构为： src：放所有小程序源文件.c drv：所有小程序编译后都为对应.drv 其它头文件、库目录省略。 makefile不太熟，也很菜，我第一想法是用for循环进行循环编译，还用到了makefile自定义函数，贴代码： CC = arm-linux-gcc CFLAGS +=-Wall -O -D_REENTRANT -fpic -shared LDFLAGS += -L./lib -lutility -lcrc -lmxml -lserial -lsocket -lpthread ROOT_DIR = $(shell pwd) SRC_DIR = ./src DRV_DIR = ./drv #src/*.c SRC := $(wildcard ${SRC_DIR}/*.c) SRC1 := $(notdir $(SRC)) ALL_NAME := $(basename ${SRC1}) #自定义了一个compile_file函数 define compile_file $(CC) $(CFLAGS) -o $1 $2 $(LDFLAGS) endef default: for name in $(ALL_NAME); do \\ #这里调用自定义函数，传输两个参数:一个drv/xx.drv，一个src/xx.c ${call compile_file, $(DRV_DIR)/$$name.drv, $(SRC_DIR)/$$name.c}; done clean: rm -f $(DRV_DIR)/*.drv 编译的效果是将所有的小程序都编译一遍，不管有没有出错，不管是否为最新。我需要的效果是编译所有程序，编译到哪一个出错即停止，编译前还要检查目标文件和源文件的更新时间，因此这个makefile不好用，只是学习了一下makefile的循环和自定义函数。 然后又构思makefile该如何写，就在思考的过程中想起来了学裸机程序时工程有一个.S和一个.c文件的编译，再结合makefile的伪目标，结构就很清晰了，这里用一个变量ALL_NAME表示获取到的所有src目录下的.c文件的名字替换为.drv（去除src/目录名和.c后缀，再补上drv/和.drv后缀，形式为drv/xxx.drv），代码忘了拷，贴部分自己能记住的吧： .PHONY:default clean default:$(ALL_NAME) $(DRV_DIR)/%.drv:$(SRC_DIR)/%.c $(CC) $(CFLAGS) -o $@ $&lt; $(LDFLAGS) clean: rm $(DRV_DIR)/*.drv -r 这个makefile就能满足之前的要求了。通过两个makefile的编写，学习了makefile的函数、自定义函数、循环、伪目标、makefile规则与shell规则的混合问题。","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"}]},{"title":"v4l2capture","slug":"002v4l2capture/index","date":"2018-06-13T13:38:53.000Z","updated":"2018-06-19T02:02:56.047Z","comments":true,"path":"2018/06/13/002v4l2capture/index/","link":"","permalink":"http://yoursite.com/2018/06/13/002v4l2capture/index/","excerpt":"","text":"虽然网上很多了，还是贴一下吧，自己刚入门的时候也是找苦逼很久找代码，代码我也是总结的。 1.v4l2.cvoid get_cam_info(struct camera *cam) { if(ioctl(cam-&gt;fd, VIDIOC_QUERYCAP, &amp;cam-&gt;cap) &lt; 0) { perror(&quot;query camera information error.\\n&quot;); exit(0); } if(!(cam-&gt;cap.capabilities &amp; V4L2_CAP_VIDEO_CAPTURE)) { printf(&quot;device is not a capture device.\\n&quot;); exit(0); } printf(&quot;\\nCapability Informations:\\n&quot;); printf(&quot;Driver Name:%s\\nCard Name:%s\\nBus info:%s\\nDriver Version:%u.%u.%u\\nCapabilities: %d\\n&quot;, cam-&gt;cap.driver,cam-&gt;cap.card,cam-&gt;cap.bus_info, (cam-&gt;cap.version&gt;&gt;16)&amp;0XFF, (cam-&gt;cap.version&gt;&gt;8)&amp;0XFF,cam-&gt;cap.version&amp;0XFF, cam-&gt;cap.capabilities ); } void get_cam_fmtdesc(struct camera *cam) { cam-&gt;fmtdesc.index = 0; cam-&gt;fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; while ((ioctl(cam-&gt;fd, VIDIOC_ENUM_FMT, &amp;cam-&gt;fmtdesc)) == 0) { printf(&quot;\\t%d.\\n\\t{\\n\\tpixelformat = &apos;%c%c%c%c&apos;,\\n\\tdescription = &apos;%s&apos;\\n \\t}\\n&quot;, cam-&gt;fmtdesc.index+1, cam-&gt;fmtdesc.pixelformat &amp; 0xFF, (cam-&gt;fmtdesc.pixelformat &gt;&gt; 8) &amp; 0xFF, (cam-&gt;fmtdesc.pixelformat &gt;&gt; 16) &amp; 0xFF, (cam-&gt;fmtdesc.pixelformat &gt;&gt; 24) &amp; 0xFF, cam-&gt;fmtdesc.description); cam-&gt;fmtdesc.index++; } } void set_cap_format(struct camera *cam) { memset(&amp;cam-&gt;format, 0, sizeof(cam-&gt;format)); cam-&gt;format.fmt.pix.width = cam-&gt;width; cam-&gt;format.fmt.pix.height = cam-&gt;height; cam-&gt;format.fmt.pix.pixelformat = cam-&gt;cap_format; //cam-&gt;format.fmt.pix.field = V4L2_FIELD_INTERLACED; cam-&gt;format.fmt.pix.field = V4L2_FIELD_ANY; cam-&gt;format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; if(ioctl(cam-&gt;fd, VIDIOC_S_FMT, &amp;cam-&gt;format) &lt; 0) { perror(&quot;set capture format error.\\n&quot;); exit(0); } } void get_cap_format(struct camera *cam) { struct v4l2_format fmt; struct v4l2_fmtdesc fmtdesc; fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; if(ioctl(cam-&gt;fd, VIDIOC_G_FMT, &amp;fmt) &lt; 0) { perror(&quot;get_cap_format:error.\\n&quot;); exit(0); } printf(&quot;\\nCurrent data format information:\\n width:%d\\n height:%d\\n&quot;, fmt.fmt.pix.width,fmt.fmt.pix.height); fmtdesc.index = 0; fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; while(ioctl(cam-&gt;fd, VIDIOC_ENUM_FMT, &amp;fmtdesc) != -1) { if(fmtdesc.pixelformat == cam-&gt;format.fmt.pix.pixelformat) { printf(&quot; format:%s\\n&quot;,fmtdesc.description); break; } fmtdesc.index ++; } } void get_framerate(struct camera *cam) { int ret; memset(&amp;cam-&gt;setfps, 0, sizeof(struct v4l2_streamparm)); cam-&gt;setfps.type = V4L2_BUF_TYPE_VIDEO_CAPTURE ; cam-&gt;setfps.parm.capture.capability = V4L2_CAP_TIMEPERFRAME; ret = ioctl(cam-&gt;fd, VIDIOC_G_PARM, &amp;cam-&gt;setfps); if(ret &lt; 0) { perror(&quot;get fps error.\\n&quot;); } printf(&quot; fps:%d\\n&quot;,cam-&gt;setfps.parm.capture.timeperframe.denominator); } void set_framerate(struct camera *cam) { int ret ; memset(&amp;cam-&gt;setfps, 0, sizeof(struct v4l2_streamparm)); cam-&gt;setfps.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; cam-&gt;setfps.parm.capture.timeperframe.numerator = 1; cam-&gt;setfps.parm.capture.timeperframe.denominator = 25; ret = ioctl(cam-&gt;fd, VIDIOC_S_PARM, &amp;cam-&gt;setfps); if(ret &lt; 0) { perror(&quot;set fps error.\\n&quot;); } } void req_buffer(struct camera *cam) { memset(&amp;cam-&gt;reqbuf, 0, sizeof(cam-&gt;reqbuf)); cam-&gt;reqbuf.count = cam-&gt;buf_num; cam-&gt;reqbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; cam-&gt;reqbuf.memory = V4L2_MEMORY_MMAP; if(ioctl(cam-&gt;fd, VIDIOC_REQBUFS, &amp;cam-&gt;reqbuf) &lt; 0) { perror(&quot;reqbuf error.\\n&quot;); exit(0); } } void init_mmap(struct camera *cam) { unsigned int i; for(i=0; i&lt;cam-&gt;buf_num; i++) { //memset(&amp;cam-&gt;buf, 0, sizeof(cam-&gt;buf)); cam-&gt;buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; cam-&gt;buf.memory = V4L2_MEMORY_MMAP; cam-&gt;buf.index = i; if(-1 == ioctl(cam-&gt;fd, VIDIOC_QUERYBUF, &amp;cam-&gt;buf)) { perror(&quot;ioctl querybuf error.\\n&quot;); exit(0); } cam-&gt;buffers[i].length = cam-&gt;buf.length; cam-&gt;buffers[i].start = (unsigned char *)mmap(NULL, cam-&gt;buf.length, PROT_READ | PROT_WRITE, MAP_SHARED, cam-&gt;fd, cam-&gt;buf.m.offset); if(MAP_FAILED == cam-&gt;buffers[i].start) { perror(&quot;mmap error.\\n&quot;); exit(0); } } } void start_capture(struct camera *cam) { unsigned int i; for(i=0; i&lt;cam-&gt;buf_num; i++) { //memset(&amp;cam-&gt;buf, 0, sizeof(cam-&gt;buf)); cam-&gt;buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; cam-&gt;buf.memory = V4L2_MEMORY_MMAP; cam-&gt;buf.index = i; if(-1 == ioctl(cam-&gt;fd, VIDIOC_QBUF, &amp;cam-&gt;buf)) { perror(&quot;start capture:video ioctl qbuf error.\\n&quot;); exit(0); } } if(-1 == ioctl(cam-&gt;fd, VIDIOC_STREAMON, &amp;cam-&gt;buf.type)) { perror(&quot;start capture:video ioctl streamon error.\\n&quot;); exit(0); } } int isHaveData(int fd) { fd_set fds; struct timeval tv; int r; FD_ZERO (&amp;fds);//将指定的文件描述符集清空 FD_SET (fd, &amp;fds);//在文件描述符集合中增加一个新的文件描述符 tv.tv_sec = 2; tv.tv_usec = 0; for (;;) //这一段涉及到异步IO { r = select (fd + 1, &amp;fds, NULL, NULL, &amp;tv);//判断是否可读（即摄像头是否准备好），tv是定时 if (-1 == r) { if (EINTR == errno) { printf(&quot;select err\\n&quot;); continue; } } if (0 == r) { fprintf (stderr, &quot;select timeout：%d\\n&quot;,errno); return 0; } return 1; } } int get_one_frame_buf(struct camera * cam) { int index ; if(isHaveData(cam-&gt;fd)) { memset(&amp;cam-&gt;buf, 0, sizeof(cam-&gt;buf)); cam-&gt;buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; cam-&gt;buf.memory = V4L2_MEMORY_MMAP; if(ioctl(cam-&gt;fd, VIDIOC_DQBUF, &amp;cam-&gt;buf) &lt; 0) { perror(&quot;get one frame buffer:video ioctl dqbuf error.\\n&quot;); exit(0); } assert(cam-&gt;buf.index &lt; cam-&gt;buf_num); index = cam-&gt;buf.index; //starter = (unsigned char *)buffers[cam-&gt;buf.index].start; if(ioctl(cam-&gt;fd, VIDIOC_QBUF, &amp;cam-&gt;buf) &lt; 0) { perror(&quot;get one frame buffer:video ioctl qbuf error.\\n&quot;); exit(0); } return index; } else { printf(&quot;get one frame buffer error.\\n&quot;); exit(0); } } void stop_capture(struct camera *cam) { if(-1 == ioctl(cam-&gt;fd,VIDIOC_STREAMOFF,&amp;cam-&gt;fmtdesc.type)) { perror(&quot;stop capture error.\\n&quot;); exit(0); } close(cam-&gt;fd); printf(&quot;stop capture successfully!\\n&quot;); } void Munmap(int req_num, struct mmap_buffer *buffers) { unsigned int i; for (i = 0; i &lt; req_num; ++i) if (-1 == munmap(buffers[i].start, buffers[i].length)) free (buffers); } 2.v4l2.h这里的h4all.h包含的库函数,动手man一下吧 :-D #ifndef _V4L2_UVC_H #define _V4L2_UVC_H #include &quot;h4all.h&quot; struct mmap_buffer{ void *start; size_t length; }; typedef struct camera{ int fd; //摄像头文件描述符 int width; int height; int cap_format; int buf_num; struct v4l2_capability cap; struct v4l2_fmtdesc fmtdesc; struct v4l2_format format; struct v4l2_streamparm setfps; struct v4l2_requestbuffers reqbuf; struct v4l2_buffer buf; struct mmap_buffer buffers[4]; }Camera; void get_cam_info(struct camera *cam); void get_cam_fmtdesc(struct camera *cam); void set_cap_format(struct camera *cam); void get_cap_format(struct camera *cam); void get_framerate(struct camera *cam); void set_framerate(struct camera *cam); void req_buffer(struct camera *cam); void init_mmap(struct camera *cam); void start_capture(struct camera *cam); int get_one_frame_buf(struct camera * cam); void stop_capture(struct camera *cam); void Munmap(int req_num, struct mmap_buffer *buffers); void Init_v4l2(struct camera *cam); #endif 3.初始化：main.c#define DRIVER &quot;/dev/video2&quot; #define WIDTH 176 #define HEIGHT 144 #define CAP_FORMAT V4L2_PIX_FMT_YUYV #define REQ_BUFFER 4 Camera *cam; struct mmap_buffer buffers[REQ_BUFFER]; cam = (Camera *)malloc(sizeof(Camera)); void set_cam(Camera *cam, const char *driver_path, int width, int height, int format, int req_num) { cam-&gt;fd = Open(driver_path); cam-&gt;width = width; cam-&gt;height = height; cam-&gt;cap_format = format; cam-&gt;buf_num = req_num; } 4.获得数据调用v4l2_uvc.c的get_one_frame_buf(cam),用int型的index接收返回值，即是目前获得的底几个缓冲区的索引值，cam-&gt;buffers[index].start即是指向那段数据内存，cam-&gt;buffers[index].length即是大小 注：当然，还有什么设置伽马值、曝光度这些套路跟上面差不多，可以百度一下，作为函数补充进去","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"摄像头","slug":"摄像头","permalink":"http://yoursite.com/tags/摄像头/"}]},{"title":"yuv422转换为yuv420p","slug":"001yuv422toyuv420p/index","date":"2018-06-12T14:25:24.000Z","updated":"2018-06-19T02:02:56.039Z","comments":true,"path":"2018/06/12/001yuv422toyuv420p/index/","link":"","permalink":"http://yoursite.com/2018/06/12/001yuv422toyuv420p/index/","excerpt":"","text":"今天遇到一个问题，我的摄像头采集到的数据是yuyv格式(属于yuv422)，而X264在进行编码的时候需要标准的YUV（4：2：0）。所以有一个yuv422toyuv420的转换。在网上找了半天找到的方法拿过来转换了查看都很花。于是自己看了一下yuv格式的解释，准备写一个转换代码。以下许多解释都是按我的理解： 1.yuvyuv格式通常有两大类：打包(packed)和平面(planar)格式。前者在码流里是yuv挨一起，比如我的yuyv就是 Y0 U0 Y1 V1 Y2 U2 …. 每一个 Y对应一组UV分量。后者存储y u v分量是分开存储的，这种方式一般后面带P， 比如y uv420p就是Y0 Y1 Y2 … U0 U1 U2 … V0 V1 V2 … uv分量的多少根据格式来，yuv420也就是每四个 Y共用一组UV分量。 2.转换理解了yuyv即yuv422与yuv420p中分量的排布，就要进行转换了。网上查到的资料说yuv422-&gt;yuv420p时 丢弃偶数行的uv分量。 3.编码定义： unsignedchar *y = out; unsignedchar *u = out + width*height; unsigned char*v = out + width*height + width*height/4; y u v分别指向yuv420buf中存储y u v分量的数组，这里out的类型为char型数组，按yuv420p的定义，4个y共用一对uv，那么一个y对应1/4个uv，一个分量占一个byte，out的大小为：总共的y分量(widthheight) + 总共的u分量(widthheight/4) + 总共的v分量(widthheight/4) = widthheight*3/2。通过上面的转换也可以得到yuyv(yuv422)一个像素占用2个字节，yuv420p一个像素占1.5个字节，rgb24的话占用3个字节，还是节约了一点点空间的。。。 获取y分量并存储到yuv420buf中： for(i=0; i&lt;yuv422_length; i+=2){ *(y+y_index) = *(in+i); y_index++; } 这里的yuv422_length为width*height*2;y_index初始为0，存储一个y就自加一次。 获取uv分量并存储到yuv420buf中： for(i=0; i&lt;height; i+=2){ base_h = i*width*2; for(j=base_h+1;j&lt;base_h+width*2; j+=2){ if(is_u){ *(u+u_index)= *(in+j); u_index++; is_u = 0; } else{ *(v+v_index)= *(in+j); v_index++; is_u = 1; } } } 总结：初入视频图像，我还是一个菜鸟，对于很多理解也不深，这个代码应该还有很多没考虑，对于我可用了。当然以上都是废话，直接贴代码 int yuv422toyuv420(unsigned char *out, const unsigned char *in, unsigned int width, unsigned int height) { unsigned char *y = out; unsigned char *u = out + width*height; unsigned char *v = out + width*height + width*height/4; unsigned int i,j; unsigned int base_h; unsigned int is_y = 1, is_u = 1; unsigned int y_index = 0, u_index = 0, v_index = 0; unsigned long yuv422_length = 2 * width * height; //序列为YU YV YU YV，一个yuv422帧的长度 width * height * 2 个字节 //丢弃偶数行 u v for(i=0; i&lt;yuv422_length; i+=2){ *(y+y_index) = *(in+i); y_index++; } for(i=0; i&lt;height; i+=2){ base_h = i*width*2; for(j=base_h+1; j&lt;base_h+width*2; j+=2){ if(is_u){ *(u+u_index) = *(in+j); u_index++; is_u = 0; } else{ *(v+v_index) = *(in+j); v_index++; is_u = 1; } } } return 1; }","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"摄像头","slug":"摄像头","permalink":"http://yoursite.com/tags/摄像头/"}]}]}