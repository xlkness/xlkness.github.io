<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>My Blog</title>
  
  <subtitle>我的小站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-20T04:50:55.817Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>lkness</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图的简单表示-算法学习笔记十七</title>
    <link href="http://yoursite.com/2018/06/20/028graph/index/"/>
    <id>http://yoursite.com/2018/06/20/028graph/index/</id>
    <published>2018-06-20T04:49:36.000Z</published>
    <updated>2018-06-20T04:50:55.817Z</updated>
    
    <content type="html"><![CDATA[<p>基于邻接矩阵和邻接链表的图表示法，以及各自的深度优先遍历和广度优先遍历，但图的表示中没有加带权的边，只是简单写一写，学习一下，底层链表和队列用了通用链表</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#define PRINT(format, arg...) \do{ \    printf(&quot;[%s/%d]:&quot;, __func__, __LINE__); \    printf(format, ##arg); \    printf(&quot;\n&quot;); \}while(0)/*****************************图********************************/#define MAX_VERTEX_NUM 100typedef struct init_array {    int start_v;    int end_v;} init_array;/**************邻接矩阵表示****************/typedef struct matrix_graph {    int vertex[MAX_VERTEX_NUM];  // 存放顶点信息    int v_num;  // 顶点数    int e_num;  // 边数    int matrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];} matrix_graph;matrix_graph *init_matrix_graph(    int v_num,    int e_num ){    int i = 0, j = 0;    matrix_graph *graph = NULL;    graph = ( matrix_graph * )malloc( sizeof(matrix_graph) );    graph-&gt;v_num = v_num;    graph-&gt;e_num = e_num;    for ( i = 0; i &lt; MAX_VERTEX_NUM; i++ ) {        if ( i &lt; v_num )            graph-&gt;vertex[i] = i;        else            graph-&gt;vertex[i] = -1;        for ( j = 0; j &lt; MAX_VERTEX_NUM; j++ ) {            graph-&gt;matrix[i][j] = 0;        }    }    return graph;}matrix_graph *create_matrix_graph(    init_array *i_arr,    int arr_size,    int v_num ){    int i = 0;    matrix_graph *graph = NULL;    graph = init_matrix_graph( v_num, arr_size );    for ( i = 0; i &lt; arr_size; i++ ) {        graph-&gt;matrix[i_arr[i].start_v][i_arr[i].end_v] = 1;    }    return graph;}int visited[MAX_VERTEX_NUM] = {0};// 深度优先遍历void dfs_matrix_graph1(    matrix_graph *g,    int v ){    visited[v] = 1;    printf(&quot;%d &quot;, v);    // 搜索此结点的下一个结点    int i = 0;    for ( i; i &lt; g-&gt;v_num; i++ ) {        if ( g-&gt;matrix[v][i] &amp;&amp; !visited[i] )            dfs_matrix_graph1( g, i );    }}void dfs_matrix_graph(    matrix_graph *g ){    int i = 0;    for ( i; i &lt; g-&gt;v_num; i++ )        visited[i] = 0;    printf(&quot;deep first visit:\n\t&quot;);    for ( i = 0; i &lt; g-&gt;v_num; i++ ) {        if ( !visited[i] )            dfs_matrix_graph1( g, i );    }    printf(&quot;\n&quot;);}// 广度优先搜索void bfs_matrix_graph(    matrix_graph *g ){    int i = 0;    // 栈结点数据域，需要void *    int tmp_vertex[MAX_VERTEX_NUM] = {0};    queue *q = create_queue();    for ( i = 0; i &lt; g-&gt;v_num; i++ )        visited[i] = 0;    printf(&quot;broad first visit:\n\t&quot;);    for ( i = 0; i &lt; g-&gt;v_num; i++ ) {        if ( !visited[i] ) {            tmp_vertex[i] = i;            q-&gt;enqueue(q-&gt;this, &amp;tmp_vertex[i]);            while ( q-&gt;size(q-&gt;this) != 0 ) {                int tmp = *( int * )q-&gt;dequeue( q-&gt;this );                if ( !visited[tmp] )                    printf(&quot;%d &quot;, tmp);                visited[tmp] = 1;                int j = 0;                for ( j = 0; j &lt; g-&gt;v_num; j++ ) {                    if ( g-&gt;matrix[tmp][j] &amp;&amp; !visited[j] ) {                        tmp_vertex[j] = j;                        q-&gt;enqueue( q-&gt;this, &amp;tmp_vertex[j] );                    }                }            }        }    }    q-&gt;free( q-&gt;this );    printf(&quot;\n&quot;);}void free_matrix_graph(    matrix_graph *g ){    free( g );}#undef DEBUG_MATRIX_GRAPH#ifdef DEBUG_MATRIX_GRAPHint main(){    init_array i_arr[20] =        {            {0, 4},            {0, 9},            {1, 5},            {2, 1},            {2, 6},            {3, 2},            {3, 6},            {4, 7},            {4, 8},            {5, 2},            {6, 5},            {7, 6},            {7, 3},            {8, 7},            {8, 4},            {9, 8},        };    matrix_graph *g = create_matrix_graph( i_arr, 16, 10 );    dfs_matrix_graph( g );    bfs_matrix_graph( g );    free_matrix_graph( g );}#endif/********************************************//**************图的邻接链表*******************/typedef struct link_list_graph {    int vertex[MAX_VERTEX_NUM];    int v_num;    int e_num;    link_list v_list[MAX_VERTEX_NUM];} link_list_graph;// 链表数据域，需要void *int tmp_vertex[MAX_VERTEX_NUM] = {0};link_list_graph *create_link_list_graph(    init_array *i_arr,    int arr_size,    int v_num ){    int i = 0;    link_list_graph *graph = NULL;    graph = ( link_list_graph * )malloc( sizeof(link_list_graph) );    graph-&gt;e_num = arr_size;    graph-&gt;v_num = v_num;    for ( i = 0; i &lt; v_num; i++ ) {        tmp_vertex[i] = i;        //定制链表操作        graph-&gt;v_list[i].size = 0;        graph-&gt;v_list[i].insert = insert_tail;        graph-&gt;v_list[i].get_first = get_head;        graph-&gt;v_list[i].get_last = get_tail;        graph-&gt;v_list[i].del = del_tail;        graph-&gt;v_list[i].insert( &amp;graph-&gt;v_list[i], &amp;tmp_vertex[i]);    }    for ( i = 0; i &lt; arr_size; i++ ) {        int start = i_arr[i].start_v;        int end = i_arr[i].end_v;        graph-&gt;v_list[start].insert( &amp;graph-&gt;v_list[start], &amp;tmp_vertex[end]);        printf(&quot;start:%d-&gt;end:%d, size:%d\n&quot;, start, end, graph-&gt;v_list[start].size);    }    return graph;}void dfs_link_list_graph1(    link_list_graph *g,    int v ){    link_list_node *p = g-&gt;v_list[v].head;    if ( !visited[*(int *)(p-&gt;data)] ) {        printf(&quot;%d &quot;, *(int *)(p-&gt;data));        visited[v] = 1;        while ( 1 ) {            p = p-&gt;next;            if ( p == g-&gt;v_list[v].head )                break;            if ( !visited[*(int *)(p-&gt;data)] ) {                dfs_link_list_graph1( g, *(int *)(p-&gt;data) );            }        }    }}void dfs_link_list_graph(    link_list_graph *g ){    int i = 0;    printf(&quot;深度优先遍历：\n\t&quot;);    for ( i = 0; i &lt; g-&gt;v_num; i++ )        visited[i] = 0;    for ( i = 0; i &lt; g-&gt;v_num; i++ ) {        if ( g-&gt;v_list[i].size &gt; 0 &amp;&amp; !visited[i] )            dfs_link_list_graph1( g, i );    }    printf(&quot;\n&quot;);}void bfs_link_list_graph(    link_list_graph *g ){    int i = 0;    // 栈结点数据域，需要void *    int tmp_vertex[MAX_VERTEX_NUM] = {0};    queue *q = create_queue();    for ( i = 0; i &lt; g-&gt;v_num; i++ ){        tmp_vertex[i] = i;        visited[i] = 0;    }    printf(&quot;广度优先遍历:\n\t&quot;);    for ( i = 0; i &lt; g-&gt;v_num; i++ ) {        if ( !visited[i] ) {            tmp_vertex[i] = i;            q-&gt;enqueue(q-&gt;this, &amp;tmp_vertex[i]);            while ( q-&gt;size(q-&gt;this) != 0 ) {                int tmp = *( int * )q-&gt;dequeue( q-&gt;this );                if ( !visited[tmp] )                    printf(&quot;%d &quot;, tmp);                visited[tmp] = 1;                int j = 0;                link_list_node *p = g-&gt;v_list[tmp].head-&gt;next;                while ( p != g-&gt;v_list[tmp].head ) {                    if ( !visited[*(int *)p-&gt;data] ) {                        q-&gt;enqueue( q-&gt;this, &amp;tmp_vertex[*(int *)p-&gt;data] );                    }                    p = p-&gt;next;                }            }        }    }    q-&gt;free( q-&gt;this );    printf(&quot;\n&quot;);}void free_link_list_graph(    link_list_graph *g ){    int i = 0;    for ( i = 0; i &lt; g-&gt;v_num; ++i ) {        del_list( &amp;g-&gt;v_list[i] );    }    free( g );}#define DEBUG_LINK_LIST_GRAPH#ifdef DEBUG_LINK_LIST_GRAPHint main(){    init_array i_arr[20] =        {            {0, 4},            {0, 9},            {1, 5},            {2, 1},            {2, 6},            {3, 2},            {3, 6},            {4, 7},            {4, 8},            {5, 2},            {6, 5},            {7, 6},            {7, 3},            {8, 7},            {8, 4},            {9, 8},        };    link_list_graph *g = create_link_list_graph( i_arr, 16, 10 );    dfs_link_list_graph( g );    bfs_link_list_graph( g );    free_link_list_graph( g );}#endif/********************************************//***************************************************************/</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基于邻接矩阵和邻接链表的图表示法，以及各自的深度优先遍历和广度优先遍历，但图的表示中没有加带权的边，只是简单写一写，学习一下，底层链表和队列用了通用链表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.
      
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>通用链表/栈/队列-算法学习笔记十六</title>
    <link href="http://yoursite.com/2018/06/20/027list-stack-queue/index/"/>
    <id>http://yoursite.com/2018/06/20/027list-stack-queue/index/</id>
    <published>2018-06-20T04:47:44.000Z</published>
    <updated>2018-06-20T04:49:04.717Z</updated>
    
    <content type="html"><![CDATA[<p>今天准备学习数据结构-图，会用到栈和队列，因此写了下代码，底层用了通用链表，为循环双向结构，结点数据域为void *；通用链表层之上封装了栈和队列，比较简单，但是代码行数有点多，单独摘出：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#define MAX_VERTEX_NUM 1000#define PRINT(format, arg...) \do{ \    printf(&quot;[%s/%d]:&quot;, __func__, __LINE__); \    printf(format, ##arg); \    printf(&quot;\n&quot;); \}while(0)/*****************************底层链表***************************/// 循环双向链表typedef struct link_list_node {    void *data;    struct link_list_node *pre;    struct link_list_node *next;} link_list_node;typedef struct link_list {    int size;    //链表插入函数    void (*insert)( struct link_list *list, void *data );    //链表取第一个结点    void *(*get_first)( struct link_list *list );    //链表取最后一个结点    void *(*get_last)( struct link_list *list );    //链表删除第一个结点    void *(*del)( struct link_list *list );    struct link_list_node *head;} link_list;link_list_node *create_link_list_node(    void *data ){    link_list_node *node = NULL;    node = ( link_list_node * )malloc( sizeof(link_list_node) );    node-&gt;data = data;    node-&gt;pre = NULL;    node-&gt;next = NULL;    return node;}//头插void insert_head(    link_list *list,    void *data ){    if ( !list ) {        PRINT(&quot;list is null.&quot;);        return;    }    link_list_node *node = create_link_list_node( data );    if ( !list-&gt;head ) {        node-&gt;next = node;        node-&gt;pre = node;        list-&gt;head = node;        list-&gt;size = 1;        return;    }    node-&gt;next = list-&gt;head;    node-&gt;pre = list-&gt;head-&gt;pre;    list-&gt;head-&gt;pre-&gt;next = node;    list-&gt;head-&gt;pre = node;    list-&gt;head = node;    list-&gt;size += 1;}//尾插，栈/队列的插入void insert_tail (    link_list *list,    void *data ){    if ( !list ) {        return;    }    link_list_node *node = create_link_list_node( data );    if ( !list-&gt;head ) {        node-&gt;next = node;        node-&gt;pre = node;        list-&gt;head = node;        list-&gt;size = 1;        return;    }    node-&gt;pre = list-&gt;head-&gt;pre;    node-&gt;next = list-&gt;head;    list-&gt;head-&gt;pre-&gt;next = node;    list-&gt;head-&gt;pre = node;    list-&gt;size += 1;}//获取链表头数据void *get_head(    link_list *list ){    if ( !list || !list-&gt;head ) {        PRINT(&quot;list is null.&quot;);        return NULL;    }    return list-&gt;head-&gt;data;}//获取链表尾数据void *get_tail(    link_list *list ){    if ( !list || !list-&gt;head ){        PRINT(&quot;list is null.&quot;);        return NULL;    }    return list-&gt;head-&gt;pre-&gt;data;}//删除链表头，并返回删除结点的数据void *del_head(    link_list *list ){    if ( !list || !list-&gt;head ) {        return NULL;    }    if ( list-&gt;size == 1 ) {        void *data = list-&gt;head-&gt;data;        free( list-&gt;head );        list-&gt;head = NULL;        list-&gt;size = 0;        return data;    }    link_list_node *p = list-&gt;head;    void *data = p-&gt;data;    list-&gt;head-&gt;pre-&gt;next = list-&gt;head-&gt;next;    list-&gt;head-&gt;next-&gt;pre = list-&gt;head-&gt;pre;    list-&gt;head = list-&gt;head-&gt;next;    list-&gt;size -= 1;    free( p );    return data;}//删除链表尾，并返回删除结点的数据void *del_tail(    link_list *list ){    if ( !list || !list-&gt;head ) {        PRINT(&quot;list is null.&quot;);        return NULL;    }    if ( list-&gt;size == 1 ) {        void *data = list-&gt;head-&gt;data;        free( list-&gt;head );        list-&gt;head = NULL;        list-&gt;size = 0;        return data;    }    link_list_node *p = list-&gt;head-&gt;pre;    void *data = p-&gt;data;    list-&gt;head-&gt;pre-&gt;pre-&gt;next = list-&gt;head;    list-&gt;head-&gt;pre = list-&gt;head-&gt;pre-&gt;pre;    list-&gt;size -= 1;    free( p );    return data;}/******************************************************************//********************************队列***********************************/typedef struct queue {    void *(*first)( struct queue *this );    void *(*last)( struct queue *this );    void (*enqueue)( struct queue *this, void *data );    void *(*dequeue)( struct queue *this );    int (*size)( struct queue *this );    void (*free)( struct queue *this );    struct link_list *list;    struct queue *this;} queue;void *queue_get_first(    queue *q ){    if ( !q || !q-&gt;list )        return NULL;    return q-&gt;list-&gt;get_first( q-&gt;list );}void *queue_get_last(    queue *q ){    if ( !q || !q-&gt;list )        return NULL;    return q-&gt;list-&gt;get_last( q-&gt;list );}void enqueue(    queue *q,    void *data ){    if ( !q || !q-&gt;list )        return ;    q-&gt;list-&gt;insert( q-&gt;list, data );}void *dequeue(    queue *q ){    if ( !q || !q-&gt;list )        return NULL;    q-&gt;list-&gt;del( q-&gt;list );}int queue_size(    queue *q ){    if ( !q || !q-&gt;list)        return 0;    return q-&gt;list-&gt;size;}void queue_free(    queue *q ){    if ( !q )        return ;    if ( !q-&gt;list ) {        free( q );        return;    }    while ( q-&gt;dequeue( q-&gt;this ) );    free( q-&gt;list );    free( q );}queue *create_queue(){    queue *q = NULL;    q = ( queue * )malloc( sizeof(queue) );    q-&gt;first = queue_get_first;    q-&gt;last = queue_get_last;    q-&gt;enqueue = enqueue;    q-&gt;dequeue = dequeue;    q-&gt;size = queue_size;    q-&gt;free = queue_free;    q-&gt;list = ( link_list * )malloc( sizeof(link_list) );    q-&gt;list-&gt;size = 0;    q-&gt;list-&gt;insert = insert_tail;    q-&gt;list-&gt;get_first = get_head;    q-&gt;list-&gt;get_last = get_tail;    q-&gt;list-&gt;del = del_head;    q-&gt;this = q;}#undef DEBUG_QUEUE#ifdef DEBUG_QUEUEvoid test_queue(){    queue *q = create_queue();    int data1 = 5;    int data2 = 6;    int data3 = 7;    q-&gt;enqueue(q-&gt;this, (void *)&amp;data1);    PRINT(&quot;q-&gt;last:%d&quot;, *(int *)q-&gt;last(q-&gt;this));    q-&gt;enqueue(q-&gt;this, (void *)&amp;data2);    PRINT(&quot;q-&gt;last:%d&quot;, *(int *)q-&gt;last(q-&gt;this));    q-&gt;enqueue(q-&gt;this, (void *)&amp;data3);    PRINT(&quot;q-&gt;last:%d\n&quot;, *(int *)q-&gt;last(q-&gt;this));    PRINT(&quot;q-&gt;size:%d\n&quot;, q-&gt;size(q-&gt;this));    PRINT(&quot;q-&gt;first:%d&quot;, (int)*(int *)(q-&gt;first(q-&gt;this)));    PRINT(&quot;q-&gt;last:%d\n&quot;, (int)*(int *)(q-&gt;last(q-&gt;this)));    PRINT(&quot;q-&gt;dequeue:%d&quot;, (int)*(int *)(q-&gt;dequeue(q-&gt;this)));    PRINT(&quot;q-&gt;first:%d&quot;, (int)*(int *)(q-&gt;first(q-&gt;this)));    PRINT(&quot;q-&gt;size:%d\n&quot;, q-&gt;size(q-&gt;this));    PRINT(&quot;q-&gt;dequeue:%d&quot;, (int)*(int *)(q-&gt;dequeue(q-&gt;this)));    PRINT(&quot;q-&gt;first:%d&quot;, (int)*(int *)(q-&gt;first(q-&gt;this)));    PRINT(&quot;q-&gt;size:%d\n&quot;, q-&gt;size(q-&gt;this));    PRINT(&quot;q-&gt;dequeue the last element&quot;);    q-&gt;dequeue(q-&gt;this);    PRINT(&quot;q-&gt;size:%d\n&quot;, q-&gt;size(q-&gt;this));    q-&gt;free( q-&gt;this );}int main(){    test_queue();    return 0;}#endif/*****************************************************************//*****************************栈********************************/typedef struct stack {    void *(*first)( struct stack *this );    void *(*last)( struct stack *this );    void (*push)( struct stack *this, void *data );    void *(*pop)( struct stack *this );    int (*size)( struct stack *this );    void (*free)( struct stack *this );    struct link_list *list;    struct stack *this;} stack;void *stack_get_first(    stack *s ){    if ( !s || !s-&gt;list )        return NULL;    return s-&gt;list-&gt;get_first( s-&gt;list );}void *stack_get_last(    stack *s ){    if ( !s || !s-&gt;list )        return NULL;    return s-&gt;list-&gt;get_last( s-&gt;list );}void stack_push(    stack *s,    void *data ){    if ( !s || !s-&gt;list )        return ;    s-&gt;list-&gt;insert( s-&gt;list, data );}void *stack_pop(    stack *s ){    if ( !s || !s-&gt;list )        return NULL;    s-&gt;list-&gt;del( s-&gt;list );}int stack_size(    stack *s ){    if ( !s || !s-&gt;list)        return 0;    return s-&gt;list-&gt;size;}void stack_free(    stack *s ){    if ( !s )        return ;    if ( !s-&gt;list ) {        free( s );        return;    }    while ( s-&gt;pop( s-&gt;this ) );    free( s-&gt;list );    free( s );}stack *create_stack(){    stack *s = NULL;    s = ( stack * )malloc( sizeof(stack) );    s-&gt;first = stack_get_first;    s-&gt;last = stack_get_last;    s-&gt;push = stack_push;    s-&gt;pop = stack_pop;    s-&gt;size = stack_size;    s-&gt;free = stack_free;    s-&gt;list = ( link_list * )malloc( sizeof(link_list) );    s-&gt;list-&gt;size = 0;    s-&gt;list-&gt;insert = insert_tail;    s-&gt;list-&gt;get_first = get_tail;    s-&gt;list-&gt;get_last = get_head;    s-&gt;list-&gt;del = del_tail;    s-&gt;this = s;}#define DEBUG_STACK#ifdef DEBUG_STACKvoid test_stack(){    stack *s = create_stack();    int data1 = 5;    int data2 = 6;    int data3 = 7;    s-&gt;push(s-&gt;this, (void *)&amp;data1);    PRINT(&quot;s-&gt;first:%d&quot;, *(int *)s-&gt;first(s-&gt;this));    s-&gt;push(s-&gt;this, (void *)&amp;data2);    PRINT(&quot;s-&gt;first:%d&quot;, *(int *)s-&gt;first(s-&gt;this));    s-&gt;push(s-&gt;this, (void *)&amp;data3);    PRINT(&quot;s-&gt;first:%d\n&quot;, *(int *)s-&gt;first(s-&gt;this));    PRINT(&quot;s-&gt;size:%d\n&quot;, s-&gt;size(s-&gt;this));    PRINT(&quot;s-&gt;last:%d&quot;, (int)*(int *)(s-&gt;last(s-&gt;this)));    PRINT(&quot;s-&gt;first:%d\n&quot;, (int)*(int *)(s-&gt;first(s-&gt;this)));    PRINT(&quot;s-&gt;pop:%d&quot;, (int)*(int *)(s-&gt;pop(s-&gt;this)));    PRINT(&quot;s-&gt;first:%d&quot;, (int)*(int *)(s-&gt;first(s-&gt;this)));    PRINT(&quot;s-&gt;size:%d\n&quot;, s-&gt;size(s-&gt;this));    PRINT(&quot;s-&gt;pop:%d&quot;, (int)*(int *)(s-&gt;pop(s-&gt;this)));    PRINT(&quot;s-&gt;first:%d&quot;, (int)*(int *)(s-&gt;first(s-&gt;this)));    PRINT(&quot;s-&gt;size:%d\n&quot;, s-&gt;size(s-&gt;this));    PRINT(&quot;s-&gt;pop the first element&quot;);    s-&gt;pop(s-&gt;this);    PRINT(&quot;s-&gt;size:%d\n&quot;, s-&gt;size(s-&gt;this));    s-&gt;free( s-&gt;this );}int main(){    test_stack();    return 0;}#endif</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天准备学习数据结构-图，会用到栈和队列，因此写了下代码，底层用了通用链表，为循环双向结构，结点数据域为void *；通用链表层之上封装了栈和队列，比较简单，但是代码行数有点多，单独摘出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#i
      
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>外排序多路归并+败者树-算法学习笔记十五</title>
    <link href="http://yoursite.com/2018/06/20/026out-sort/index/"/>
    <id>http://yoursite.com/2018/06/20/026out-sort/index/</id>
    <published>2018-06-20T04:40:53.000Z</published>
    <updated>2018-06-20T04:46:12.233Z</updated>
    
    <content type="html"><![CDATA[<p>问题：一个文件有大量的数，现要对文件排序，但内存无法一次读取完全，而磁盘空间足够，要如何排序。</p><p>学习了几篇博客：</p><ol><li>july<a href="https://blog.csdn.net/v_july_v/article/details/6451990" target="_blank" rel="noopener">大神的海量数据排序</a>(他的其他博客都很值得看)</li><li>对july大神的算法进行改进不用选择法而是败者树的<a href="www.cnblogs.com/harryshayne/archive/2011/07/02/2096196.html">博客</a></li><li>以及另一篇但不知道是否为原创的<a href="http://kenby.iteye.com/blog/1017532" target="_blank" rel="noopener">博客</a></li><li>还有<a href="http://www.cnblogs.com/eaglet/archive/2011/01/17/1937083.html" target="_blank" rel="noopener">生成不重复乱序m-n的数的博客</a>(先生成m-n的数，然后洗牌算法)</li></ol><p>#<br>以上几篇博客写得很完全了，看懂了思路，自己临摹写一个简单的测试 ….<br><strong>先用生成随机数的代码生成data.txt待排序大文件:</strong></p><pre><code>//生成随机的不重复的测试数据#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;assert.h&gt;#include &lt;stdlib.h&gt;  // RAND_MAXusing namespace std;//产生[i,u]区间的随机数int randint(int l, int u){    int a = RAND_MAX * rand();    int b = rand();    //取低31位    int c = ( a + b ) &amp; (0x7fffffff) % ( u - l + 1 );    int d = l + c;    return d;}const int size = 10000000;// const int size = 10;int num[size];int main(){    srand((int)time(NULL));    int i, j;    FILE *fp = fopen(&quot;data.txt&quot;, &quot;w&quot;);    assert(fp);    for (i = 0; i &lt; size; i++)        num[i] = i+1;    // printf(&quot;rand_max:%d\n&quot;, RAND_MAX);    for (i = 0; i &lt; size; i++)    {        j = randint(i, size-1);        // printf(&quot;%d &quot;, j);        fflush(stdout);        int t = num[i]; num[i] = num[j]; num[j] = t;        //swap(num[i], num[j]);    }    // printf(&quot;\n&quot;);    for (i = 0; i &lt; size; i++)        fprintf(fp, &quot;%d\n&quot;, num[i]);    fclose(fp);    return 0;}</code></pre><p><strong>对data.txt文件开始外排序:</strong></p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;time.h&gt;#define TEMP_PREFIX &quot;ftemp_&quot;#define OUTPUT_FILE &quot;out_data.txt&quot;#define MAX_WAYS  100// 无穷大，用于某一路文件或缓冲区读到尾了// 败者树产生一个注定失败的结点#define INFINITY 1000000000int *buf;int lst[MAX_WAYS];void read_data(FILE *fp, int *buf){    if ( fscanf(fp, &quot;%d &quot;, buf) == EOF )        *buf = INFINITY;}int partition( int *arr, int p, int r ){    int x = arr[r];    int i = p - 1;    int j = 0, temp;    for ( j = p; j &lt;= r - 1; j++ ) {        if ( arr[j] &lt;= x ) {            i += 1;            temp = arr[i];            arr[i] = arr[j];            arr[j] = temp;        }    }    temp = arr[i + 1];    arr[i + 1] = arr[r];    arr[r] = temp;    return i + 1;}void quick_sort( int *arr, int p, int r ){    if ( p &lt; r ) {        int q = partition( arr, p, r );        quick_sort( arr, p, q - 1 );        quick_sort( arr, q + 1, r );    }}void adjust( int k, int s ){    // t为结点s在败者树数组的父结点，    // 例如64路归并，输入63/62，他们    // 的父结点均为 63    int t = ( k + s ) / 2;    while ( t &gt; 0 ) {        if ( s == -1 ) {            break;        }        // 第一趟，输入一个叶子结点s，让s与父结点的值比较        // （这里父结点一定保存上一次比较的较大者），如果s        // 大于父结点的值，表示s为新的败者，将表示s结点的        // 索引放到父结点处，胜者（父结点）继续到更上层的        // 父结点进行比较，这样比较完后，顶点一定放置的最        // 小的值        // 将败者树想象为一场淘汰赛，假如有8个参赛者入口，        // 8个参赛者编号1-8，第一轮（即初始化败者树），假        // 设产生了2/4/6/8四强败者，放置到8个入口上一层（        // 即父结点），然后再产生两强败者5/7，放置到更上一        // 层的结点，然后产生最后的失败者1，而剩余的8就是最        // 终的胜者，这样一棵败者树就初始化好了，        // 8个入口，之后我们可以随便哪个入口加入一个参赛者，        // 这个参赛者只需要与父结点进行比较，败者留下，胜者        // 可以往更高的父结点去参加比赛....这样每一轮进入一        // 个参赛者，每次能得到一个新的冠军(最小值)，然后写入        // 文件末尾        // 这里的8其实就是8路归并，这个入口的参赛者每次就去        // 读取8个排好序的文件或缓冲区        if ( buf[s] &gt; buf[lst[t]] ) {            int temp = s;            s = lst[t];            lst[t] = temp;        }        t &gt;&gt;= 1;    }    // 以2^n次方来算，顶层败者编号为1，所以败者树数组lst[0]一定    // 没存东西，可以用来存放最后的冠军    lst[0] = s;}void create_loser_tree(int k){    int i = 0;    for( i; i &lt; k; i++ ) {        lst[i] = -1;    }    for( i = k - 1; i &gt;= 0; i-- ) {        adjust(k, i);    }}void k_merge(    int k ){    int i = 0;    FILE **ftemp = ( FILE * )malloc( sizeof(FILE *) * k );    FILE *fout = NULL;    // 归并路数大小的数组，每个数组值存放每一个归并路文件读取的    // 一个值，某一个索引的值写入输出文件，又读取对应文件下一个    // 值补充    buf = ( int * )malloc( sizeof(int) * k );    fout = fopen( OUTPUT_FILE, &quot;w+&quot; );    for ( i; i &lt; k; i++ ) {        char file_name[20] = {0};        snprintf( file_name, sizeof(file_name), TEMP_PREFIX&quot;%d&quot;, i );        ftemp[i] = fopen( file_name, &quot;r&quot; );        // 读取每个排序好的临时文件第一个数        fscanf( ( FILE * )ftemp[i], &quot;%d &quot;, buf + i );    }    // 以排好序文件第一个数的数组来创建败者树，    // 树结点产生败者，这样以后的每轮比较只需要    // 去文件或缓冲区读取下一个值加入败者树入口即可    create_loser_tree( k );    // 开始归并， 哪一个入口产生的冠军，先把冠军写入输出文件，    // 然后冠军所属的文件或缓冲区再读入一个数进行比赛，如果某一路    // 文件或缓冲区读到尾了，那么这个入口的参赛者为无限大，这样    // 与之共有一个父结点的兄弟结点每次读取的值都能成为胜者，参加    // 父结点以上的比较，到所有节点都读完时，最终败者结点，即lst[1]    // 为无穷大，再加入一个参赛者，lst[0]也为无穷大了，    while ( buf[lst[0]] != INFINITY ) {        // 读取冠军的值        int q = lst[0];        // 将冠军写入输出文件        fprintf(fout, &quot;%d\n&quot;, buf[q]);        // 读取冠军所属队列（文件或缓冲区）的下一个值        read_data(ftemp[q], &amp;buf[q]);        // 加入了一个新参赛者，调整败者树        adjust(k, q);    }    // 清理    free( buf );    for ( i = 0; i &lt; k; i++ ) {        fclose(ftemp[i]);    }}void memory_sort_small_file(    FILE *fp,    int num, // 待排序数的数量    int k ){    int i = 0;    int num_per_ways = num / k; // 每一路多少个数    int *buf = NULL;    FILE **ftemp = ( FILE * )malloc( sizeof(FILE *) * k );    buf = ( int * )malloc( sizeof(int) * num_per_ways + 1000 );    // for ( i = 0; i &lt; k; i++ ) {    //     char temp_buf[20] = {0};    //     snprintf( temp_buf, sizeof(temp_buf), TEMP_PREFIX&quot;%d&quot;, i);    //     ftemp[i] = fopen( temp_buf, &quot;w+&quot; );    //     if ( ftemp[i] == NULL ) {    //         printf(&quot;[%s:%d],error occured!!(%s)\n&quot;, __func__, __LINE__, strerror(errno));    //         exit( 0 );    //     }    // }    // 先不处理最后一个，可能总数/k路带余数，多余的    // 留到最后一个文件处理    k--;    while ( k &gt; 0 ) {        char temp_buf[20] = {0};        snprintf( temp_buf, sizeof(temp_buf), TEMP_PREFIX&quot;%d&quot;, k);        ftemp[k] = fopen( temp_buf, &quot;w+&quot; );        if ( ftemp[k] == NULL ) {            printf(&quot;[%s:%d],error occured!!(%s)\n&quot;, __func__, __LINE__, strerror(errno));            exit( 0 );        }        i = 0;        memset( buf, 0, sizeof(buf) );        for ( i; i &lt; num_per_ways; i++ ) {            fscanf(fp, &quot;%d &quot;, &amp;buf[i]);        }        printf(&quot;%s:%d, K:%d\n&quot;, __func__, __LINE__, k);        quick_sort( buf, 0, num_per_ways - 1 );        for ( i = 0; i &lt; num_per_ways; i++ ) {            fprintf(ftemp[k], &quot;%d &quot;, buf[i]);        }        fclose( ftemp[k] );        k--;    }    // 处理剩余的最后一个待排序文件    char temp_buf[20] = {0};    snprintf( temp_buf, sizeof(temp_buf), TEMP_PREFIX&quot;%d&quot;, 0);    ftemp[0] = fopen( temp_buf, &quot;w+&quot; );    if ( ftemp[0] == NULL ) {        printf(&quot;[%s:%d],error occured!!(%s)\n&quot;, __func__, __LINE__, strerror(errno));        exit( 0 );    }    i = 0;    while ( fscanf(fp, &quot;%d &quot;, &amp;buf[i]) != EOF ) i++;    printf(&quot;%s:%d, K:%d\n&quot;, __func__, __LINE__, 0);    quick_sort( buf, 0, i );    int j = 0;    for ( j = 0; j &lt;= i; j++ ) {        fprintf(ftemp[0], &quot;%d &quot;, buf[j]);    }    free( buf );    fclose( ftemp[0] );}int main(    int argc,    char **argv ){    if ( argc != 3 ) {        printf(&quot;usage:\n\t./xxx file_name k ways to merge\n&quot;);        exit( 0 );    }    int k = atoi( argv[2] );    char *file_name = argv[1];    FILE *fp = fopen(file_name, &quot;r&quot;);    if ( fp == NULL ) {        printf(&quot;[%s:%d],error occured!!(%s)\n&quot;, __func__, __LINE__, strerror(errno));        exit( 0 );    }    time_t t1 = time(NULL), t2, t3;    memory_sort_small_file( fp, 10000000, k );    t2 = time(NULL);    k_merge( k );    t3 = time(NULL);    printf(&quot;---------------------------finish-----------------------------\n&quot;);    printf(&quot;\tmemory sort &amp; ouput to temp file cost:  %ds\n&quot;, (int)(t2 - t1));    printf(&quot;\tk_merge &amp; ouput to file cost:  %ds\n&quot;, (int)(t3 - t2));    printf(&quot;\ttotal cost time:  %ds\n&quot;, (int)(t3 - t1));    printf(&quot;--------------------------------------------------------------\n&quot;);    fclose( fp );    return 0;}</code></pre><p>64路归并排序1000w个数用时：</p><p><img src="/img/out_sort1.png" alt="out_sort1"></p><p>生成文件：</p><p><img src="/img/out_sort2.png" alt="out_sort2"></p><p>排序后的文件头和尾：</p><p><img src="/img/out_sort3.png" alt="out_sort3"><br><img src="/img/out_sort4.png" alt="out_sort4"></p><p>代码注释写了很多了，以后忘了回头看看也能记起来 …..</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;问题：一个文件有大量的数，现要对文件排序，但内存无法一次读取完全，而磁盘空间足够，要如何排序。&lt;/p&gt;
&lt;p&gt;学习了几篇博客：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;july&lt;a href=&quot;https://blog.csdn.net/v_july_v/article/details/
      
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>trie树-《算法导论》学习笔记十四</title>
    <link href="http://yoursite.com/2018/06/20/025trie-tree/index/"/>
    <id>http://yoursite.com/2018/06/20/025trie-tree/index/</id>
    <published>2018-06-20T04:34:50.000Z</published>
    <updated>2018-06-20T04:38:29.448Z</updated>
    
    <content type="html"><![CDATA[<p>引用一下百度百科的话吧：<br>Trie树，又称单词查找树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p><p>这里构建了一棵字典树，每个结点有52个孩子指针，对应26个小写字母和26个大写字母，根节点不存储数据，一个单词从第一个字母开始经由根结点走对应分支进行插入和统计。</p><p>trie树结点卫星数据包含了字母、出现次数、是否构成一个单词，孩子指针就是一个52大小的trie树结点指针数组。</p><p>实现了几个操作：</p><h1 id="插入单词"><a href="#插入单词" class="headerlink" title="插入单词"></a>插入单词</h1><blockquote><p>遍历每个字母，从根结点出发，如果结点对应字母的孩子结点为空，就创建结点，出现次数为1，如果存在这个结点，出现次数就+1，并且如果单词结束，结束处的结点是否构成一个单词字段标识为构成</p></blockquote><h1 id="遍历树，并打印所有单词和每个单词出现次数"><a href="#遍历树，并打印所有单词和每个单词出现次数" class="headerlink" title="遍历树，并打印所有单词和每个单词出现次数"></a>遍历树，并打印所有单词和每个单词出现次数</h1><h1 id="统计树，按给定的数字统计出现次数前几的单词"><a href="#统计树，按给定的数字统计出现次数前几的单词" class="headerlink" title="统计树，按给定的数字统计出现次数前几的单词"></a>统计树，按给定的数字统计出现次数前几的单词</h1><blockquote><p>树统计，与遍历类似，用尾递归，并传入一个大于单词最大长度的数组来存储每个分支的单词，如果遇到结点能构成一个单词，就判断你单词个数，并以插入排序的方式插入创建的统计链表（类似打扑克的插排序）；<br> 统计链表有更新操作，根据输入的统计前几的数字来维护这个链表该去掉哪些结点，该更新哪些结点的顺序等</p></blockquote><p>##<br>获取单词来源为编写的一个简单单词随机生成代码，写入一个文件中，可指定单词最大长度，全大写/全小写/大小写均有，单词个数，单词范围（只支持a-<em>或A-</em>，例如5，就是生成a-e/A-E的单词）<br>贴代码：<br><strong>随机生成单词</strong></p><pre><code>#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int word_len = 0;int upper_low = 65;int lowwer_low = 97;// if letter_size = 5// it will generate a-e or A-E letter.int letter_size = 0;int random_letter(){    return rand() % letter_size;}int random_word(    char *word,    int opt ){    // minimum word&apos;length is 3.    int true_word_len = rand() % word_len + 3;    int true_word_len1 = true_word_len;    while ( true_word_len-- ) {        char letter = 0;        if ( opt == 0 ) {            letter = random_letter() + lowwer_low;        } else if ( opt == 1 ) {            letter = random_letter() + upper_low;        } else {            int opt_case = rand() % 2;            if ( opt_case == 0 )                letter = random_letter() + lowwer_low;            else                letter = random_letter() + upper_low;        }        word[true_word_len] = letter;    }    return true_word_len1;}void gen_word(    int fd,    int word_num,    int opt ){    char word[20] = {0};    int true_word_len = 0;    while ( word_num-- ) {        memset( word, 0, 20);        true_word_len = random_word( word, opt );        word[true_word_len] = &apos;\n&apos;;        write( fd, word, true_word_len + 1 );    }}int main(    int argc,    char **argv ){    srand((int)time(NULL));    if ( argc != 5 ) {        printf(&quot;please input &quot;                &quot;word&apos;s length &amp; &quot;                &quot;words&apos; number &amp; &quot;                &quot;word&apos;s range &amp; &quot;                &quot;gen_case(0:lowwer case,1:upper case,other:both\n&quot;);        exit( 0 );    }    word_len = atoi( argv[1] );    int word_num = atoi( argv[2] );    letter_size = atoi( argv[3] );    int opt = atoi( argv[4] );    int fd = open(&quot;word.txt&quot;, O_RDWR | O_TRUNC, 0777);    gen_word( fd, word_num, opt );    close( fd );    return 0;}</code></pre><p><strong>trie树</strong></p><pre><code>#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#define MAX_CHILD_NUM 52#define UPPER_LOW 65#define UPPER_UP 90#define LOWER_LOW 97#define LOWER_UP 122#define PRINT(format, arg...) \do { \    printf(&quot;[%s/%d]:&quot;, __func__, __LINE__); \    printf(format, ##arg); \    printf(&quot;\n&quot;); \}while(0)typedef struct trieTreeNode {    char letter;    int count;    int is_word;    struct trieTreeNode *next[MAX_CHILD_NUM];} trieTreeNode;typedef struct trieTree {    trieTreeNode *root;} trieTree;typedef struct count_data {    int order;    int count;    char string[20];    struct count_data *next;} count_data;int trans_letter_2_index(    char letter ){    int index = -1;    if ( letter &gt;= LOWER_LOW        &amp;&amp; letter &lt;= LOWER_UP ) {        index = letter - LOWER_LOW + 26;    } else if ( letter &gt;= UPPER_LOW        &amp;&amp; letter &lt;= UPPER_UP ) {        index = letter - UPPER_LOW;    } else {        PRINT(&quot;error letter input:%c&quot;, letter);        exit( 0 );    }    return index;}trieTreeNode *create_node(    char letter ){    trieTreeNode *node =        ( trieTreeNode * )calloc( 1, sizeof(trieTreeNode) );    node-&gt;letter = letter;    node-&gt;count = 0;    node-&gt;is_word = 0;}void insert(    trieTreeNode *root,    char *word ){    if ( root == NULL ) {        PRINT(&quot;root node is null.&quot;);        return;    }    int i = 0;    trieTreeNode *cur = root;    for ( i; word[i] != &apos;\0&apos;; i++ ) {        int next_index = trans_letter_2_index(word[i]);        //PRINT(&quot;letter:%c, index:%d&quot;, word[i], next_index);        if ( cur-&gt;next[next_index] == NULL ) {            cur-&gt;next[next_index] = create_node( word[i] );        } else {            //cur-&gt;next[next_index]-&gt;count += 1;        }        if ( word[i+1] == &apos;\0&apos; ) {            cur-&gt;next[next_index]-&gt;count += 1;            cur-&gt;next[next_index]-&gt;is_word = 1;        }        cur = cur-&gt;next[next_index];    }}// 删除链表所有结点void delete_list_all_node(    count_data *node ){    count_data *p = NULL;    while ( node ) {        p = node;        node = node-&gt;next;        free( p );    }}void print_list_all_node(    count_data *node ){    printf(&quot;\n&quot;);    node = node-&gt;next;    while ( node ) {        printf(&quot;[%d],count:%d\tword:%s\n&quot;,            node-&gt;order, node-&gt;count, node-&gt;string);        node = node-&gt;next;    }    printf(&quot;\n&quot;);}void update_insert_node(    count_data *insert_node ){    if ( !insert_node-&gt;next )        return;    count_data *print_p = insert_node;    if ( insert_node-&gt;order == 1 ) {        delete_list_all_node( insert_node-&gt;next );        insert_node-&gt;next = NULL;    } else if ( insert_node-&gt;order &lt; 1 ) {        PRINT(&quot;ERROR!!!!!&quot;);        exit( 0 );    } else {        count_data *p = insert_node;        insert_node = insert_node-&gt;next;        while ( insert_node ) {            if ( insert_node-&gt;count &lt; p-&gt;count ) {                insert_node-&gt;order = p-&gt;order - 1;            } else if ( insert_node-&gt;count &gt; p-&gt;count ) {                PRINT(&quot;ERROR!!!cur-&gt;count:%d, pre-&gt;count:%d&quot;,                    insert_node-&gt;count, p-&gt;count);                exit( 0 );            } else {                insert_node-&gt;order = p-&gt;order;            }            if ( insert_node-&gt;order &lt; 1 ) {                delete_list_all_node( insert_node );                p-&gt;next = NULL;                break;            }            p = insert_node;            insert_node = insert_node-&gt;next;        }    }}void list_insert(    char *tmp_word,    int cur_count,    int tail,    count_data *head,    int top_num ){    tmp_word[tail] = &apos;\0&apos;;    count_data *new_data = ( count_data * )malloc( sizeof(count_data) );    new_data-&gt;count = cur_count;    memcpy( new_data-&gt;string, tmp_word, tail + 1 );    new_data-&gt;next = NULL;    //PRINT(&quot;count:%d\ttmp_word:%s, string:%s&quot;, cur_count, tmp_word, new_data-&gt;string);    if ( head-&gt;next == NULL ) {        head-&gt;next = new_data;        new_data-&gt;order = top_num;    } else if ( cur_count &gt; head-&gt;next-&gt;count ) {        new_data-&gt;order = head-&gt;next-&gt;order;        new_data-&gt;next = head-&gt;next;        head-&gt;next = new_data;        update_insert_node( new_data );    } else {        while ( 1 ) {            head = head-&gt;next;            if ( head-&gt;next == NULL ) {                if ( head-&gt;order &gt; 1 ) {                    head-&gt;next = new_data;                    if ( head-&gt;count == new_data-&gt;count )                        new_data-&gt;order = head-&gt;order;                    else                        new_data-&gt;order = head-&gt;order - 1;                    head-&gt;next = new_data;                } else if ( head-&gt;count &gt; new_data-&gt;count ) {                    // 不插入                    free( new_data );                } else if ( head-&gt;count == new_data-&gt;count ) {                    head-&gt;next = new_data;                    new_data-&gt;order = head-&gt;order;                } else if ( head-&gt;count &lt; new_data-&gt;count ) {                    // 此种情况只有求出现次数最多的前1个单词时有                    head-&gt;count = new_data-&gt;count;                    free( new_data );                }                break;            } else if ( head-&gt;count &gt;= cur_count                &amp;&amp; head-&gt;next-&gt;count &lt; cur_count ) {                new_data-&gt;next = head-&gt;next;                head-&gt;next = new_data;                new_data-&gt;order = head-&gt;order;                update_insert_node( new_data );                break;            }        }    }}void find_top_count1(    trieTreeNode *root,    char *tmp_word,    int tail,    count_data *head,    int top_num ){    if ( !root )        return;    tmp_word[tail] = root-&gt;letter;    tail++;    if ( root-&gt;is_word ) {        /*        printf(&quot;\n--------------before delete------------------\n&quot;);        print_list_all_node( head );        printf(&quot;\n--------------------------------------------\n&quot;);        */        list_insert( tmp_word, root-&gt;count, tail, head, top_num );        /*        printf(&quot;\n--------------------after delete----------------------------\n&quot;);        print_list_all_node( head );        printf(&quot;\n-----------------------------------------------------------\n&quot;);        */    }    int i = 0;    for ( i; i &lt; MAX_CHILD_NUM; i++ ) {        find_top_count1( root-&gt;next[i], tmp_word, tail, head, top_num );    }}void find_top_count(    trieTreeNode *root,    int top_num ){    if ( !root )        return;    int i = 0;    count_data *head = ( count_data * )malloc( sizeof(count_data) );    for ( i; i &lt; MAX_CHILD_NUM; i++ ) {        char tmp_word[20] = {0};        find_top_count1( root-&gt;next[i], tmp_word, 0, head, top_num );    }    printf(&quot;出现次数最大前%d次的单词:\n&quot;, top_num);    count_data *p = head-&gt;next;    count_data *free_p = NULL;    while ( p != NULL ) {        free_p = p;        printf(&quot;前%d,count:%d\t%s\n&quot;, p-&gt;order, p-&gt;count, p-&gt;string);        p = p-&gt;next;        free( free_p );    }    free( head );}void tree_walk1(    trieTreeNode *root,    char *tmp_word,    int tail ){    if ( !root )        return;    tmp_word[tail] = root-&gt;letter;    tail++;    //printf(&quot;%c\n&quot;, root-&gt;letter);    if ( root-&gt;is_word ) {        int j = 0;        printf(&quot;count:%d\t&quot;, root-&gt;count);        for ( j; j &lt; tail; j++ ) {            printf(&quot;%c&quot;, tmp_word[j]);        }        printf(&quot;\n&quot;);    }    int i = 0;    for ( i; i &lt; MAX_CHILD_NUM; i++ ) {        tree_walk1( root-&gt;next[i], tmp_word, tail );    }}void tree_walk(    trieTreeNode *root ){    if ( !root )        return;    int i = 0;    for ( i; i &lt; MAX_CHILD_NUM; i++ ) {        char tmp_word[20] = {0};        tree_walk1( root-&gt;next[i], tmp_word, 0 );    }}int main(    int argc,    char **argv ){    if ( argc != 3 ) {        PRINT(&quot;USAGE: please input words file &amp; top number&quot;);        exit( 0 );    }    char *file_name = argv[1];    int top_num = atoi( argv[2] );    trieTree *tree = ( trieTree * )malloc( sizeof(trieTree) );    tree-&gt;root = create_node( -1 );    int fd = open(file_name, O_RDONLY);    if ( fd &lt; 0 ) {        PRINT(&quot;OPEN FILE %s ERROR!!!(%s)&quot;, file_name, (char *)strerror(errno));        exit( 0 );    }    // 每次读取文件的缓冲区    char buf[1024 * 10] = {0};    // 每次读取的大小    int read_len = 1024;    // 读取的返回值    int read_bytes = 0;    // 从读取的缓冲区每次提取&apos;\n&apos; - &apos;\n&apos;之间的单词    char tmp_word[20] = {0};    // 读取文件缓冲区如果出现单词隔断，剩余部分在下一次    // read才能读到，这个index做单词继续拼接    int tmp_index = 0;    while ( 1 ) {        memset( buf, 0, read_len );        read_bytes = read( fd, buf, read_len );        if ( read_bytes &lt;= 0 )            break;        //printf(&quot;readbytes:%d------\n%s\n&quot;, read_bytes, buf);        int cur = 0;        while ( cur &lt; read_bytes ) {            // 单词文件最后一个单词末尾一定要有&apos;\n&apos;            if ( buf[cur] == &apos;\n&apos; ) {                tmp_word[tmp_index] = &apos;\0&apos;;                //printf(&quot;insert word:%s\n&quot;, tmp_word);                insert( tree-&gt;root, tmp_word );                memset( tmp_word, 0, 20 );                tmp_index = 0;            } else {                tmp_word[tmp_index] = buf[cur];                tmp_index++;            }            cur++;        }    }    printf(&quot;\n========================================\n&quot;);    tree_walk( tree-&gt;root );    find_top_count( tree-&gt;root, top_num );    close( fd );    return 0;}</code></pre><p>trie树的代码使用：./xxx word.txt 10即统计出现次数前10的单词，并打印单词和次数</p><p>例如对生成了10000个单词的word.txt文件，统计前5：<br>./xxx word.txt 5</p><p><img src="/img/trie_tree.png" alt="trie_tree"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引用一下百度百科的话吧：&lt;br&gt;Trie树，又称单词查找树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串
      
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>avl树-《算法导论》学习笔记十三</title>
    <link href="http://yoursite.com/2018/06/20/024avl-tree/index/"/>
    <id>http://yoursite.com/2018/06/20/024avl-tree/index/</id>
    <published>2018-06-20T02:55:19.000Z</published>
    <updated>2018-06-20T04:39:26.707Z</updated>
    
    <content type="html"><![CDATA[<p>（引用算法导论）AVL树是一种高度平衡的二叉搜索树：对每一个结点x，y的左子树与右子树的高度至多为1。AVL树相比二叉搜索树，每个结点维护一个额外的属性：结点的高度。</p><p>AVL树实现了几个操作：</p><h1 id="树结点创建"><a href="#树结点创建" class="headerlink" title="树结点创建"></a>树结点创建</h1><h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><blockquote><p>递归的前序、中序、后序遍历，以及基于层序遍历的简单图形打印</p></blockquote><h1 id="后序遍历释放树结点"><a href="#后序遍历释放树结点" class="headerlink" title="后序遍历释放树结点"></a>后序遍历释放树结点</h1><h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h1 id="寻找结点子树最小关键字结点、寻找结点子树最大关键字结点"><a href="#寻找结点子树最小关键字结点、寻找结点子树最大关键字结点" class="headerlink" title="寻找结点子树最小关键字结点、寻找结点子树最大关键字结点"></a>寻找结点子树最小关键字结点、寻找结点子树最大关键字结点</h1><h1 id="求结点高度"><a href="#求结点高度" class="headerlink" title="求结点高度"></a>求结点高度</h1><h1 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h1><h1 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h1><h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><blockquote><p>先以普通二叉搜索树的方式插入结点；</p><p>插入结点后可能影响平衡（一个子树高度-另一子树高度等于2），具体的不平衡的情况分四种：</p><ol><li>结点左子树高度-右子树高度=2，且结点左孩子的左子树更高</li><li>结点左子树高度-右子树高度=2，且结点右孩子的右子树更高</li><li>结点右子树高度-左子树高度=2，且结点右孩子的右子树更高</li><li>结点右子树高度-左子树高度=2，且结点右孩子的左子树更高</li></ol><p>对于情况1，只需对结点进行右旋即可重新平衡；</p><p>对于情况3，只需对结点进行左旋即可重新平衡；</p><p>对于情况2，需要先对结点的左孩子进行左旋，然后对结点进行右旋即可平衡；</p><p>对于情况4，需要先对结点的右孩子进行右旋，然后对结点进行左旋即可平衡；</p><p>旋转之后，结点的左子树与右子树达到平衡，但结点父结点的树可能不平衡，</p><p>需要循环向根节点判断结点高度有无平衡，直至根节点。</p></blockquote><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><blockquote><ol><li><p>先查询相同的key的结点；</p></li><li><p>找到待删除结点，如果待删除结点的左孩子与右孩子都不为空，则判断左右孩子的树高：</p></li></ol><ul><li>若左子树更高，则将左子树的最大关键字结点的关键字替换掉待删除结点的关键字，然后再删除那个左子树最大关键字结点</li><li>若右子树与左子树同高或更高，则将右子树的最小关键字结点的关键字替换掉待删除节点的关键字，然后再删除那个右子树最小关键字结点</li></ul><ol start="3"><li>删除结点后，会影响树平衡，具体不平衡情况与插入时相同，依然进行相同操作来重新平衡树</li></ol></blockquote><p>#</p><p>代码:</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#include &lt;math.h&gt;#define MAX(a, b) ((a &gt; b) ? (a) : (b))typedef struct avlTreeNode {    int key;    int height;    //这里有父结点，有了父结点多很多代码，    //大部分的调试都是父结点的值没注意，    //可取消这个字段    struct avlTreeNode *parent;    struct avlTreeNode *left;    struct avlTreeNode *right;}avlTreeNode;typedef struct avlTree {    int node_num;    avlTreeNode *root;}avlTree;// 随机基数尽量大，代码不支持key值相同的// 树节点，但不影响插入，删除会出错，所以// 尽量保证不同int random_num(){    int a = 1;    int b = 10000;    return rand() % ( b - a ) + a;}avlTreeNode *tree_create_node(    int key,    avlTreeNode *parent,    avlTreeNode *left,    avlTreeNode *right ){    avlTreeNode *node = ( avlTreeNode * )malloc( sizeof(avlTreeNode) );    node-&gt;height = 1;    node-&gt;key = key;    node-&gt;parent = parent;    node-&gt;left = left;    node-&gt;right = right;    return node;}//后续遍历释放树结点void postorder_tree_free(    avlTreeNode *root ){    if ( root != NULL ) {        postorder_tree_free( root-&gt;left );        postorder_tree_free( root-&gt;right );        printf(&quot;%d &quot;, root-&gt;key);        free( root );    }}void inorder_tree_walk(    avlTreeNode *root ){    if ( root != NULL ) {        inorder_tree_walk( root-&gt;left );        printf(&quot;%d(%d) &quot;, root-&gt;key, root-&gt;height);        inorder_tree_walk( root-&gt;right );    }}void preorder_tree_walk(    avlTreeNode *root ){    if ( root != NULL ) {        printf(&quot;%d(%d) &quot;, root-&gt;key, root-&gt;height);        preorder_tree_walk( root-&gt;left );        preorder_tree_walk( root-&gt;right );    }}void postorder_tree_walk(    avlTreeNode *root ){    if ( root != NULL ) {        postorder_tree_walk( root-&gt;left );        postorder_tree_walk( root-&gt;right );        printf(&quot;%d(%d) &quot;, root-&gt;key, root-&gt;height);    }}//层序遍历，支持简单的树形打印//为了调试代码，而不用中序和前序//去推算树int queue_pre = -1;int queue_post = 0;avlTreeNode *node_queue[1000] = {NULL};int factor( int n ){    if ( n == 1 )        return 1;    return (pow(2,n-1) + factor( n - 1 ));}void graph_tree_walk(    avlTreeNode *root,    int height,    int root_height ){    if ( queue_pre == factor( root_height ) - 1 )        return ;    queue_pre++;    if ( root == NULL ) {        printf(&quot;* &quot;);        node_queue[queue_post] = NULL;        queue_post++;        node_queue[queue_post] = NULL;        queue_post++;    } else {        node_queue[queue_post] = root-&gt;left;        queue_post++;        node_queue[queue_post] = root-&gt;right;        queue_post++;        printf(&quot;%d &quot;, root-&gt;key);    }    int new_height = height;    if ( queue_pre == factor( height ) - 1 ) {        printf(&quot;\n&quot;);        new_height = height + 1;    }    graph_tree_walk( node_queue[queue_pre], new_height, root_height );}void print_tree(    avlTree *tree ){    printf(&quot;中序:&quot;);    inorder_tree_walk( tree-&gt;root );    printf(&quot;\n&quot;);    printf(&quot;前序:&quot;);    preorder_tree_walk( tree-&gt;root );    printf(&quot;\n&quot;);    printf(&quot;后序:&quot;);    postorder_tree_walk( tree-&gt;root );    printf(&quot;\n&quot;);    printf(&quot;图形:\n&quot;);    graph_tree_walk( tree-&gt;root, 1, tree-&gt;root-&gt;height );    queue_pre = -1;    queue_post = 0;    int i = 999;    for ( i ; i &gt;=0; i-- )        node_queue[i] = NULL;    printf(&quot;\n\n&quot;);}//检查avl树的树高是否差2以内int check_is_avltree(    avlTreeNode *root ){    if ( root == NULL )        return 0;    int left_height = check_is_avltree( root-&gt;left );    int right_height = check_is_avltree( root-&gt;right );    if ( left_height - right_height &gt;= 2 || right_height - left_height &gt;= 2 )        printf(&quot;it&apos;s not a avl tree!!!! l:%d, r:%d\n&quot;, left_height, right_height);    else        //printf(&quot;left:%d,right:%d\n&quot;, left_height, right_height);    return (left_height &gt; right_height ? left_height : right_height ) + 1;}avlTreeNode *tree_search_recursion(    avlTreeNode *root,    int key ){    if ( root == NULL || key == root-&gt;key ) {        return root;    }    if ( key &lt; root-&gt;key )        return tree_search_recursion( root-&gt;left, key );    else        return tree_search_recursion( root-&gt;right, key );}avlTreeNode *tree_search(    avlTreeNode *root,    int key ){    while ( root != NULL &amp;&amp; key != root-&gt;key ) {        if ( key &lt; root-&gt;key )            root = root-&gt;left;        else            root = root-&gt;right;    }    return root;}avlTreeNode *tree_minimum(    avlTreeNode *root ){    while ( root-&gt;left != NULL ) {        root = root-&gt;left;    }    return root;}avlTreeNode *tree_maximum(    avlTreeNode *root ){    while ( root-&gt;right != NULL ) {        root = root-&gt;right;    }    return root;}int node_height(    avlTreeNode *node ){    if ( node == NULL )        return 0;    return node-&gt;height;}int tree_height(    avlTree *tree ){    return node_height( tree-&gt;root );}avlTreeNode *left_rotate(    avlTreeNode *node ){    if ( node != NULL &amp;&amp; node-&gt;right != NULL ) {        avlTreeNode *p = node-&gt;right-&gt;left;        if ( node-&gt;parent == NULL ) {            node-&gt;right-&gt;parent = NULL;        } else if ( node == node-&gt;parent-&gt;left ) {            node-&gt;parent-&gt;left = node-&gt;right;            node-&gt;right-&gt;parent = node-&gt;parent;        } else {            node-&gt;parent-&gt;right = node-&gt;right;            node-&gt;right-&gt;parent = node-&gt;parent;        }        node-&gt;parent = node-&gt;right;        node-&gt;right-&gt;left = node;        node-&gt;right = p;        if ( p != NULL )            p-&gt;parent = node;        node-&gt;height = MAX( node_height(node-&gt;left),                            node_height(node-&gt;right) ) + 1;        node-&gt;parent-&gt;height = MAX( node_height(node-&gt;parent-&gt;left),                                    node_height(node-&gt;parent-&gt;right) ) + 1;        return node-&gt;parent;    }    return node;}avlTreeNode *right_rotate(    avlTreeNode *node ){    if ( node != NULL &amp;&amp; node-&gt;left != NULL ) {        avlTreeNode *p = node-&gt;left-&gt;right;        if ( node-&gt;parent == NULL ) {            node-&gt;left-&gt;parent = NULL;        } else if ( node == node-&gt;parent-&gt;left ) {            node-&gt;parent-&gt;left = node-&gt;left;            node-&gt;left-&gt;parent = node-&gt;parent;        } else {            node-&gt;parent-&gt;right = node-&gt;left;            node-&gt;left-&gt;parent = node-&gt;parent;        }        node-&gt;parent = node-&gt;left;        node-&gt;left-&gt;right = node;        node-&gt;left = p;        if ( p != NULL )            p-&gt;parent = node;        node-&gt;height = MAX( node_height(node-&gt;left),                            node_height(node-&gt;right) ) + 1;        node-&gt;parent-&gt;height = MAX( node_height(node-&gt;parent-&gt;right),                                    node_height(node-&gt;parent-&gt;left) ) + 1;        return node-&gt;parent;    }    return node;}avlTreeNode *tree_insert1(    avlTreeNode *root,    avlTreeNode *node ){    if ( root == NULL ) {        node-&gt;height = 1;        return node;    } else if ( node-&gt;key &lt; root-&gt;key ) {        root-&gt;left = tree_insert1( root-&gt;left, node );        root-&gt;left-&gt;parent = root;        if ( node_height( root-&gt;left ) - node_height( root-&gt;right ) == 2 ) {            if ( node-&gt;key &lt; root-&gt;left-&gt;key ) {                // right rotate;                root = right_rotate( root );            } else {                // left right rotate;                root-&gt;left = left_rotate( root-&gt;left );                root = right_rotate( root );            }        }        root-&gt;height = MAX( node_height(root-&gt;left), node_height(root-&gt;right) ) + 1;    } else {        root-&gt;right = tree_insert1( root-&gt;right, node );        root-&gt;right-&gt;parent = root;        if ( node_height( root-&gt;right ) - node_height( root-&gt;left ) == 2 ) {            if ( node-&gt;key &gt;= root-&gt;right-&gt;key ) {                root = left_rotate( root );            } else {                root-&gt;right = right_rotate( root-&gt;right );                root = left_rotate( root );            }        }        root-&gt;height = MAX( node_height(root-&gt;right), node_height(root-&gt;left) ) + 1;    }    return root;}void tree_insert(    avlTree *tree,    int key ){    avlTreeNode *node = tree_create_node( key, NULL, NULL, NULL );    if ( tree-&gt;root == NULL ) {        tree-&gt;root = node;    } else {        tree-&gt;root = tree_insert1( tree-&gt;root, node );    }}avlTreeNode *tree_delete1(    avlTreeNode *root,    int key ){    if ( root == NULL )        return NULL;    if ( key &lt; root-&gt;key ) {        root-&gt;left = tree_delete1( root-&gt;left, key );        if ( node_height(root-&gt;right) - node_height(root-&gt;left) == 2 ) {            if ( node_height(root-&gt;right-&gt;left) &gt; node_height(root-&gt;right-&gt;right) ) {                root-&gt;right = right_rotate( root-&gt;right );                root = left_rotate( root );            } else {                root = left_rotate( root );            }        }    } else if ( key &gt; root-&gt;key ) {        root-&gt;right = tree_delete1( root-&gt;right, key );        if ( node_height(root-&gt;left) - node_height(root-&gt;right) == 2 ) {            if ( node_height(root-&gt;left-&gt;right) &gt; node_height(root-&gt;left-&gt;left) ) {                root-&gt;left = left_rotate( root-&gt;left );                root = right_rotate( root );            } else {                root = right_rotate( root );            }        }    } else {        if ( root-&gt;left != NULL &amp;&amp; root-&gt;right != NULL ) {            avlTreeNode *replace = NULL;            // 这里做了替换后要删除最大值结点，但匹配无法确认同key值的不同结点            // ，因此树不能有相同key值的结点，但插入没有这个问题            if ( node_height(root-&gt;left) &gt; node_height(root-&gt;right) ) {                replace = tree_maximum( root-&gt;left );                root-&gt;key = replace-&gt;key;                root-&gt;left = tree_delete1( root-&gt;left, replace-&gt;key );            } else {                replace = tree_minimum( root-&gt;right );                root-&gt;key = replace-&gt;key;                root-&gt;right = tree_delete1( root-&gt;right, replace-&gt;key );            }        } else {            avlTreeNode *delete = root;            if ( root-&gt;left ) {                root-&gt;left-&gt;parent = root-&gt;parent;                root = delete-&gt;left;            } else if ( root-&gt;right ) {                root-&gt;right-&gt;parent = root-&gt;parent;                root = delete-&gt;right;            } else {                root = NULL;            }            free( delete );        }    }    if ( root != NULL )        root-&gt;height = MAX( node_height(root-&gt;left), node_height(root-&gt;right) ) + 1;    return root;}void tree_delete(    avlTree *tree,    int key ){    if ( tree-&gt;root != NULL ) {        tree-&gt;root = tree_delete1( tree-&gt;root, key );    }}void free_tree(    avlTree *tree ){    printf(&quot;\ndelete tree node...\n&quot;);    postorder_tree_free( tree-&gt;root );    tree-&gt;root = NULL;    printf(&quot;\ndelete tree...\n&quot;);    free( tree );    printf(&quot;free tree over!\n&quot;);}int main(    int argc,    char **argv ){    srand((int)time(NULL));    int i = 10;    int len = 20;    int arr[10] = {10,4,15,14,5, 2,8,13,1,19};    avlTree *tree = ( avlTree * )malloc( sizeof(avlTree) );    int delete_key_a, delete_key_b, delete_key_c;    for ( i = 0; i &lt; len; i++ ) {        //tree_insert( tree, arr[i] );        int randomnum = random_num();        if ( i == 2 )            delete_key_a = randomnum;        if ( i == 5 )            delete_key_b = randomnum;        if ( i == 9 )            delete_key_c = randomnum;        //printf(&quot;randon num:%d\n&quot;, randomnum);        tree_insert( tree, randomnum );    }    print_tree( tree );    check_is_avltree( tree-&gt;root );    printf(&quot;删除结点%d\n&quot;, delete_key_a);    tree_delete( tree, delete_key_a );    print_tree( tree );    check_is_avltree( tree-&gt;root );    tree_delete( tree, delete_key_b );    printf(&quot;删除结点%d\n&quot;, delete_key_b );    print_tree( tree );    check_is_avltree( tree-&gt;root );    tree_delete( tree, delete_key_c );    printf(&quot;删除结点%d\n&quot;, delete_key_c );    print_tree( tree );    check_is_avltree( tree-&gt;root );    printf(&quot;\n===========================================free================================================\n&quot;);    free_tree( tree );    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;（引用算法导论）AVL树是一种高度平衡的二叉搜索树：对每一个结点x，y的左子树与右子树的高度至多为1。AVL树相比二叉搜索树，每个结点维护一个额外的属性：结点的高度。&lt;/p&gt;
&lt;p&gt;AVL树实现了几个操作：&lt;/p&gt;
&lt;h1 id=&quot;树结点创建&quot;&gt;&lt;a href=&quot;#树结点创
      
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>红黑树-《算法导论》学习笔记十二</title>
    <link href="http://yoursite.com/2018/06/19/023red-black-tree/index/"/>
    <id>http://yoursite.com/2018/06/19/023red-black-tree/index/</id>
    <published>2018-06-19T12:38:53.000Z</published>
    <updated>2018-06-20T04:39:52.623Z</updated>
    
    <content type="html"><![CDATA[<p>红黑树是一种二叉搜索树，它在每个结点上增加了一个存储为来表示结点的颜色，或红或黑，通过从根到叶子的简单路径上各个结点的颜色进行约束，红黑树确保没有一条路径会比其它路径长出2倍，近似平衡的。</p><p>树种每个结点包含5个属性：color、key、left、right、parent，如果一个结点没有子结点或父结点，则该结点相应指针属性值指向空（这里的空不是空指针，而是定义一个空结点，结点颜色为黑色），一颗红黑树是满足几个特殊性质的二叉搜索树：</p><ul><li>每个结点或是红色的，或是黑色的</li><li>根结点是黑色的</li><li>每个叶结点（亦即空结点）为黑色的</li><li>如果一个结点是红色的，则它的两个子结点都是黑色的</li><li>对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点（经过的黑色结点数为黑高）</li></ul><p>与二叉搜索树相似，红黑树也有一些操作接口：</p><ul><li>遍历</li><li>寻找结点中序遍历的后继:tree_minimum</li><li>寻找结点中序遍历的前驱:tree_maximum</li><li>结点左右旋转（红黑树不同于二叉搜索树的操作），用来平衡黑高<ul><li>左旋：结点的父结点的左孩子指向结点的右孩子，右孩子的左孩子变为结点的右孩子，右孩子变为它的父结点</li><li>右旋：结点的父结点的右孩子指向结点的左孩子，做孩子的右孩子变为结点的左孩子，左孩子变为它的父结点*</li></ul></li><li>插入，插入一个新结点时，考虑如果插入黑色结点，破坏了原树的红黑性质（黑高），要进行重新平衡</li><li>删除，删除了一个结点后，考虑如果删除的是黑色结点，或删除了结点，后继提升到删除节点的位置后，平衡红黑性质</li></ul><p><strong>———-插入</strong></p><ol><li><p>如果结点的父结点为黑色，表示没插入这个结点前满足红黑树<br>性质，且插入这个红色结点后，也不影响红黑树黑高，故保持当前位置</p></li><li><p>如果结点的父结点为红色，那么判断插入结点与父结点，以及父结点的<br>父结点，叔结点，这四个结点是否组成一个倒立的”v”字形：</p><p> (1). 如果是倒立”v”，则插入结点的父结点为红色，破坏了红黑树的：红<br>色结点的左右孩子都为黑色的性质，故父结点一定要变为黑色;<br>那么将父结点变为黑色;</p><p> 判断叔结点若为红色，则将叔结点变为黑色，父结点的父结点变为红色，<br>插入结点的指针指向父结点的父结点，再次从步骤1判断（因为经过变换，<br>从插入结点的父结点的父结点开始的子数都满足红黑树性质，只需要将<br>父结点的父结点单独当作一个新插入它的父结点的子结点再进行处理即可）;</p><p> 否则叔结点为黑色，则直接将父结点的父结点变为红色，但是这样做之后，<br>父结点因为变为黑色，而叔结点还是黑色，两个子树路径的黑高相差1,要<br>维持黑高相等，则将父结点的父结点的父结点向叔结点相同的方向旋转（<br>可以针对这种情况画图，会发现这样旋转后，两个黑高不一样的子树分开了，<br>，且满足红黑树性质）。</p><p> (2). 如果不是倒立”v”，即插入结点的父结点所处子树为某方向上的子树，但插入<br>结点又是父结点另一方的孩子结点，则只需要进行一下旋转，就将结点变为<br>倒立的”v”形状，继续从步骤1开始作为倒立”v”子树判断。</p></li><li><p>将根结点变为黑色</p></li></ol><p><strong>———-删除</strong></p><ol><li><p>以指针p指向待删除结点node，p_color记录node颜色</p></li><li><p>判断node的左右孩子<br> (1). 如果左孩子为空<br>寻找node的右孩子，记为q（不管是否指向空）<br>用q结点替换node结点</p><p> (2). 但如果右孩子为空<br>寻找node的左孩子，记为q（不管是否指向空）<br>用q结点替换node结点</p><p> (3). 否则左右孩子都不为空<br>寻找node的中序遍历后继(tree_minimum())，p指向它;</p><p> p_color记录后继的颜色;</p><p> q指向p的右结点（不管是否为空）;</p><p> 判断p的父结点是否为node:是，则， q的父结点设为p（只有当q为空结点时有用）/否，则，用p的右结点替换p(rb_transplant(tree, p, p-&gt;right))，用p结点接管node结点右子树（p-&gt;right = node-&gt;right, p-&gt;right-&gt;parent = p）;</p><p> 用p结点替换node结点(rb_transplant(tree, node, p));</p><p> p结点接管node结点左子树(p-&gt;left = node-&gt;left,p-&gt;left-&gt;parent = p);</p><p> p结点的颜色设置为node结点的颜色</p></li><li><p>判断p_color的颜色如果为黑色，表示删除结点后，黑高可能-1,<br>要修复红黑树，从结点q处开始修复红黑树，根据q的颜色来修复</p></li><li><p>循环.直到q结点不为根结点以及p结点的颜色不为黑色</p><p> (1). 如果node的兄弟结点为红色<br>（因为node结点替换了删除结点，黑高-1,与兄弟结点子树黑高差1）<br>设置兄弟结点为黑色，父结点设置为红色，从父结点开始向node一侧旋转，兄弟结点成为新的子树根结点，因为兄弟结点为黑色，则经过兄弟结点到node结点的子树黑高+1,平衡，但对于兄弟结点的父结点的子树，黑高又可能不平衡，node指针指向兄弟结点，继续步骤4</p><p> (2). 如果node的兄弟结点为黑色，且兄弟结点的左右孩子均为黑色<br>（因为node结点替换了删除结点，黑高-1,与兄弟结点子树黑高差1）<br>设置兄弟结点颜色为红色，兄弟结点子树黑高-1,达到平衡，但父结点以上的子树可能受影响，node指针指向父结点，继续步骤4</p><p> (3). 如果node的兄弟结点为黑色，且兄弟结点的靠近node一侧的孩子结点颜色为红色，另一侧的孩子结点为黑色<br>（因为node结点替换了删除结点，黑高-1,与兄弟结点子树黑高差1）<br>兄弟结点靠近node一侧的孩子结点设置为黑色，兄弟结点设置为红色，从兄弟结点开始进行向远离node一侧旋转，兄弟结点的孩子结点成为它的父结点，原兄弟结点的左右子树黑高不变，但node结点所处子树因为替换删除结点，黑高-1，还是没有平衡，node指针指向新的兄弟结点的孩子结点，继续4</p><p> (4). 如果node的兄弟结点为黑色，且兄弟结点的远离node一侧的孩子结点颜色为红色，另一侧颜色未知<br>（因为node结点替换了删除结点，黑高-1,与兄弟结点子树黑高差1）<br>兄弟结点设置为node父结点的颜色，父结点设置为黑色，兄弟结点为红色的设置为黑色，然后从node父结点开始进行向node一侧旋转，旋转前，可以思考，父结点若为红色，旋转后不改变子树黑高，若父结点为黑色，旋转后也不会改变黑高经过一轮变换后，node结点的父结点的父结点左右子树黑高一样，且经过node替换后-1的黑高，因为变换，又+1,本子树在整个红黑树中没有破坏黑高一致性，故将node指针指向整个树的根结点，跳出循环<br>设置node指针的结点颜色为黑色</p></li></ol><p>代码：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;//#define COLOR_RED   1;//#define COLOR_BLACK 2;typedef enum color {    COLOR_RED,    COLOR_BLACK}color;typedef struct rbTreeNode {    int key;    color color;    struct rbTreeNode *parent;    struct rbTreeNode *left;    struct rbTreeNode *right;}rbTreeNode;typedef struct rbTree {    int node_num;    int height;    rbTreeNode *root;    rbTreeNode *null;}rbTree;void print_tree( rbTree * );rbTreeNode *tree_minimum(    rbTreeNode *root,    rbTreeNode *null ){    while ( root-&gt;left != null ) {        root = root-&gt;left;    }    return root;}rbTreeNode *tree_maximum(    rbTreeNode *root,    rbTreeNode *null ){    while ( root-&gt;right != null ) {        root = root-&gt;right;    }    return root;}void left_rotate(    rbTree *tree,    rbTreeNode *node ){    rbTreeNode *p = node-&gt;right;    node-&gt;right = p-&gt;left;    if ( p-&gt;left != tree-&gt;null )        p-&gt;left-&gt;parent = node;    p-&gt;parent = node-&gt;parent;    if ( node-&gt;parent == tree-&gt;null )        tree-&gt;root = p;    else if ( node == node-&gt;parent-&gt;left )        node-&gt;parent-&gt;left = p;    else        node-&gt;parent-&gt;right = p;    p-&gt;left = node;    node-&gt;parent = p;}void right_rotate(    rbTree *tree,    rbTreeNode *node ){    rbTreeNode *p = node-&gt;left;    node-&gt;left = p-&gt;right;    if ( p-&gt;right != tree-&gt;null )        p-&gt;right-&gt;parent = node;    p-&gt;parent = node-&gt;parent;    if ( node-&gt;parent == tree-&gt;null )        tree-&gt;root = p;    else if ( node == node-&gt;parent-&gt;right )        node-&gt;parent-&gt;right = p;    else        node-&gt;parent-&gt;left = p;    p-&gt;right = node;    node-&gt;parent = p;}void rb_insert_fixup(    rbTree *tree,    rbTreeNode *node ){    rbTreeNode *p = tree-&gt;null;    while ( node-&gt;parent-&gt;color == COLOR_RED ) {        if ( node-&gt;parent == node-&gt;parent-&gt;parent-&gt;left ) {            p = node-&gt;parent-&gt;parent-&gt;right;            if ( p-&gt;color == COLOR_RED ) {                node-&gt;parent-&gt;color = COLOR_BLACK;                p-&gt;color = COLOR_BLACK;                node-&gt;parent-&gt;parent-&gt;color = COLOR_RED;                node = node-&gt;parent-&gt;parent;            } else if ( node == node-&gt;parent-&gt;right ) {                node = node-&gt;parent;                left_rotate( tree, node );            } else {                node-&gt;parent-&gt;color = COLOR_BLACK;                node-&gt;parent-&gt;parent-&gt;color = COLOR_RED;                right_rotate( tree, node-&gt;parent-&gt;parent );            }        } else {            p = node-&gt;parent-&gt;parent-&gt;left;            if ( p-&gt;color == COLOR_RED ) {                node-&gt;parent-&gt;color = COLOR_BLACK;                p-&gt;color = COLOR_BLACK;                node-&gt;parent-&gt;parent-&gt;color = COLOR_RED;                node = node-&gt;parent-&gt;parent;            } else if ( node == node-&gt;parent-&gt;left ) {                node = node-&gt;parent;                right_rotate( tree, node );            } else {                node-&gt;parent-&gt;color = COLOR_BLACK;                node-&gt;parent-&gt;parent-&gt;color = COLOR_RED;                left_rotate( tree, node-&gt;parent-&gt;parent );            }        }    }    tree-&gt;root-&gt;color = COLOR_BLACK;}void rb_insert(    rbTree *tree,    rbTreeNode *node ){    rbTreeNode *p = tree-&gt;null;    rbTreeNode *q = tree-&gt;root;    while ( q != tree-&gt;null ) {        p = q;        if ( node-&gt;key &lt; q-&gt;key )            q = q-&gt;left;        else            q = q-&gt;right;    }    node-&gt;parent = p;    if ( p == tree-&gt;null )        tree-&gt;root = node;    else if ( node-&gt;key &lt; p-&gt;key )        p-&gt;left = node;    else        p-&gt;right = node;    node-&gt;left = tree-&gt;null;    node-&gt;right = tree-&gt;null;    node-&gt;color = COLOR_RED;    rb_insert_fixup( tree, node );}void rb_transplant(    rbTree *tree,    rbTreeNode *node_a,    rbTreeNode *node_b ){    if ( node_a-&gt;parent == tree-&gt;null )        tree-&gt;root = node_b;    else if ( node_a == node_a-&gt;parent-&gt;left )        node_a-&gt;parent-&gt;left = node_b;    else        node_a-&gt;parent-&gt;right = node_b;    node_b-&gt;parent = node_a-&gt;parent;    free( node_a );}void rb_delete_fixup(    rbTree *tree,    rbTreeNode *node ){    rbTreeNode *p = tree-&gt;null;    while ( node != tree-&gt;null &amp;&amp; node-&gt;color == COLOR_BLACK ) {        if ( node == node-&gt;parent-&gt;left ) {            p = node-&gt;parent-&gt;right;            if ( p-&gt;color == COLOR_RED ) {                p-&gt;color = COLOR_BLACK;                node-&gt;parent-&gt;color = COLOR_RED;                left_rotate( tree, node-&gt;parent );                p = node-&gt;parent-&gt;right;            } else if ( p-&gt;left-&gt;color == COLOR_BLACK                &amp;&amp; p-&gt;right-&gt;color == COLOR_BLACK ) {                p-&gt;color = COLOR_RED;                node = node-&gt;parent;            } else if ( p-&gt;right-&gt;color == COLOR_BLACK ) {                p-&gt;left-&gt;color = COLOR_BLACK;                p-&gt;color = COLOR_RED;                right_rotate( tree, p );                p = node-&gt;parent-&gt;right;            } else {                p-&gt;color = node-&gt;parent-&gt;color;                node-&gt;parent-&gt;color = COLOR_BLACK;                left_rotate( tree, node-&gt;parent );                node = tree-&gt;root;            }        } else {            p = node-&gt;parent-&gt;left;            if ( p-&gt;color == COLOR_RED ) {                p-&gt;color = COLOR_BLACK;                node-&gt;parent-&gt;color = COLOR_RED;                right_rotate( tree, node-&gt;parent );                p = node-&gt;parent-&gt;left;            } else if ( p-&gt;left-&gt;color == COLOR_BLACK                &amp;&amp; p-&gt;right-&gt;color == COLOR_BLACK ) {                p-&gt;color = COLOR_RED;                node = node-&gt;parent;            } else if ( p-&gt;left-&gt;color == COLOR_BLACK ) {                p-&gt;right-&gt;color = COLOR_BLACK;                p-&gt;color = COLOR_RED;                left_rotate( tree, p );                p = node-&gt;parent-&gt;left;            } else {                p-&gt;color = node-&gt;parent-&gt;color;                node-&gt;parent-&gt;color = COLOR_BLACK;                right_rotate( tree, node-&gt;parent );                node = tree-&gt;root;            }        }    }    node-&gt;color = COLOR_BLACK;}void rb_delete(    rbTree *tree,    rbTreeNode *node ){    rbTreeNode *p = node;    rbTreeNode *q = tree-&gt;null;    color origin_color = p-&gt;color;    if ( node-&gt;left == tree-&gt;null ) {        q = node-&gt;right;        rb_transplant( tree, node, node-&gt;right );    } else if ( node-&gt;right == tree-&gt;null ) {        q = node-&gt;left;        rb_transplant( tree, node, node-&gt;left );    } else {        p = tree_minimum( node-&gt;right, tree-&gt;null );        origin_color = p-&gt;color;        q = p-&gt;right;        if ( p-&gt;parent == node )            q-&gt;parent = p;        else {            rb_transplant( tree, p, p-&gt;right );            p-&gt;right = node-&gt;right;            p-&gt;right-&gt;parent = p;        }        rb_transplant( tree, node, p );        p-&gt;left = node-&gt;left;        p-&gt;left-&gt;parent = p;        p-&gt;color = node-&gt;color;    }    if ( origin_color == COLOR_BLACK )        rb_delete_fixup( tree, q );}int random_num(){    int a = 1;    int b = 100;    return rand() % ( b - a ) + a;}void postorder_tree_free(    rbTreeNode *root,    rbTreeNode *null ){    if ( root != null ) {        postorder_tree_free( root-&gt;left, null );        postorder_tree_free( root-&gt;right, null );        free( root );    }}void inorder_tree_walk(    rbTreeNode *root,    rbTreeNode *null ){    if ( root != null ) {        inorder_tree_walk( root-&gt;left, null );        printf(&quot;%d(%d) &quot;, root-&gt;key, root-&gt;color);        inorder_tree_walk( root-&gt;right, null );    }}void preorder_tree_walk(    rbTreeNode *root,    rbTreeNode *null ){    if ( root != null ) {        printf(&quot;%d(%d) &quot;, root-&gt;key, root-&gt;color);        preorder_tree_walk( root-&gt;left, null );        preorder_tree_walk( root-&gt;right, null );    }}void postorder_tree_walk(    rbTreeNode *root,    rbTreeNode *null ){    if ( root != null ) {        postorder_tree_walk( root-&gt;left, null );        postorder_tree_walk( root-&gt;right, null );        printf(&quot;%d(%d) &quot;, root-&gt;key, root-&gt;color);    }}void print_tree(    rbTree *tree ){    printf(&quot;中序:&quot;);    inorder_tree_walk( tree-&gt;root, tree-&gt;null );    printf(&quot;\n&quot;);    printf(&quot;前序:&quot;);    preorder_tree_walk( tree-&gt;root, tree-&gt;null );    printf(&quot;\n&quot;);    printf(&quot;后序:&quot;);    postorder_tree_walk( tree-&gt;root, tree-&gt;null );    printf(&quot;\n\n&quot;);}rbTreeNode *tree_search_recursion(    rbTreeNode *root,    int key,    rbTreeNode *null){    if ( root == null || key == root-&gt;key ) {        return root;    }    if ( key &lt; root-&gt;key )        return tree_search_recursion( root-&gt;left, key, null );    else        return tree_search_recursion( root-&gt;right, key, null );}rbTreeNode *tree_search(    rbTreeNode *root,    int key,    rbTreeNode *null ){    while ( root != null &amp;&amp; key != root-&gt;key ) {        if ( key &lt; root-&gt;key )            root = root-&gt;left;        else            root = root-&gt;right;    }    return root;}// 找前驱 即中序遍历的前一个位置值rbTreeNode *tree_predecessor(    rbTreeNode *node,    rbTreeNode *null ){    if ( node-&gt;left != null )        return tree_maximum( node-&gt;left, null );    rbTreeNode *p = node-&gt;parent;    while ( p != null &amp;&amp; node == p-&gt;left ) {        node = p;        p = p-&gt;parent;    }    return p;}// 找后继 即中序遍历的后一个位置值rbTreeNode *tree_successor(    rbTreeNode *node,    rbTreeNode *null ){    if ( node-&gt;right != null )        return tree_minimum( node-&gt;right, null );    rbTreeNode *p = node-&gt;parent;    while ( p != null &amp;&amp; node == p-&gt;right ) {        node = p;        p = p-&gt;parent;    }    return p;}void free_tree(    rbTree *tree ){    rbTreeNode *root = tree-&gt;root;    postorder_tree_free( root, tree-&gt;null );    free( tree );}int main(    int argc,    char **argv ){    srand((int)time(NULL));    int i = 10;    int len = 10;    int arr[10] = {10,4,15,14,5, 2,8,13,1,19};    rbTree *tree = ( rbTree * )malloc( sizeof(rbTree) );    tree-&gt;node_num = 0;    tree-&gt;height = 0;    tree-&gt;null = ( rbTreeNode * )malloc( sizeof(rbTreeNode) );    tree-&gt;null-&gt;color = COLOR_BLACK;    tree-&gt;root = tree-&gt;null;    for ( i = 0; i &lt; len; i++ ) {        rbTreeNode *node =            ( rbTreeNode * )malloc( sizeof(rbTreeNode) );        //node-&gt;key = random_num();        node-&gt;key = arr[i];        node-&gt;parent = tree-&gt;null;        node-&gt;left = tree-&gt;null;        node-&gt;right = tree-&gt;null;        rb_insert( tree, node );        printf(&quot;insert %d successfully\n&quot;, arr[i]);    }    print_tree( tree );    rbTreeNode *delete_node = tree_search( tree-&gt;root, 4, tree-&gt;null );    if ( delete_node != tree-&gt;null ) {        rb_delete( tree, delete_node );    }    printf(&quot;\n删除%d的节点后遍历顺序为:\n&quot;, 4);    print_tree( tree );    printf(&quot;\n&quot;);    delete_node = tree_search( tree-&gt;root, 15, tree-&gt;null );    if ( delete_node != tree-&gt;null ) {        rb_delete( tree, delete_node );    }    printf(&quot;\n删除%d的节点后中序遍历顺序为:\n&quot;, 15);    print_tree( tree );    printf(&quot;\n&quot;);    free_tree( tree );    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;红黑树是一种二叉搜索树，它在每个结点上增加了一个存储为来表示结点的颜色，或红或黑，通过从根到叶子的简单路径上各个结点的颜色进行约束，红黑树确保没有一条路径会比其它路径长出2倍，近似平衡的。&lt;/p&gt;
&lt;p&gt;树种每个结点包含5个属性：color、key、left、right、p
      
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树-《算法导论》学习笔记十一</title>
    <link href="http://yoursite.com/2018/06/19/022bin-search-tree/index/"/>
    <id>http://yoursite.com/2018/06/19/022bin-search-tree/index/</id>
    <published>2018-06-19T12:36:13.000Z</published>
    <updated>2018-06-19T12:38:27.885Z</updated>
    
    <content type="html"><![CDATA[<p>二叉搜索树是以一颗二叉树来组织的，每个节点除数据外，还包括三个分别指向父结点、左孩子、右孩子的指针，二叉搜索树有个特性：某个结点root的左子树的某个节点x的关键值小于等于root结点右子树某个结点y的关键值。</p><p>二叉搜索树有几个操作：</p><p><strong>1、查找</strong></p><p>查找与给定关键值相等的结点</p><p><strong>2、遍历</strong></p><p>前序、中序、后序遍历输出</p><p><strong>3、从某结点出发，寻找子树中最小关键值的结点</strong></p><p><strong>4、从某结点出发，寻找子树中最大关键值的结点</strong></p><p><strong>5、以某种遍历方式的次数，寻找某结点的前驱结点和后继结点</strong></p><p>例如中序遍历的顺序为123456，则4结点的前驱为3，后继为5</p><p><strong>6、插入结点</strong></p><p><strong>7、删除结点</strong></p><p>删除某个结点后，要把它的后继结点补在删除的位置上，要注意：</p><ul><li>如果结点没有孩子结点，那么只是简单地将它删除，并删改它的父结点的孩子指针指向它</li><li><p>如果结点只有一个孩子，那么将它孩子提升到它的位置，并修改它的父结点的孩子指针指向它</p></li><li><p>如果节点有两个孩子，那么寻找它的后继（按中序遍历来说一定在右子树），并让后继占据它的位置，后继（按中序遍历来说一定没有左子树）的子树提升到后继的位置</p></li><li><p>情况如上，具体删除时如何替换，又有不同情况：</p></li><li><p>如果结点只有左或孩子，用孩子替换结点</p></li><li>如果结点有左右两个孩子，那么要查找结点的后继：(1)、如果后继是结点的右孩子，用后继替换结点，并留下后继的右孩子；(2)、后继位于结点的右子树，但并不是结点的右孩子，则，先用后继的右孩子替换后继，再用后继替换结点</li></ul><p>代码：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;typedef struct biSearchTreeNode {    int key;    struct biSearchTreeNode *parent;    struct biSearchTreeNode *left;    struct biSearchTreeNode *right;}biSearchTreeNode;typedef struct biSearchTree {    int node_num;    int height;    biSearchTreeNode *root;}biSearchTree;int random_num(){    int a = 1;    int b = 100;    return rand() % ( b - a ) + a;}void postorder_tree_free(    biSearchTreeNode *root ){    if ( root != NULL ) {        postorder_tree_free( root-&gt;left );        postorder_tree_free( root-&gt;right );        free( root );    }}void inorder_tree_walk(    biSearchTreeNode *root ){    if ( root != NULL ) {        inorder_tree_walk( root-&gt;left );        printf(&quot;%d &quot;, root-&gt;key);        inorder_tree_walk( root-&gt;right );    }}void preorder_tree_walk(    biSearchTreeNode *root ){    if ( root != NULL ) {        printf(&quot;%d &quot;, root-&gt;key);        preorder_tree_walk( root-&gt;left );        preorder_tree_walk( root-&gt;right );    }}void postorder_tree_walk(    biSearchTreeNode *root ){    if ( root != NULL ) {        postorder_tree_walk( root-&gt;left );        postorder_tree_walk( root-&gt;right );        printf(&quot;%d &quot;, root-&gt;key);    }}void print_tree(    biSearchTree *tree ){    printf(&quot;中序:&quot;);    inorder_tree_walk( tree-&gt;root );    printf(&quot;\n&quot;);    printf(&quot;前序:&quot;);    preorder_tree_walk( tree-&gt;root );    printf(&quot;\n&quot;);    printf(&quot;后序:&quot;);    postorder_tree_walk( tree-&gt;root );    printf(&quot;\n\n&quot;);}biSearchTreeNode *tree_search_recursion(    biSearchTreeNode *root,    int key ){    if ( root == NULL || key == root-&gt;key ) {        return root;    }    if ( key &lt; root-&gt;key )        return tree_search_recursion( root-&gt;left, key );    else        return tree_search_recursion( root-&gt;right, key );}biSearchTreeNode *tree_search(    biSearchTreeNode *root,    int key ){    while ( root != NULL &amp;&amp; key != root-&gt;key ) {        if ( key &lt; root-&gt;key )            root = root-&gt;left;        else            root = root-&gt;right;    }    return root;}biSearchTreeNode *tree_minimum(    biSearchTreeNode *root ){    while ( root-&gt;left != NULL ) {        root = root-&gt;left;    }    return root;}biSearchTreeNode *tree_maximum(    biSearchTreeNode *root ){    while ( root-&gt;right != NULL ) {        root = root-&gt;right;    }    return root;}// 找前驱 即中序遍历的前一个位置值biSearchTreeNode *tree_predecessor(    biSearchTreeNode *node ){    if ( node-&gt;left != NULL )        return tree_maximum( node-&gt;left );    biSearchTreeNode *p = node-&gt;parent;    while ( p != NULL &amp;&amp; node == p-&gt;left ) {        node = p;        p = p-&gt;parent;    }    return p;}// 找后继 即中序遍历的后一个位置值biSearchTreeNode *tree_successor(    biSearchTreeNode *node ){    if ( node-&gt;right != NULL )        return tree_minimum( node-&gt;right );    biSearchTreeNode *p = node-&gt;parent;    while ( p != NULL &amp;&amp; node == p-&gt;right ) {        node = p;        p = p-&gt;parent;    }    return p;}void tree_insert(    biSearchTree *tree,    biSearchTreeNode *node ){    biSearchTreeNode *root = tree-&gt;root;    biSearchTreeNode *p = NULL;    biSearchTreeNode *q = root;    while ( q != NULL ) {        p = q;        if ( node-&gt;key &lt; q-&gt;key )            q = q-&gt;left;        else            q = q-&gt;right;    }    node-&gt;parent = p;    if ( p == NULL ) {        tree-&gt;root = node;    }    else if ( node-&gt;key &lt; p-&gt;key )        p-&gt;left = node;    else        p-&gt;right = node;}void transplant(    biSearchTree *tree,    biSearchTreeNode *node_a,    biSearchTreeNode *node_b ){    if ( node_a-&gt;parent == NULL )        tree-&gt;root = node_b;    else if ( node_a == node_a-&gt;parent-&gt;left )        node_a-&gt;parent-&gt;left = node_b;    else        node_a-&gt;parent-&gt;right = node_b;    if ( node_b != NULL )        node_b-&gt;parent = node_a-&gt;parent;}void tree_delete(    biSearchTree *tree,    biSearchTreeNode *node ){    if ( node-&gt;left == NULL )        transplant( tree, node, node-&gt;right );    else if ( node-&gt;right == NULL )        transplant( tree, node, node-&gt;left );    else {        biSearchTreeNode *p = tree_minimum( node-&gt;right );        if ( p-&gt;parent != node ) {            transplant( tree, p, p-&gt;right );            p-&gt;right = node-&gt;right;            p-&gt;right-&gt;parent = p;        }        transplant( tree, node, p );        p-&gt;left = node-&gt;left;        p-&gt;left-&gt;parent = p;    }    free( node );}void free_tree(    biSearchTree *tree ){    biSearchTreeNode *root = tree-&gt;root;    postorder_tree_free( root );    free( tree );}int main(    int argc,    char **argv ){    srand((int)time(NULL));    int i = 10;    int len = 10;    int arr[10] = {10,4,15,14,5, 2,8,13,1,19};    biSearchTree *tree = ( biSearchTree * )malloc( sizeof(biSearchTree) );    tree-&gt;node_num = 0;    tree-&gt;height = 0;    for ( i = 0; i &lt; len; i++ ) {        biSearchTreeNode *node =            ( biSearchTreeNode * )malloc( sizeof(biSearchTreeNode) );        //node-&gt;key = random_num();        node-&gt;key = arr[i];        node-&gt;parent = NULL;        node-&gt;left = NULL;        node-&gt;right = NULL;        tree_insert( tree, node );    }    print_tree( tree );    for ( i = 0; i &lt; len; i++ ) {        biSearchTreeNode *pre = tree_predecessor( tree_search(tree-&gt;root, arr[i]) );        biSearchTreeNode *post = tree_successor( tree_search(tree-&gt;root, arr[i]) );        printf(&quot;\n&quot;);        if ( pre != NULL )            printf(&quot;查找%d的中序遍历前驱为:%d\n&quot;, arr[i], pre-&gt;key);        else            printf(&quot;查找%d的中序遍历前驱为空！\n&quot;, arr[i]);        if ( post != NULL )            printf(&quot;查找%d的中序遍历后继为:%d\n&quot;, arr[i], post-&gt;key);        else            printf(&quot;查找%d的中序遍历后继为空！\n&quot;, arr[i]);    }    biSearchTreeNode *delete_node = tree_search( tree-&gt;root, 4 );    if ( delete_node != NULL ) {        tree_delete( tree, delete_node );    }    printf(&quot;\n删除%d的节点后中序遍历顺序为:&quot;, 4);    inorder_tree_walk( tree-&gt;root );    printf(&quot;\n&quot;);    delete_node = tree_search( tree-&gt;root, 15 );    if ( delete_node != NULL ) {        tree_delete( tree, delete_node );    }    printf(&quot;\n删除%d的节点后中序遍历顺序为:&quot;, 15);    inorder_tree_walk( tree-&gt;root );    printf(&quot;\n&quot;);    free_tree( tree );    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;二叉搜索树是以一颗二叉树来组织的，每个节点除数据外，还包括三个分别指向父结点、左孩子、右孩子的指针，二叉搜索树有个特性：某个结点root的左子树的某个节点x的关键值小于等于root结点右子树某个结点y的关键值。&lt;/p&gt;
&lt;p&gt;二叉搜索树有几个操作：&lt;/p&gt;
&lt;p&gt;&lt;stro
      
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>查找数组第i小的数-《算法导论》学习笔记十</title>
    <link href="http://yoursite.com/2018/06/19/021search-min-i/index/"/>
    <id>http://yoursite.com/2018/06/19/021search-min-i/index/</id>
    <published>2018-06-19T12:32:13.000Z</published>
    <updated>2018-06-19T12:35:17.286Z</updated>
    
    <content type="html"><![CDATA[<p>查找第i小的数利用了快速排序的一点思想，即以数组某个值作为比较值，然后遍历数组中除这个数以外的数，小于它的就放左边，大于它的放右边，然后作为比较值的数放中间，并返回比较值的下标，如果下标等于i，表示就找到了，如果下标大于i，又再次从大于此下标的数组递归进行此过程，同理，小于i就从小于此下标的数组递归进行此过程，代码：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int partition( int *arr, int p, int r ){    int x = arr[r];    int i = p - 1;    int j = 0;    int temp = 0;    for ( j = p; j &lt; r; j++ ) {        if ( arr[j] &lt;= x ) {            i += 1;            temp = arr[i];            arr[i] = arr[j];            arr[j] = temp;        }    }    temp = arr[i + 1];    arr[i + 1] = arr[r];    arr[r] = temp;    return i + 1;}int randomized_partition( int *arr, int p, int r ){    int i = rand() % (r - p) + p;    int temp = arr[r];    arr[r] = arr[i];    arr[i] = temp;    return partition( arr, p, r );}int randomized_select(    int *arr,    int p,    int r,    int i ){    if ( p == r )        return arr[p];    int q = 0, k = 0;    q = randomized_partition( arr, p, r );    k = q - p + 1;    if ( i == k )        return arr[q];    else if ( i &lt; k )        return randomized_select( arr, p, q - 1, i );    else        return randomized_select( arr, q + 1, r, i - k );}int main(){    int arr[10] = {1,2,3,4,5,6,7,8,9,10};    int len = 10;    int i = 8;    printf(&quot;第%d小的数是:%d\n&quot;, i, randomized_select(arr, 0, 9, i));    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;查找第i小的数利用了快速排序的一点思想，即以数组某个值作为比较值，然后遍历数组中除这个数以外的数，小于它的就放左边，大于它的放右边，然后作为比较值的数放中间，并返回比较值的下标，如果下标等于i，表示就找到了，如果下标大于i，又再次从大于此下标的数组递归进行此过程，同理，小于
      
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>桶排序-《算法导论》学习笔记九</title>
    <link href="http://yoursite.com/2018/06/19/020bucket-sort/index/"/>
    <id>http://yoursite.com/2018/06/19/020bucket-sort/index/</id>
    <published>2018-06-19T12:28:14.000Z</published>
    <updated>2018-06-19T12:29:00.827Z</updated>
    
    <content type="html"><![CDATA[<p>桶排序要求数据均匀、独立分布在某个区间上，然后将待排序值按某个区间划分为几个区间数组，然后将待排序的数按这个区间划分公式有序放入对应桶中，这样放完之后再按顺序从桶中拿出来一个一个放入原数组。<br>c代码桶可以用链表，如待排序数组的值为0-99，那么桶可以划分为0-9、10-19、20-29…..，这样就得到了10个桶数组链表，然后遍历待排序的数组，将值/10后以链表插入排序方式放入对应桶链表中（就像打扑克一样从前往后遍历，能插入就插入），待所有数遍历完后，就得到了桶数据了，然后再排序0-9的桶，每个桶做链表遍历取数据，直接从数组0开始插入到待排序数组，代码：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;//#define DEBUGtypedef struct bucket_data {    int no;    struct bucket_data *next;} bucket_data;void sort_insert( bucket_data *, int );void bucket_sort( int *arr, int len ){    bucket_data *tmp_arr = ( bucket_data * )malloc( sizeof(bucket_data) * 10 );    int i = 0, count = 0;    //初始化链表头数组    for ( i = 0; i &lt; 10; i++ ) {        tmp_arr[i].next = NULL;    }    //遍历数据并有序插入到相应链表中    for ( i = 0; i &lt; len; i++ ) {        sort_insert( &amp;tmp_arr[arr[i] / 10], arr[i] );    }    //从链表中取数据到数组    count = 0;    for ( i = 0; i &lt; 10; i++ ) {        bucket_data *p = tmp_arr[i].next;        bucket_data *free_p = NULL;        #ifdef DEBUG            printf(&quot;bucket[%d]:\n&quot;, i);        #endif        while( p != NULL ) {        #ifdef DEBUG            printf(&quot;%d &quot;, p-&gt;no);        #endif            free_p = p;            arr[count] = p-&gt;no;            count++;            p = p-&gt;next;            free( free_p );        }        #ifdef DEBUG            printf(&quot;\n&quot;);        #endif    }    free( tmp_arr );}void sort_insert( bucket_data *head, int no ){    bucket_data *p = head;    bucket_data *data = ( bucket_data * )malloc( sizeof(bucket_data) );    data-&gt;no = no;    data-&gt;next = NULL;    while ( p != NULL &amp;&amp; p-&gt;next != NULL ) {        if ( p-&gt;next-&gt;no &gt;= no ) {            data-&gt;next = p-&gt;next;            p-&gt;next = data;            break;        }        p = p-&gt;next;    }    if ( p-&gt;next == NULL ) {        p-&gt;next = data;    }}void check_is_inc_arr(    int *arr,    int len ){    int i = 0;    for ( i = 0; i &lt; len; i++ ) {        if ( arr[i] &lt; arr[i - 1] ) {            printf(&quot;check_is_inc_arr fail.\n&quot;);            return;        }    }}//初始化随机数组void initArr( int *arr, int lowV,    int upV, int len ){    int i = 0;    int size = upV - lowV;    for ( i = 0; i &lt; len; i++ )    {        arr[i] = rand() % size + lowV;    }}void print_arr(    int *arr,    int len ){    int i = 0;    printf(&quot;\n=============================================\n&quot;);    for ( i = 0; i &lt; len; i++ ) {        printf(&quot;%d &quot;, arr[i]);    }    printf(&quot;\n=============================================\n&quot;);}int main(    int argc,    char **argv ){    if ( argc != 4 ) {        printf(&quot;input array length and the random value range.\n&quot;);        exit( 0 );    }    srand( (int)time(NULL) );    int length = atoi( argv[1] );    int lowV = atoi( argv[2] );    int upV = atoi( argv[3] );    int *arr = ( int * )malloc( sizeof(int) * (length) );    int i = 1000;    for ( ; i &gt; 0; i-- ) {        initArr( arr, lowV, upV, length );        //print_arr( arr, length );        bucket_sort( arr, length );        //print_arr( arr, length );        check_is_inc_arr( arr, length );    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;桶排序要求数据均匀、独立分布在某个区间上，然后将待排序值按某个区间划分为几个区间数组，然后将待排序的数按这个区间划分公式有序放入对应桶中，这样放完之后再按顺序从桶中拿出来一个一个放入原数组。&lt;br&gt;c代码桶可以用链表，如待排序数组的值为0-99，那么桶可以划分为0-9、10
      
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计数排序-《算法导论》学习笔记八</title>
    <link href="http://yoursite.com/2018/06/19/019count-sort/index/"/>
    <id>http://yoursite.com/2018/06/19/019count-sort/index/</id>
    <published>2018-06-19T12:27:08.000Z</published>
    <updated>2018-06-19T12:27:51.135Z</updated>
    
    <content type="html"><![CDATA[<p>计数排序：假设n个输入元素中的每一个都是在0-k区间内的一个整数(k为正整数)，对每一个输入元素x，确定小于x的元素个数，用一个0-k长度的数组做记录，例如输入数组的数为0-10长度，随机出[2,5,3,0,2,3,0,3]，可以计算出一个0-10的数组，分别表示小于等于x的数的个数，于是有：0-&gt;2,1-&gt;2,2-&gt;4,3-&gt;7,4-&gt;7,5-&gt;8,6-&gt;8,7-&gt;8,9-&gt;8,10-&gt;8，然后再倒序遍历待排序数组，根据值去0-10数组取索引，然后将数组值放入一个新的等长数组那个索引处，取过的索引值要减一，这是为了下次再取到相同值不会放在同一位置，代码：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;void counting_sort(    int *in_arr,    int *out_arr,    int arr_len,    int k ){    int *tmp_arr = ( int * )malloc( sizeof(int) * (k + 1) );    int i = 0, j = 0;    for ( i = 0; i &lt; k; i++ ) {        tmp_arr[i]  = 0;    }    for ( j = 0; j &lt; arr_len; j++ ) {        tmp_arr[in_arr[j]] = tmp_arr[in_arr[j]] + 1;    }    for ( i = 1; i &lt; k + 1; i++ ) {        tmp_arr[i] = tmp_arr[i] + tmp_arr[i - 1];    }    for ( j = arr_len - 1; j &gt;= 0; j-- ) {        //printf(&quot;j:%d, in_arr[j]:%d, tmp_arr[in_arr[j]]:%d\n&quot;,        //  j, in_arr[j], tmp_arr[in_arr[j]]);        out_arr[tmp_arr[in_arr[j]] - 1] = in_arr[j];        tmp_arr[in_arr[j]] = tmp_arr[in_arr[j]] - 1;    }    free( tmp_arr );}void check_is_inc_arr(    int *arr,    int len ){    int i = 0;    for ( i = 0; i &lt; len; i++ ) {        if ( arr[i] &lt; arr[i - 1] ) {            printf(&quot;check_is_inc_arr fail.\n&quot;);            return;        }    }}//初始化随机数组void initArr( int *arr, int lowV,    int upV, int len ){    int i = 0;    int size = upV - lowV;    for ( i = 0; i &lt; len; i++ )    {        arr[i] = rand() % size + lowV;    }}void print_arr(    int *arr,    int len ){    int i = 0;    printf(&quot;\n=============================================\n&quot;);    for ( i = 0; i &lt; len; i++ ) {        printf(&quot;%d &quot;, arr[i]);    }    printf(&quot;\n=============================================\n&quot;);}int main(    int argc,    char **argv ){    if ( argc != 4 ) {        printf(&quot;input array length and the random value range.\n&quot;);        exit( 0 );    }    srand( (int)time(NULL) );    int length = atoi( argv[1] );    int lowV = atoi( argv[2] );    int upV = atoi( argv[3] );    int *arr = ( int * )malloc( sizeof(int) * (length) );    int *new_arr = ( int * )malloc( sizeof(int) * length );    int i = 1000;    for ( ; i &gt; 0; i-- ) {        initArr( arr, lowV, upV, length );        //print_arr( arr, length );        counting_sort( arr, new_arr, length, upV );        //print_arr( new_arr, length );        check_is_inc_arr( new_arr, length );    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计数排序：假设n个输入元素中的每一个都是在0-k区间内的一个整数(k为正整数)，对每一个输入元素x，确定小于x的元素个数，用一个0-k长度的数组做记录，例如输入数组的数为0-10长度，随机出[2,5,3,0,2,3,0,3]，可以计算出一个0-10的数组，分别表示小于等于x
      
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>快速排序-《算法导论》学习笔记七</title>
    <link href="http://yoursite.com/2018/06/19/018quick-sort/index/"/>
    <id>http://yoursite.com/2018/06/19/018quick-sort/index/</id>
    <published>2018-06-19T12:24:39.000Z</published>
    <updated>2018-06-19T12:26:47.543Z</updated>
    
    <content type="html"><![CDATA[<p>快排利用分治的思想，将问题规模切分为小的子规模问题，类似归并排序，归并是将两个待排序的子数组合并为一个有序的数组，而快排是将数组以某个数组值划分为两个子数组，一个数组的所有数比这个值小，一个数组的所有数比这个值大，然后再递归地对两个子数组再以某个数组值做切分和交换：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;int partition( int *arr, int p, int r ){    int x = arr[r];    int i = p - 1;    int j = 0;    int temp = 0;    for ( j = p; j &lt; r; j++ ) {        if ( arr[j] &lt;= x ) {            i += 1;            temp = arr[i];            arr[i] = arr[j];            arr[j] = temp;        }    }    temp = arr[i + 1];    arr[i + 1] = arr[r];    arr[r] = temp;    return i + 1;}void quick_sort( int *arr, int p, int r ){    int q = 0;    if ( p &lt; r ) {        q = partition( arr, p, r );        //printf(&quot;p-&gt;%d, q-&gt;%d, r-&gt;%d\n&quot;, p, q, r);        quick_sort( arr, p, q - 1 );        quick_sort( arr, q + 1, r );    }}void check_is_inc_arr(    int *arr,    int len ){    int i = 0;    for ( i = 0; i &lt; len; i++ ) {        if ( arr[i] &lt; arr[i - 1] ) {            printf(&quot;check_is_inc_arr fail.\n&quot;);            return;        }    }}//初始化随机数组void initArr( int *arr, int lowV,    int upV, int len ){    int i = 0;    int size = upV - lowV;    for ( i = 0; i &lt; len; i++ )    {        arr[i] = rand() % size + lowV;    }}void print_arr(    int *arr,    int len ){    int i = 0;    printf(&quot;\n=============================================\n&quot;);    for ( i = 0; i &lt; len; i++ ) {        printf(&quot;%d &quot;, arr[i]);    }    printf(&quot;\n=============================================\n&quot;);}int main(    int argc,    char **argv ){    if ( argc != 4 ) {        printf(&quot;input array length and the random value range.\n&quot;);        exit( 0 );    }    srand( (int)time(NULL) );    int length = atoi( argv[1] );    int lowV = atoi( argv[2] );    int upV = atoi( argv[3] );    int *arr = ( int * )malloc( sizeof(int) * (length) );    initArr( arr, lowV, upV, length );    print_arr( arr, length );    quick_sort( arr, 0, length - 1 );    print_arr( arr, length );    check_is_inc_arr( arr, length );    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;快排利用分治的思想，将问题规模切分为小的子规模问题，类似归并排序，归并是将两个待排序的子数组合并为一个有序的数组，而快排是将数组以某个数组值划分为两个子数组，一个数组的所有数比这个值小，一个数组的所有数比这个值大，然后再递归地对两个子数组再以某个数组值做切分和交换：&lt;/p&gt;
      
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>erlang的终端带颜色输出与中文字符串输出</title>
    <link href="http://yoursite.com/2018/06/19/017erlang-shell-color/index/"/>
    <id>http://yoursite.com/2018/06/19/017erlang-shell-color/index/</id>
    <published>2018-06-19T12:19:59.000Z</published>
    <updated>2018-06-19T12:21:25.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-带颜色输出"><a href="#1-带颜色输出" class="headerlink" title="1.带颜色输出"></a>1.带颜色输出</h1><p>erlang终端支持带颜色输出，例如lager日志库就可以。其实就是在输出前设置一下输出属性，正常的字体是：”\e[0;38m”<br>下面自己弄了一些宏：</p><pre><code>-define(CONSOLE_COLOR_RED,      &quot;\e[0;31m&quot;).-define(CONSOLE_COLOR_RED_BOLD, &quot;\e[1;31m&quot;).-define(CONSOLE_COLOR_YELLOW1,  &quot;\e[0;32m&quot;).-define(CONSOLE_COLOR_YELLOW2,  &quot;\e[0;33m&quot;).-define(CONSOLE_COLOR_BLUE,     &quot;\e[0;34m&quot;).-define(CONSOLE_COLOR_PURPLE,   &quot;\e[0;35m&quot;).-define(CONSOLE_COLOR_GREEN,    &quot;\e[0;36m&quot;).-define(CONSOLE_COLOR_GRAY,     &quot;\e[0;37m&quot;).-define(CONSOLE_COLOR_NORMAL,   &quot;\e[0;38m&quot;).</code></pre><p>用法就是打印的字符串前后加上要设置的属性例如<br><code>io:format(“~s~s~s~n”, [“\e[0;31m”, debug, “\e[0;38m”]).</code><br>就是在输出debug之前设置字体为红色，然后输出结束后设置字体为正常白色。</p><h1 id="2-中文输出"><a href="#2-中文输出" class="headerlink" title="2.中文输出"></a>2.中文输出</h1><p>中文输出乱码在rebar3插件里用rebar_info输出以及在ct里用io:format(user, ….)输出会遇到，带中文的字符串要转为utf8，代码形如：</p><pre><code>NewFormat = io_lib:format(Format, Args),io:format(&quot;~s&quot;, [unicode:characters_to_binary(NewFormat, utf8)]).</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-带颜色输出&quot;&gt;&lt;a href=&quot;#1-带颜色输出&quot; class=&quot;headerlink&quot; title=&quot;1.带颜色输出&quot;&gt;&lt;/a&gt;1.带颜色输出&lt;/h1&gt;&lt;p&gt;erlang终端支持带颜色输出，例如lager日志库就可以。其实就是在输出前设置一下输出属性，正常的
      
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Erlang" scheme="http://yoursite.com/tags/Erlang/"/>
    
  </entry>
  
  <entry>
    <title>堆排序-《算法导论》学习笔记六</title>
    <link href="http://yoursite.com/2018/06/19/016heap-sort/index/"/>
    <id>http://yoursite.com/2018/06/19/016heap-sort/index/</id>
    <published>2018-06-19T12:18:42.000Z</published>
    <updated>2018-06-19T12:19:36.767Z</updated>
    
    <content type="html"><![CDATA[<p>堆排序就是将一组数按二叉树层序遍历的存储顺序，经过一系列比较转移，最终变成有序的数组，这里的二叉树堆一定是完全二叉树。堆排序能进行的基础是有个最大堆的数组，最大堆性质是指树上的每个节点的子节点都比自己小或等于。<br>因此最顶上的根节点一定是值最大的节点，有了最大堆在，堆排序就可以进行了，从层序遍历的最后一个节点开始倒序循环，交换当前节点与最顶层根节点，即最大值的节点，这样每次最大的节点都被放在层序遍历的最后位置，类似冒泡排序了，而放了最大值的节点即从堆中排除（只要堆长度减一即表示堆没有这个节点了），交换到顶点根节点的值再做一次下滤操作（以这个节点值与子树的最大值交换），保证剩余子树一定也是最大堆性质。<br>贴代码：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;int parent( int );int left( int );int right( int );inline int parent( int index ){    return index / 2;}inline int left( int index ){    return index * 2;}inline int right( int index ){    return index * 2 + 1;}//下滤void max_heapify(    int *arr,    int heap_size,    int index ){    int l = left( index );    int r = right( index );    int largest = 0;    if ( l &lt;= heap_size &amp;&amp; arr[l] &gt; arr[index] ) {        largest = l;    } else {        largest = index;    }    if ( r &lt;= heap_size &amp;&amp; arr[r] &gt; arr[largest] ) {        largest = r;    }    if ( largest != index ) {        int temp = arr[index];        arr[index] = arr[largest];        arr[largest] = temp;        max_heapify( arr, heap_size, largest );    }}//构建最大堆void build_max_heap(    int *arr,    int length,    int heap_size ){    int i = 0;    for ( i = length / 2; i &gt;= 1; i-- ) {        max_heapify( arr, heap_size, i );    }}//开始堆排序void heap_sort(    int *arr,    int length,    int heap_size ){    int i = 0;    build_max_heap( arr, length, heap_size );    for ( i = heap_size; i &gt;= 2; i-- ) {        int temp = arr[1];        arr[1] = arr[i];        arr[i] = temp;        heap_size -= 1;        max_heapify( arr, heap_size, 1 );    }}void check_is_inc_arr(    int *arr,    int len ){    int i = 0;    for ( i = 1; i &lt;= len; i++ ) {        if ( arr[i] &lt; arr[i - 1] ) {            printf(&quot;check_is_inc_arr fail.\n&quot;);            return;        }    }    printf(&quot;check_is_inc_arr ok.\n&quot;);}//初始化随机数组void initArr( int *arr, int lowV,    int upV, int len ){    int i = 0;    int size = upV - lowV;    for ( i = 1; i &lt; len + 1; i++ )    {        arr[i] = rand() % size + lowV;    }    arr[0] = 0;}void print_arr(    int *arr,    int len ){    int i = 0;    printf(&quot;\n=============================================\n&quot;);    for ( i = 0; i &lt;= len; i++ ) {        printf(&quot;%d &quot;, arr[i]);    }    printf(&quot;\n=============================================\n&quot;);}int main(    int argc,    char **argv ){    if ( argc != 4 ) {        printf(&quot;input array length and the random value range.\n&quot;);        exit( 0 );    }    srand( (int)time(NULL) );    int length = atoi( argv[1] );    int lowV = atoi( argv[2] );    int upV = atoi( argv[3] );    int *arr = ( int * )malloc( sizeof(int) * (length + 1) );    initArr( arr, lowV, upV, length );    //print_arr( arr, length );    heap_sort( arr, length, length );    //print_arr( arr, length );    check_is_inc_arr( arr, length );    return 0;}</code></pre><p>上面代码中因为c数组从0开始的原因，因此0位置不参与存储和运算，数据形式是{0, 2, 3, 4, 5, 6}。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;堆排序就是将一组数按二叉树层序遍历的存储顺序，经过一系列比较转移，最终变成有序的数组，这里的二叉树堆一定是完全二叉树。堆排序能进行的基础是有个最大堆的数组，最大堆性质是指树上的每个节点的子节点都比自己小或等于。&lt;br&gt;因此最顶上的根节点一定是值最大的节点，有了最大堆在，堆排
      
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>n阶矩阵一般乘法-《算法导论》学习笔记五</title>
    <link href="http://yoursite.com/2018/06/19/015nmatrix/index/"/>
    <id>http://yoursite.com/2018/06/19/015nmatrix/index/</id>
    <published>2018-06-19T12:16:29.000Z</published>
    <updated>2018-06-19T12:18:12.130Z</updated>
    
    <content type="html"><![CDATA[<p>A、B两个矩阵均是nxn的矩阵，则两个矩阵的乘法：</p><p><img src="/img/nmatrix1.png" alt="nmatrix1"></p><p>一般的矩阵乘法代码：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;class SquareMatrix {public:    SquareMatrix(){}    SquareMatrix( int row, int col ):        mRow(row), mCol(col)    {        Init();    }    ~SquareMatrix()    {        for ( int i = 0; i &lt; mRow; i++ ) {            delete[] mElement[i];            //printf(&quot;delete %d\n&quot;, i);        }        delete[] mElement;    }    void Init()    {        mElement = new int*[mRow];        for ( int i = 0; i &lt; mCol; i++ ) {            mElement[i] = new int[i];        }    }    void SetElement( int lowV, int upV )    {        int size = upV - lowV;        for ( int i = 0; i &lt; mRow; i++ ) {            for ( int j = 0; j &lt; mCol; j++ ) {                mElement[i][j] = rand() % size + lowV;            }        }    }    void PrintElement()    {        printf(&quot;=========================================\n&quot;);        for ( int i = 0; i &lt; mRow; i++ ) {            for ( int j = 0; j &lt; mCol; j++ ) {                printf(&quot;%d &quot;, mElement[i][j]);            }            printf(&quot;\n&quot;);        }        printf(&quot;=========================================\n&quot;);    }public:    int mRow;    int mCol;    int *(*mElement);};void SquareMatrixMultiply(    SquareMatrix &amp;a,    SquareMatrix &amp;b,    SquareMatrix &amp;c ){    int n = a.mRow;    c.mRow = c.mCol = n;    c.Init();    for ( int i = 0; i &lt; n; i++ ) {        for ( int j = 0; j &lt; n; j++ ) {            c.mElement[i][j] = 0;            for ( int k = 0; k &lt; n; k++ ) {                c.mElement[i][j] += a.mElement[i][k] * b.mElement[j][k];            }        }    }}int main( int argc, char **argv ){    if ( argc != 2 ) {        printf(&quot;Usage:./binaryfile num\n&quot;);        exit( 0 );    }    int n = atoi( argv[1] );    SquareMatrix smA( n, n ), smB( n, n ), smC;    smA.SetElement( 1, 10 );    smA.PrintElement();    smB.SetElement( 1, 10 );    smB.PrintElement();    SquareMatrixMultiply( smA, smB, smC );    smC.PrintElement();    printf(&quot;init square matrix finished\n&quot;);    return 0;}</code></pre><p>算法复杂度为O(n^3)，而Stranssen算法通过分治法将大矩阵切分为小矩阵进行计算，算法复杂度可以降低为O(n^2.81)，但是尝试写下代码，发现切割子矩阵时有点复杂，普通的切分会创建子矩阵并复制值，而用下标进行计算又比较复杂，下次有空再尝试写吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A、B两个矩阵均是nxn的矩阵，则两个矩阵的乘法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/nmatrix1.png&quot; alt=&quot;nmatrix1&quot;&gt;&lt;/p&gt;
&lt;p&gt;一般的矩阵乘法代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#
      
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>erlang编写rebar3插件</title>
    <link href="http://yoursite.com/2018/06/19/014rebar3-plugin/index/"/>
    <id>http://yoursite.com/2018/06/19/014rebar3-plugin/index/</id>
    <published>2018-06-19T12:11:35.000Z</published>
    <updated>2018-06-19T12:15:54.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-生成插件工程"><a href="#1-生成插件工程" class="headerlink" title="1.生成插件工程"></a>1.生成插件工程</h1><p>假设插件名为testp，执行rebar3 new plugins testp，即生成了插件工程项目，查看目录结构如图：</p><p><img src="/img/rebar3plugin1.jpeg" alt="rebar3plugin1"></p><p>testp.erl文件调用初始化的代码，而插件最重要的代码在testp_prv.erl的文件，文件里提供了三个接口，分别为<code>init/1</code>,<code>do/1</code>,<code>format_error/1</code>，init做插件初始化的工作，初始化命名空间/初始化命令，然后将命令加入到rebar3，贴一份配置：</p><pre><code>init(State) -&gt;        Provider = providers:create([                {name, compile},            % The &apos;user friendly&apos; name of the task                {module, ?MODULE},            % The module implementation of the task                {namespace, testp},                {bare, true},                 % The task can be run by the user, always true                {deps, ?DEPS},                % The list of dependencies                {example, &quot;rebar3 testp compile&quot;}, % How to use the plugin                {opts, []},                   % list of options understood by the plugin                {short_desc, &quot;rebar3 testp compiler&quot;},                {desc, &quot;rebar3 testp compiler&quot;}        ]),        {ok, rebar_state:add_provider(State, Provider)}.</code></pre><p>这份配置就是为rebar3添加一个rebar3 testp compile命令，如果只输入<code>rebar3 testp</code>，会提示<code>rebar3 testp compiler</code>。<br>第二个方法do就是主要的业务逻辑了，执行了<code>rebar3 testp compiler</code>命令就会调用里面的do方法。<br>如果想添加多个命令，可以在testp.erl里多写一个命令的init调用，然后再添加一个命令类似的prv文件，写不同的do业务逻辑，就可以上传git，将git地址配置在rebar.config的plugins里了，rebar3 compile编译就自动拉取插件代码。<br>插件还可以配置钩子(provider_hook)使用，例如添加编译前调用<br><code>{provider_hooks,[{pre[{compile, {testp, compile}}]}]}</code>，编译后调用将pre改为post即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-生成插件工程&quot;&gt;&lt;a href=&quot;#1-生成插件工程&quot; class=&quot;headerlink&quot; title=&quot;1.生成插件工程&quot;&gt;&lt;/a&gt;1.生成插件工程&lt;/h1&gt;&lt;p&gt;假设插件名为testp，执行rebar3 new plugins testp，即生成了插件工
      
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Erlang" scheme="http://yoursite.com/tags/Erlang/"/>
    
  </entry>
  
  <entry>
    <title>erlang rebar3配置文件</title>
    <link href="http://yoursite.com/2018/06/19/013rebar3-conf/index/"/>
    <id>http://yoursite.com/2018/06/19/013rebar3-conf/index/</id>
    <published>2018-06-19T11:59:19.000Z</published>
    <updated>2018-06-19T12:11:02.436Z</updated>
    
    <content type="html"><![CDATA[<p>rebar3的简单使用可以参考rebar3的官方文档。以下讲解一些rebar3的配置，初入erlang，理解还不甚深刻。<br>用rebar3进行工程创建，会生成rebar.config文件，贴一些配置的使用方法</p><h1 id="1-编译设置"><a href="#1-编译设置" class="headerlink" title="1.编译设置"></a>1.编译设置</h1><pre><code>%% 编译设置{erl_opts, [{parse_transform, lager_transform}, {parse_transform, ms_transform}, report, warn_export_all, warn_export_vars, warn_obsolete_guard, warn_shadow_vars, warn_unused_function, warn_deprecated_function%% ,warn_missing_spec, warn_unused_import]}.</code></pre><p>{parse_transform, lager_transform}是lager依赖库的编译选项，修改抽象语法树的方式在编译期生成对应的代码，lager源代码里本身没有lager:error，lager:info等等方法</p><h1 id="2-rebar3-shell"><a href="#2-rebar3-shell" class="headerlink" title="2.rebar3 shell"></a>2.rebar3 shell</h1><pre><code>{shell, [{apps, [app_name, sync, recon]}, {config, “config/app_name.config”}]}.</code></pre><p>这个配置支持在项目根目录直接运行rebar3 shell启动一个erl shell来运行我们的app，而其配置可以指定为config目录下的某个配置文件，而不是sys.config，适合本地调试，app_name后面的app名字是需要依赖启动的app</p><h1 id="3-rebar3插件"><a href="#3-rebar3插件" class="headerlink" title="3.rebar3插件"></a>3.rebar3插件</h1><pre><code>{plugins,[rebar3_run, rebar3_auto, {relflow, “1.0.5”}]}.</code></pre><p>配置我们项目需要的plugins，这里的插件可以是我们自己编写的rebar3插件</p><h1 id="4-钩子-provider-hooks"><a href="#4-钩子-provider-hooks" class="headerlink" title="4.钩子 provider_hooks"></a>4.钩子 provider_hooks</h1><pre><code>{provider_hooks,[{pre,[ {compile, {my_plugins, do_something}} ]},{post,[{compile,{my_plugins1, clean}}]}]}.</code></pre><p>例如这份配置，就是在执行rebar3 compile之前(pre)运行以my_plugins命名空间下的do_something命令，简单说就是编写了一个rebar3的插件叫my_plugins，提供一个命令叫do_something，即可以在命令行执行rebar3 my_plugins do_something的功能，只是现在配置之后自动调用了命令；post同理就是在compile之后执行那个插件的clean功能，clean功能具体干什么我们不得而知。</p><h1 id="5-环境"><a href="#5-环境" class="headerlink" title="5.环境"></a>5.环境</h1><pre><code>{profiles, [{profile1, [{erl_opts, [no_debug_info]},{relx, [{include_src, false}, {dev_mode, false}, {include_erts, true}, {system_libs, true}]}]}]}</code></pre><p>例如这份配置，指定了一种环境叫profile1，编译选项erl_opts为no_debug_info，打包发布的选项为不包含源码，禁止开发模式(目录不是软连接于default环境)，包含erlang环境等，当然还可以加其它很多选项，为每种环境单独自定义需要的功能，常用default、prod、test等</p><h1 id="6-覆盖"><a href="#6-覆盖" class="headerlink" title="6.覆盖"></a>6.覆盖</h1><pre><code>{overrides, [{add, deps1, [{erl_opts, [no_debug_info]}]}]}</code></pre><p>例如这份配置，就是对名为deps1的依赖的rebar.config再添加一个配置，overrides提供了add和override两种功能，第一种是加配置，第二种也就是用配置的数据去覆盖原来依赖中有的数据</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;rebar3的简单使用可以参考rebar3的官方文档。以下讲解一些rebar3的配置，初入erlang，理解还不甚深刻。&lt;br&gt;用rebar3进行工程创建，会生成rebar.config文件，贴一些配置的使用方法&lt;/p&gt;
&lt;h1 id=&quot;1-编译设置&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Erlang" scheme="http://yoursite.com/tags/Erlang/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu16+ideaIC+rebar3搭建erlang开发环境</title>
    <link href="http://yoursite.com/2018/06/19/012erlang-system-build/index/"/>
    <id>http://yoursite.com/2018/06/19/012erlang-system-build/index/</id>
    <published>2018-06-19T11:42:44.000Z</published>
    <updated>2018-06-19T11:52:53.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-ubuntu16系统"><a href="#1-ubuntu16系统" class="headerlink" title="1.ubuntu16系统"></a>1.ubuntu16系统</h1><h1 id="2-安装各种库"><a href="#2-安装各种库" class="headerlink" title="2.安装各种库"></a>2.安装各种库</h1><pre><code>sudo apt-get install build-essentialsudo apt-get install libncurses5-devsudo apt-get install libssl-devsudo apt-get install m4sudo apt-get install unixodbc unixodbc-devsudo apt-get install freeglut3-dev libwxgtk2.8-devsudo apt-get install xsltprocsudo apt-get install fopsudo apt-get install tk8.5</code></pre><h1 id="3-安装erlang源码"><a href="#3-安装erlang源码" class="headerlink" title="3.安装erlang源码"></a>3.安装erlang源码</h1><p>deb安装包：esl-erlang_19.1.3-1-ubuntu-xenial_amd64.deb</p><p><code>dpkg -i esl-erlang_19.1.3-1-ubuntu-xenial_amd64.deb</code></p><h1 id="4-安装ideaIC工具"><a href="#4-安装ideaIC工具" class="headerlink" title="4.安装ideaIC工具"></a>4.安装ideaIC工具</h1><p>百度搜索安装ideaIC，我安装的ideaIC3.4版本，<a href="http://www.jetbrains.com/idea/" target="_blank" rel="noopener">地址</a></p><h1 id="5-下载rebar3"><a href="#5-下载rebar3" class="headerlink" title="5.下载rebar3"></a>5.下载rebar3</h1><p>rebar3<a href="http://www.rebar3.org/" target="_blank" rel="noopener">地址</a></p><h1 id="6-ideaIC安装erlang插件"><a href="#6-ideaIC安装erlang插件" class="headerlink" title="6.ideaIC安装erlang插件"></a>6.ideaIC安装erlang插件</h1><p>打开ideaIC，进入configure菜单进入settings进行设置：settings -&gt; Plugins -&gt; Browse repositories，然后搜索erlang，就可以安装erlang插件了</p><h1 id="7-配置"><a href="#7-配置" class="headerlink" title="7.配置"></a>7.配置</h1><p>安装完后再次进入settings界面：settings -&gt; Build,Execution,Deployment -&gt; Compiler -&gt; Erlang Compiler，将”Compiler project with rebar”和”Add debug info”都打勾。</p><p>接着：settings -&gt; Other Settings -&gt; Erlang External Tools，将”rebar”的路径设置为下载的rebar3可执行路径的目录。<br>配置完成。</p><h1 id="8-创建、打开新工程等"><a href="#8-创建、打开新工程等" class="headerlink" title="8.创建、打开新工程等"></a>8.创建、打开新工程等</h1><p>略</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-ubuntu16系统&quot;&gt;&lt;a href=&quot;#1-ubuntu16系统&quot; class=&quot;headerlink&quot; title=&quot;1.ubuntu16系统&quot;&gt;&lt;/a&gt;1.ubuntu16系统&lt;/h1&gt;&lt;h1 id=&quot;2-安装各种库&quot;&gt;&lt;a href=&quot;#2-安装各种
      
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Erlang" scheme="http://yoursite.com/tags/Erlang/"/>
    
  </entry>
  
  <entry>
    <title>分治之最大子数组-《算法导论》学习笔记四</title>
    <link href="http://yoursite.com/2018/06/19/011max-sub-arr/index/"/>
    <id>http://yoursite.com/2018/06/19/011max-sub-arr/index/</id>
    <published>2018-06-19T11:35:51.000Z</published>
    <updated>2018-06-19T11:41:36.432Z</updated>
    
    <content type="html"><![CDATA[<p>《算法导论》第4章4.1使用分治策略求最大子数组（数组包含负数，不然整个数组即使最大子数组，求解没意义）。</p><p>思路：数组头为low，尾为high，mid=(low+high)/2，这样将数组分为了两段。首先肯定存在这个最大子数组。那么子数组的位置要么处于mid左边，要么处于mid右边，要么包含mid。假设最大子数组出现在mid左边，对mid左边子数组再进行(low+high)/2切分，那么最大子数组可能在切分出的子数组中的位置又存在三种情况中的一种，这样递归地切分下去，最终切分到整个数组都变为1-2个元素的子数组，这时候的情况就像一颗二叉树，例如数组[53,-4,-73,-16,88,91,-50,-15,-15,52,-19]，切分之后的二叉树：</p><p><img src="/img/max_sub_arr.jpeg" alt="maxsubarr"></p><p>然后用后续遍历二叉树的方式计算、查找最大子数组。如图，节点8的子数组有53、-4、53,-4，则找出来最大子数组为[53]，后序遍历的方式遍历完左子树，返回根，到右子树，有一个节点9，则最大子数组为9，对于节点4的左右子树的最大子数组都找到，再对节点8、4、9合并的数组找位于mid的最大子数组(此时low为0，mid为1，high为2，从mid出发往左走找最大子数组，再从mid+1出发往右走找最大子数组，再将找到的两个数组合并起来，为经过mid的最大子数组)，找到为[53,-4,-73]，将[53]、[-73]，[53,-4,-73]比较，得出根节点为4的树最大数组为[53]，则再返回根节点2，再后续到节点5，对5再求最大子数组为[88,91]，再对节点2求经过mid的最大子数组为[53,-4,-73,-16,88,91]，和为139，与[53]、[88,91]比较，选[88,91]；接着返回根节点1，对右子树节点2求最大子数组，为[52]，再对节点1组成的数组求经过mid的最大子数组，为[88,91,-50,-15,-15,52]，和为151，与[88,91]、[52]比较，选[88,91]。</p><pre><code>c代码：#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int crossLow = 0, crossHigh = 0, crossSum = 0;int finalLeftIndex = -1;int finalRightIndex = -1;int finalSubArraySum = 0;//求经过mid的最长子数组，范围low-highvoid find_max_crossing_subarray( int *arr,    int low, int mid, int high ){    if ( low == mid &amp;&amp; mid == high ) {        crossLow = low;        crossHigh = high;        crossSum = arr[mid];        return ;    }    int lMax = -10000000, rMax = -10000000;    int lTmpSum = 0, rTmpSum = 0;    int i = 0;    for ( i = mid; i &gt;= low; i-- ) {        lTmpSum += arr[i];        if ( lTmpSum &gt; lMax ) {            lMax = lTmpSum;            crossLow = i;        }    }    for ( i = mid + 1; i &lt;= high; i++ ) {        rTmpSum += arr[i];        if ( rTmpSum &gt; rMax ) {            rMax = rTmpSum;            crossHigh = i;        }    }    crossSum = lMax + rMax;}//分治，将数组切分子规模的待求数组void find_maximum_subarray( int *arr,    int low, int high ){    if ( high &lt;= low + 1 ) {        find_max_crossing_subarray( arr, low, low, high );        if ( arr[low] &gt;= arr[high] &amp;&amp; arr[low] &gt;= crossSum ) {            finalLeftIndex = low;            finalRightIndex = low;            finalSubArraySum = arr[low];        }        else if ( arr[high] &gt;= arr[low] &amp;&amp; arr[high] &gt;= crossSum ) {            finalLeftIndex = high;            finalRightIndex = high;            finalSubArraySum = arr[high];        }        else {            finalLeftIndex = low;            finalRightIndex = high;            finalSubArraySum = crossSum;        }    }    else {        int lLow = 0, lHigh = 0, lSum = 0;        int rLow = 0, rHigh = 0, rSum = 0;        //其实这里的递归就像二叉树的后续遍历，直到遍历完左子树，再开始右子树，        //这样的好处假如数组有上亿的元素，不会造成栈空间不足，        //解决了一个左子树就返回了递归栈，再进行右子树的展开工作        int mid = ( low + high ) / 2;        find_maximum_subarray( arr, low, mid );        lLow = finalLeftIndex;        lHigh = finalRightIndex;        lSum = finalSubArraySum;        find_maximum_subarray( arr, mid + 1, high );        rLow = finalLeftIndex;        rHigh = finalRightIndex;        rSum = finalSubArraySum;        find_max_crossing_subarray( arr, low, mid, high );        // printf(&quot;%d %d %d/%d %d %d/%d %d %d\n&quot;,        //     lLow, lHigh, lSum,        //     rLow, rHigh, rSum,        //     crossLow, crossHigh, crossSum);        if ( lSum &gt;= rSum &amp;&amp; lSum &gt;= crossSum ) {            finalLeftIndex = lLow;            finalRightIndex = lHigh;            finalSubArraySum = lSum;        }        else if ( rSum &gt;= lSum &amp;&amp; rSum &gt;= crossSum ) {            finalLeftIndex = rLow;            finalRightIndex = rHigh;            finalSubArraySum = rSum;        }        else {            finalLeftIndex = crossLow;            finalRightIndex = crossHigh;            finalSubArraySum = crossSum;        }        // printf(&quot;------%d %d %d\n&quot;, finalLeftIndex, finalRightIndex, finalSubArraySum);    }}//暴力破解法求最长子数组，不过这里用来测试我写的分治求法结果是否正确int check_result( int *arr, int len, int lIndex, int rIndex, int Sum ){    int maxSum = -100000000;    int lIndex1;    int rIndex1;    int i = 0, j = 0;    for ( i = 0; i &lt; len; i++ ) {        int tmpSum = 0;        for ( j = i; j &lt; len; j++ ) {            tmpSum += arr[j];            if ( tmpSum &gt; maxSum ) {                maxSum = tmpSum;                lIndex1 = i;                rIndex1 = j;            }        }    }    if ( Sum == maxSum ) {        if ( lIndex == lIndex1 &amp;&amp; rIndex == rIndex1 ) {            return 0;        }        printf(&quot;equal!!\n&quot;);        printf(&quot;exhaustivly_find_result:lIndex-&gt;%d,rIndex-&gt;%d,Sum-&gt;%d\n&quot;,            lIndex1, rIndex1, maxSum);        printf(&quot;divide_and_conquer_result:lIndex-&gt;%d,rIndex-&gt;%d,Sum-&gt;%d\n&quot;,            lIndex, rIndex, Sum);        return 1;    }    // else {    //     printf(&quot;not equal!!!!!!!!!&quot;);    // }    return -1;}void mainLoop( int *arr, int len ){    find_maximum_subarray( arr, 0, len - 1 );    printf(&quot;----------------------------------------------------\n&quot;);    printf(&quot;lIndex:%d,rIndex:%d,subArrSum:%d\n&quot;,        finalLeftIndex, finalRightIndex, finalSubArraySum);    printf(&quot;----------------------------------------------------\n&quot;);}void stepLoop( int *arr, int len ){    time_t tt0 = time( NULL );    printf(&quot;before:%s&quot;, ctime(&amp;tt0));    mainLoop( arr, len );    time_t tt1 = time( NULL );    printf(&quot;after:%s&quot;, ctime(&amp;tt1));    printf(&quot;cost %d(sec),%d(min)\n&quot;,        (int)(tt1 - tt0), (int)((tt1 - tt0) / 60));}//初始化随机数组void initArr( int *arr, int lowV,    int upV, int len ){    int i = 0;    int size = upV - lowV;    for ( ; i &lt; len; i++ )    {        arr[i] = rand() % size + lowV;    }}//打印数组void printArr( int *arr, int len ){    int i = 0;    for ( ; i &lt; len; i++ )        printf(&quot;%d &quot;, arr[i]);    printf(&quot;\n&quot;);}int main( int argc, char **argv ){    srand( (int)time(NULL) );    if ( argc != 4 )    {        printf(&quot;usage: ./execfile lowV upV len\n&quot;);        return 0;    }    int lowV = atoi( argv[1] );    int upV = atoi( argv[2] );    unsigned int len = atoi( argv[3] );    int *arr = NULL;    arr = ( int *) malloc( len * sizeof(int) );    // int len = 10;    // int arr[10] = {7, 0, -86, 61, -72, 50, -38, -25, -70, -76};    int i = 0;    //随机10000个数组求最大子数组，然后检测结果是否正确    for ( i = 0; i &lt; 10000; i++ ) {        initArr( arr, lowV, upV, len );        printArr( arr, len );        // stepLoop( arr, len );        usleep(1000);        find_maximum_subarray( arr, 0, len - 1 );        int ret = check_result( arr, len,                    finalLeftIndex, finalRightIndex, finalSubArraySum );        if ( ret &lt; 0 ) {            printf(&quot;failed!!\n&quot;);            return 0;        }        printf(&quot;-------------equal:%d\n&quot;, i);    }    free( arr );    arr = NULL;    return 0;}</code></pre><p>以上代码定义了几个全局变量，与《算法导论》的代码有点出入，书上的函数块返回3个值，例如：(left-low,left-high,left-sum) = FIND-MAXIMUM-SUBARRAY(A, low, mid)，这里可能用其它编程语言更好描述算法，erlang/golang/python的函数就可以返回一个元组并接收{LeftLow, LeftHigh, LeftSum} = FIND….()。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《算法导论》第4章4.1使用分治策略求最大子数组（数组包含负数，不然整个数组即使最大子数组，求解没意义）。&lt;/p&gt;
&lt;p&gt;思路：数组头为low，尾为high，mid=(low+high)/2，这样将数组分为了两段。首先肯定存在这个最大子数组。那么子数组的位置要么处于mid左
      
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>递归插入排序-《算法导论》学习笔记三</title>
    <link href="http://yoursite.com/2018/06/15/010recu-insert-sort/index/"/>
    <id>http://yoursite.com/2018/06/15/010recu-insert-sort/index/</id>
    <published>2018-06-15T12:15:00.000Z</published>
    <updated>2018-06-19T11:50:06.319Z</updated>
    
    <content type="html"><![CDATA[<p>算法导论第二章结尾练习2.3-4提到将插入排序写递归版本，然后尝试写了个，本来写了就好了，但是调试的时候排序10w个数可以，排序100w个数就段错误，分析了一下，把结果放上来以后查看，先贴代码：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void insert_sort0( int *arr, int index ){        int i, tmp = arr[index];        //printf(&quot;index:%d\n&quot;, index);        for ( i = index - 1; i &gt;= 0; i-- ) {                if ( arr[i] &gt; tmp ) {                        arr[i + 1] = arr[i];                } else {                        arr[i + 1] = tmp;                        return;                }        }        arr[i + 1] = tmp;}void insert_sort( int *arr, int index ){        //printf(&quot;index:%d\n&quot;, index);        if ( index &gt; 0 ) {                insert_sort( arr, index - 1 );                //printf(&quot;index:%d\n&quot;, index);                insert_sort0( arr, index );        }}void sortLoop0( int *arr, int len ){        //sleep( 20 );        insert_sort( arr, len - 1 );}//排序前后做时间对比，精度secvoid sortLoop( int *arr, int len ){        time_t tt0 = time( NULL );        printf(&quot;\tbefore sort:%s&quot;, ctime(&amp;tt0));        sortLoop0( arr, len );        time_t tt1 = time( NULL );        printf(&quot;\tafter sort:%s&quot;, ctime(&amp;tt1));        printf(&quot;\tsort the array cost %d(sec),%d(min)\n&quot;,                (int)(tt1 - tt0), (int)((tt1 - tt0) / 60));}//初始化随机数组void initArr( int *arr, int lowV,        int upV, int len ){        srand( (int)time(NULL) );        int i = 0;        int size = upV - lowV;        for ( ; i &lt; len; i++ )        {                arr[i] = rand() % size + lowV;        }}//打印数组void printArr( int *arr, int len ){        int i = 0;        for ( ; i &lt; len; i++ )                printf(&quot;%d &quot;, arr[i]);        printf(&quot;\n&quot;);}//这里写了个简单得数组检查，检查是否//是正确的递增序列(怕自己的代码没检查//边界条件偶尔有错误的排序数组)int check_arr_increase( int *arr, int len ){        int i = 0;        for ( ; i &lt; len - 1; i++ )        {                if ( arr[i] &lt;= arr[i + 1] )                        continue;                else                {                        printf(&quot;array isn&apos;t increase!!!\n&quot;);                        return -1;                }        }        printf(&quot;array is increase!!!!\n&quot;);        return 0;}int main( int argc, char **argv ){        if ( argc != 4 )        {                printf(&quot;usage: ./execfile lowV upV len\n&quot;);                return 0;        }        int lowV = atoi( argv[1] );        int upV = atoi( argv[2] );        unsigned int len = atoi( argv[3] );        int *arr = NULL;        arr = ( int *) malloc( len * sizeof(int) );        initArr( arr, lowV, upV, len );        //printArr( arr, len );        sortLoop( arr, len );        check_arr_increase( arr, len );        //printArr( arr, len );        free( arr );        arr = NULL;        return 0;}</code></pre><p>开始一直以为是代码有数组越界或者边界条件没考虑到，后来看了代码许久没发现问题。然后gdb看core文件，bt看调用栈发现段在递归向下大概70w-80w的位置，而递归栈还没返回，执行过程很正常没出问题，想了想是栈溢出，每次自顶向下调用一次自身函数就要在栈里保存一次函数地址和参数。</p><p>用ulimit -a|grep stack看了一下默认的栈空间大小为8192kb=8m=8<em>1024</em>1024=8388608byte。网上查了下说一次函数调用每次占用栈内存为：4返回地址 + 4<em>参数个数 + 4寄存器保护 + 4</em>局部变量数（未验证准确与否），我的排序占用4+4<em>2+12=24字节，但根据我每次设置栈大小调试程序，设置到31256kb时程序没有段错误，也就是31256</em>1024/1000000=32字节，这里的一次函数调用为32字节。</p><p>用ulimit -s 102400修改了栈空间大小100M（暂时修改），再次运行程序排序100w个数，发现打印正常，程序也没段错误了，只是递归栈开始返回等了好久。</p><p>对归并排序的思考：以前也有用归并排序排1亿个数（<a href="http://blog.csdn.net/u012785877/article/details/52475023" target="_blank" rel="noopener">http://blog.csdn.net/u012785877/article/details/52475023</a>），没有出现栈溢出，里面也是用递归的方法，因此仔细看了下归并排序（算法导论里有提到归并排序的递归树，可以算出数量，但是我看着头大，准备略过这些数学问题，先照着把代码写出来，看完了再回头深入看一遍），模拟了一下递归的栈过程如下：</p><p>假设有134217728个数待排序(2^27)。因此递归树根节点为2^27；递归第一次递归树有二层，两个节点分别为2^26、2^26；递归第三次递归树为有三层，四个节点分别为2^25、2^25、2^25、2^25……这样一直推到递归树叶子节点为2^1，此递归树有27层，2^(floor - 1) + 1 = 2^(26 -1) + 1 = 67108865个节点，也就是要维护67108865*30约为20亿的函数调用栈空间，为什么没有栈溢出呢？。通过调试归并排序，排序4个数时，是将0-3分为0-1，在将0-1分为0，对0再分发现不能分了，则此次递归返回到父节点，划分右子树1，对1再分发现不能分了，于是调用排序，将0、1排为0-1，再回归0-1的父节点，再对右子树2-3递归进行此过程。其实排序4个数最大只需要5次递归函数调用（即递归树走到最深度），如果排序n层递归树，最大需要n+1次。回到以上排序2^27个数，则最大同时需要28次递归函数调用，其余时候都是栈空间在不断出栈入栈。</p><p>上面写得有点昏，无奈不是学文科的，又不想画图，额。这个归并排序的分析结果只花了2个小时分析，也不能确定准不准确，如果错了欢迎批评指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;算法导论第二章结尾练习2.3-4提到将插入排序写递归版本，然后尝试写了个，本来写了就好了，但是调试的时候排序10w个数可以，排序100w个数就段错误，分析了一下，把结果放上来以后查看，先贴代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
      
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>c半同步半异步进程池模型之cgi服务器</title>
    <link href="http://yoursite.com/2018/06/15/009cgiserver/index/"/>
    <id>http://yoursite.com/2018/06/15/009cgiserver/index/</id>
    <published>2018-06-15T10:47:28.000Z</published>
    <updated>2018-06-19T02:02:56.131Z</updated>
    
    <content type="html"><![CDATA[<p>对半同步半异步进程池模型垂涎已久，这次中秋放假撸了下代码。</p><p>模型的简单介绍：主进程创建几个子进程作为工作进程，主进程监听客户端connect事件，一旦有连接事件，即通过round robin(简单轮询)选取一个子进程， 通过父子进程间的通信管道通知子进程有连接事件，子进程epoll监听到管道通信时间，即知道有客户端连接，因此进程accept，并将客户端连接套接字加入epoll监听事件，客户端浏览器发送get请求，客户端监听到请求事件，即调用封装好的客户端事件进行处理，本例子的客户端处理为recv客户的请求，从中提取文件名(now.cgi)，并重定向客户端连接套接字到stdout，然后执行对应cgi文件，cgi文件打印html页面字符串，因为重定向的缘故，打印的html字符串发送给客户端，客户端浏览器即显示了html页面。</p><p>代码写了几个模块，分别是：</p><p><code>util</code>：封装了套接字创建、unix族socket管道创建、中断信号、简单屏幕输出(可自行替换为日志文件输出)</p><p><code>epoll_wrapper</code>：封装了epoll相关操作包括创建epfd、添加epoll监听事件、删除epoll监听事件</p><p><code>myhshappool</code>(我的半同步半异步进程池 - -!…)：封装了进程池初始化、启动进程池进行事件监听</p><p><code>client_handle</code>：进程池监听到客户事件、即调用client_handle封装的处理事件，这里封装的是执行cgi文件向客户端浏览器返回服务器时间(最近在看unix网络编程，里面都是时间获取的服务器，借鉴下拿来搞事，当然，嵌入式里拿来控制个灯泡开关想来特别带劲，用android做个网页app，板子接wifi模块接智能灯，cgi负责开关灯泡 。。)</p><p><code>cgisrv</code>：入口，初始化进程池，启动进程池</p><p>代码快1k行，不知道一个博客文章能不能写下，这种玩具demo代码就不往github放了。代码中凑合写了注释(有时候不想切换中英文因此用了蹩脚的英文注释)，限(wo)于(tai)篇(lan)幅(le)没有写文件头注释和函数头注释。</p><p><code>util.h</code>：</p><pre><code>#ifndef _UTIL_H#define _UTIL_H#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;//这里不用 #转字符串了，不方便管理等级#ifdef LEVELNUMPRINT    #define LEVEL0 &quot;LEVEL0&quot;    #define LEVEL1 &quot;LEVEL1&quot;    #define LEVEL2 &quot;LEVEL2&quot;    #define LEVEL3 &quot;LEVEL3&quot;    #define LEVEL4 &quot;LEVEL4&quot;    #define LEVEL4 &quot;LEVEL5&quot;#else    #define LEVEL0  &quot;DEBUG&quot;    #define LEVEL1  &quot;INFO&quot;    #define LEVEL2  &quot;NOTICE&quot;    #define LEVEL3  &quot;WARN&quot;    #define LEVEL4  &quot;ERROR&quot;    #define LEVEL5  &quot;FATAL&quot;#endif#define PRINTINFO( LEVEL, format, args... ) \do { \    printf(&quot;[%s]:(pid:%d)/(file:%s)/(func:%s)/(line:%d)&quot;, \        LEVEL, getpid(), __FILE__, __func__, __LINE__); \    /*printf(&quot;\t&quot; #LEVEL &quot;:&quot;);*/ \    printf(&quot;--|--&quot;); \    printf( format, ##args ); \    printf(&quot;\n&quot;); \} while( 0 )#define PRINTINFO_ERR( LEVEL, format, args... ) \do { \    printf(&quot;[%s]:(pid:%d)/(file:%s)/(func:%s)/(line:%d)&quot;, \        LEVEL, getpid(), __FILE__, __func__, __LINE__); \    /*printf(&quot;\t&quot; #LEVEL &quot;:&quot;);*/ \    printf(&quot;--|--&quot;); \    printf( format, ##args ); \    printf(&quot;(errmsg:%s)&quot;, strerror(errno)); \    printf(&quot;\n&quot;); \} while( 0 )void Add_sig( int sig, void (*handler)(int),    int restart_syscall );void Socketpair( int *pairpipefd );int Socket_create( char *ipaddr, int port );void Setnonblocking( int fd );#endif</code></pre><p><code>util.c</code>:</p><pre><code>#include &quot;util.h&quot;static int add_sig( int sig, void (*handler)(int),    int restart_syscall ){    struct sigaction act;    bzero( &amp;act, sizeof(act) );    act.sa_handler = handler;    act.sa_flags = 0;    //早期unix系统对于进程在执行一个低速系统调用(如ioctl、    //read、write、wait)而阻塞期间捕捉到一个信号，则系统    //调用被中断不再执行，该系统调用返回错误，设置errno为    //EINTR，随后的bsd系统引入了自动重启，即再次进行此系统    //调用。unix衍生系统默认的方式可能为可选、总是等，类    //unix系统的linux系统可能默认为不重启，因此添加重启标识    if ( restart_syscall ) {        act.sa_flags |= SA_RESTART;    }    //宏定义：    //#define sigfillset(*p) (*p) = ~(0,0)    sigfillset( &amp;act.sa_mask );    if ( -1 == sigaction(sig, &amp;act, NULL) ) {        PRINTINFO_ERR( LEVEL4, &quot;sigaction error&quot; );        return -1;    }    return 0;}void Add_sig( int sig, void (*handler)(int),    int restart_syscall ){    if ( add_sig(sig, handler, restart_syscall) &lt; 0 ) {        PRINTINFO( LEVEL5, &quot;add_sig error&quot; );        exit( 0 );    }}void Socketpair( int *pairpipefd ){    int ret;    ret = socketpair( PF_UNIX, SOCK_STREAM,            0, pairpipefd );    if ( ret &lt; 0 ) {        PRINTINFO_ERR( LEVEL5, &quot;socketpair error!!&quot; );        exit( 0 );    }}static int socket_create( char *ipaddr, int port,    int backlog ){    int sockfd;    int ret;    sockfd = socket( AF_INET, SOCK_STREAM, 0 );    if ( sockfd &lt; 0 ) {        PRINTINFO_ERR( LEVEL4, &quot;socket error!!!&quot; );        return -1;    }    struct sockaddr_in addr;    bzero( &amp;addr, sizeof(addr) ) ;    addr.sin_family     = AF_INET;    addr.sin_port       = htons( port );    inet_pton( AF_INET, ipaddr, &amp;addr.sin_addr );    int reuseaddr = 1;    setsockopt( sockfd, SOL_SOCKET, SO_REUSEADDR,        &amp;reuseaddr, sizeof(int) );    ret = bind( sockfd, (struct sockaddr *)&amp;addr, (socklen_t)sizeof(addr) ) ;    if ( ret &lt; 0 ) {        PRINTINFO_ERR( LEVEL4, &quot;bind error!!!&quot; );        return -1;    }    ret = listen( sockfd, backlog );    if ( ret &lt; 0 ) {        PRINTINFO_ERR( LEVEL4, &quot;listen error!!!&quot; );        return -1;    }    return sockfd;}int Socket_create( char *ipaddr, int port ){    int ret;    ret = socket_create( ipaddr, port, 5 );    if ( ret &lt; 0 ) {        PRINTINFO( LEVEL5, &quot;socket_creaet error!!!&quot; );        exit( 0 );    }    return ret;}static int setnonblocking( int fd ){    int old_opt = fcntl( fd, F_GETFL );    int new_opt = old_opt | O_NONBLOCK;    fcntl( fd, F_SETFL, new_opt );    return old_opt;}void Setnonblocking( int fd ){    setnonblocking( fd );}int Send ( int socket_fd, const unsigned char * send_buf,    int buf_size, int flag ){    int snd_bytes = 0;    int snd_total_bytes = 0;    int snd_count = 3;    while ( snd_count -- ) {        snd_bytes = send( socket_fd, send_buf, buf_size, flag );        if ( snd_bytes &lt;= 0 ) {            if ( EAGAIN == errno || EINTR == errno              || EWOULDBLOCK == errno ) { //暂时发送失败，需要重复发送                usleep( 50 );                continue;            }else {  //连接不正常，返回-1交由上层清理此套接字                PRINTINFO_ERR( LEVEL4, &quot;send return error!!!&quot; );                return -1;            }        }        snd_total_bytes += snd_bytes;        if ( snd_total_bytes &gt;= buf_size ) {            break;        }    }    if ( !snd_count ) {        PRINTINFO( LEVEL4, &quot;send timeout!!!&quot; );        return -1;    }    return snd_total_bytes;}#if 0int main(){    PRINTINFO( LEVEL0, &quot;likun:%d&quot;, 123 );    PRINTINFO( LEVEL1, &quot;likun:&quot; );    //PRINTINFO( likun, &quot;likun:&quot; );    return 0;}#endif</code></pre><p><code>epoll_wrapper.h</code>:</p><pre><code>#ifndef _EPOLL_WRAPPER_H#define _EPOLL_WRAPPER_H#include &lt;sys/epoll.h&gt;#include &lt;stdlib.h&gt;int Epoll_create( int size );int Epoll_wait( int epfd, struct epoll_event *events,        int maxevents, int timeout );void Epoll_add_fd( int epfd, int fd );void Epoll_del_fd( int epfd, int fd );#endif</code></pre><p><code>epoll_wrapper.c</code>:</p><pre><code>#include &quot;epoll_wrapper.h&quot;#include &quot;util.h&quot;static int epoll_create0( int size ){    int ret;    ret = epoll_create( size );    if ( ret &lt;= 0 ) {        PRINTINFO_ERR( LEVEL3, &quot;epoll_create error!!!&quot; );        return -1;    }    return ret;}int Epoll_create( int size ){    int ret;    if ( (ret = epoll_create0(size)) &lt; 0 ) {        PRINTINFO( LEVEL5, &quot;epoll_create0 error!!!&quot; );        exit( 0 );    }    return ret;}int Epoll_wait( int epfd, struct epoll_event *events,        int maxevents, int timeout ){    return epoll_wait( epfd, events, maxevents, timeout );}static int epoll_add_fd( int epfd, int fd ){    struct epoll_event event;    event.data.fd = fd;    event.events  = EPOLLIN | EPOLLET;    epoll_ctl( epfd, EPOLL_CTL_ADD, fd, &amp;event );    Setnonblocking( fd );    return 0;}void Epoll_add_fd( int epfd, int fd ){    epoll_add_fd( epfd, fd );}void Epoll_del_fd( int epfd, int fd ){    epoll_ctl( epfd, EPOLL_CTL_DEL, fd, NULL );}#if 0int main(){}#endif</code></pre><p><code>myhshappool.h</code>:</p><pre><code>#ifndef _MY_HS_HA_P_POOL_H#define _MY_HS_HA_P_POOL_H#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;signal.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/stat.h&gt;#include &lt;libgen.h&gt;typedef struct process {    //当前进程id号    pid_t   pid;    //与父进程通信用的管道    //0端父进程写    //1端子进程读    int     pipefd[2];} process;typedef struct processpool {    //进程池最大进程数    int     max_process_num;    //每个进程最大处理客户数量    int     max_user_num;    //epoll最多处理的事件数    int     max_epoll_event;    //当前进程池进程总数    int     cur_process_num;    //当前子进程在进程池序号，从0开始    int     index;    //每个进程一个epoll内核事件表    int     epollfd;    //监听socket    int     listenfd;    //停止线程池    int     stop;    //进程池子进程管理    struct process *sub_process;} processpool;int init_process_pool( processpool *ppool, int maxpnum,    int maxunum, int maxeevent, int curpnum, int listenfd );void run( processpool *ppool );#endif</code></pre><p><code>myhshappool.c</code>:</p><pre><code>#include &quot;myhshappool.h&quot;#include &quot;client_handle.h&quot;#include &quot;util.h&quot;//用于信号中断时主进程通信，//统一处理事件，即将客户端连接//事件、信号事件都统一用epoll//监听处理，0端信号处理函数写，//1端进程读static int sig_pipefd[2];static void sig_handler( int sig ){    //保存旧的errno，对后续的send不    //进行错误判定，但send假如返回    //失败会设置errno，信号中断调用    //结束后影响进程其它模块判断    int old_errno = errno;    char signo     = (char)sig;    send( sig_pipefd[0], (char *)&amp;signo, 1, 0 );    errno = old_errno;}static void init_signal( processpool *ppool ){    Socketpair( sig_pipefd );    Setnonblocking( sig_pipefd[0] );    //Epoll_add_fd( ppool-&gt;epollfd, sig_pipefd[1] );    Add_sig( SIGCHLD, sig_handler, 1 );    Add_sig( SIGTERM, sig_handler, 1 );    Add_sig( SIGINT,  sig_handler, 1 );    Add_sig( SIGPIPE, SIG_IGN, 1 );}int init_process_pool( processpool *ppool, int maxpnum,    int maxunum, int maxeevent, int curpnum, int listenfd ){    if ( !ppool ) {        PRINTINFO( LEVEL4, &quot;ppool is null!!!&quot; );        return -1;    }    ppool-&gt;max_process_num  = maxpnum;    ppool-&gt;max_user_num     = maxunum;    ppool-&gt;max_epoll_event  = maxeevent;    ppool-&gt;cur_process_num  = curpnum;    ppool-&gt;listenfd         = listenfd;    // ppool-&gt;epollfd          = Epoll_create( 5 );    ppool-&gt;index            = -1;    ppool-&gt;stop             = 0;    ppool-&gt;sub_process =        (process *)calloc( sizeof(process), curpnum );    if ( !ppool-&gt;sub_process ) {        PRINTINFO( LEVEL4, &quot;sub_process calloc error!!!&quot; );        return -1;    }    int i = 0;    int pid;    //先模拟一下进程池创建之前的情况，假设终端    //bash shell进程id为1000，运行此程序进程id    //为1001，其父进程为1000，fork之后主进程不    //变，子进程id为1002，其父进程为1001，因此    //明白fork的过程，下面可以走一下进程池创建    //的流程（条件均为以上假设）：    //第一次fork:创建亲缘进程的管道，父进程1001    //，子进程1002，其父进程为1001，子进程不再    //执行for循环，且主进程与1002子进程有单独通    //信的管道    //第二次fork:创建亲缘进程的管道，父进程1001    //，子进程1003，其父进程为1001，子进程不再    //执行for循环，且主进程与1003子进程有单独通    //信的管道    //第三次fork .....1004.....    //    ........    //通过以上过程，可以看到for循环次数为创建的    //子进程数量，且每个子进程可以单独与父进程    //通信    //    //这里进程创建，没有脱离当前终端的会话，    //我觉得可以setsid()来摆脱终端影响    for ( ; i &lt; curpnum; i++ ) {        Socketpair( ppool-&gt;sub_process[i].pipefd );        pid = fork();        if ( pid &gt; 0 ) { //parent fork            close( ppool-&gt;sub_process[i].pipefd[1] );            ppool-&gt;sub_process[i].pid = pid;            Setnonblocking( ppool-&gt;sub_process[i].pipefd[0] );            continue;        } else if ( pid == 0 ) { //child            ppool-&gt;index = i;            PRINTINFO( LEVEL0, &quot;child(%d):%d\tparent:%d&quot;, i + 1, getpid(), getppid() );            close( ppool-&gt;sub_process[i].pipefd[0] );            //每次只由父进程去创建进程            break;        }        else {            PRINTINFO( LEVEL5, &quot;fork error!!!&quot; );            exit( 0 );        }    }}static int client_signal_handle( processpool *ppool,    char *signals, int signals_num ){    int i = 0;    for ( ; i &lt; signals_num; i++ ) {        switch( signals[i] ) {            case SIGCHLD:            {                PRINTINFO( LEVEL0, &quot;child receive a SIGCHLD signal&quot; );                pid_t pid;                int stat;                //catch SIGCHLD                while ( (pid = waitpid(-1, &amp;stat, WNOHANG)) &gt; 0 ) {                    continue;                }                break;            }            case SIGTERM:            {                PRINTINFO( LEVEL0, &quot;child receive a SIGTERM signal&quot; );                ppool-&gt;stop = 1;                break;            }            case SIGINT:            {                PRINTINFO( LEVEL0, &quot;child receive a SIGINT signal&quot; );                ppool-&gt;stop = 1;                break;            }            default:            {                break;            }        }    }}static void run_child( processpool *ppool ){    if ( !ppool ) {        PRINTINFO( LEVEL4, &quot;ppool is null!!!&quot; );        return;    }    init_signal( ppool );    ppool-&gt;epollfd          = Epoll_create( 5 );    PRINTINFO( LEVEL0, &quot;child cur process:%d&quot;, ppool-&gt;cur_process_num );    int pipefd = ppool-&gt;sub_process[ppool-&gt;index].pipefd[1];    Epoll_add_fd( ppool-&gt;epollfd, pipefd );    Epoll_add_fd( ppool-&gt;epollfd, sig_pipefd[1] );    struct epoll_event *events = (struct epoll_event *)        calloc( sizeof(struct epoll_event), ppool-&gt;max_epoll_event );    if ( !events ) {        PRINTINFO( LEVEL5, &quot;calloc error!!!&quot; );        goto _free_source;    }    struct client_param *cparam = NULL;    cparam = (struct client_param *)                calloc( sizeof(struct client_param), ppool-&gt;max_user_num );    if ( !cparam ) {        PRINTINFO( LEVEL5, &quot;calloc error!!!&quot; );        goto _free_source;    }    int event_num, event_fd;    int i, j, ret, onebyte;    while ( !ppool-&gt;stop ) {        event_num = Epoll_wait( ppool-&gt;epollfd, events, ppool-&gt;max_epoll_event, -1);        //PRINTINFO( LEVEL0, &quot;child event num:%d&quot;, event_num );        if ( (event_num &lt; 0) &amp;&amp; (errno != EINTR) ) {            PRINTINFO_ERR( LEVEL4, &quot;Epoll_wait error!!!&quot; );            ppool-&gt;stop = 1;            break;        }        for ( i = 0; i &lt; event_num; i++ ) {            event_fd = events[i].data.fd;            //parent process notify that there is a new client connect to.            if ( event_fd == pipefd &amp;&amp; events[i].events &amp; EPOLLIN ) {                PRINTINFO( LEVEL0, &quot;receive signal from parent there is a new client connection&quot; );                ret = recv( event_fd, (char *)&amp;onebyte, 1, 0 );                if ( ret &lt;= 0 ) {                    continue;                } else {                    struct sockaddr_in clientaddr;                    socklen_t addrlen = sizeof(clientaddr);                    bzero( &amp;clientaddr, addrlen );                    int connfd = accept( ppool-&gt;listenfd,                                    (struct sockaddr *)&amp;clientaddr, &amp;addrlen );                    if ( connfd &lt; 0 ) {                        PRINTINFO_ERR( LEVEL3, &quot;accept a new client error!!!&quot; );                        continue;                    }                    PRINTINFO( LEVEL0, &quot;one client conntect(fd:%d)&quot;, connfd );                    Epoll_add_fd( ppool-&gt;epollfd, connfd );                    client_param_init( &amp;cparam[connfd], connfd, &amp;clientaddr );                }            }            //process catch a signal            else if ( event_fd == sig_pipefd[1] &amp;&amp; events[i].events &amp; EPOLLIN ) {                int sig;                char signals[1024] = {0};                ret = recv( sig_pipefd[1], signals, sizeof(signals), 0 );                if ( ret &lt;= 0 ) {                    continue;                }                client_signal_handle( ppool, signals, ret );            }            //client socket fd has readable event,maybe a            //request            else if ( events[i].events &amp; EPOLLIN ) {                client_handle( &amp;cparam[event_fd] );            }            else {                continue;            }        }    }_free_source:    free( events );    events = NULL;    free( cparam );    cparam = NULL;    close( pipefd );    close( ppool-&gt;epollfd );}static int parent_signal_handle( processpool *ppool,    char *signals, int signals_num ){    int i = 0, j = 0;    for ( ; i &lt; signals_num; i++ ) {        switch( signals[i] ) {            case SIGCHLD:            {                PRINTINFO( LEVEL0, &quot;parent receive SIGCHLD signal&quot; );                pid_t pid;                int stat;                while ( (pid = waitpid(-1, &amp;stat, WNOHANG)) &gt; 0 ) {                    PRINTINFO( LEVEL0, &quot;parent receive SIGCHLD signal(pid:%d)&quot;, pid );                    for ( j = 0; j &lt; ppool-&gt;cur_process_num; j++ ) {                        if ( ppool-&gt;sub_process[j].pid == pid ) {                            PRINTINFO( LEVEL3, &quot;child process(%d) exit.&quot;, pid );                            close( ppool-&gt;sub_process[j].pipefd[1] );                            ppool-&gt;sub_process[j].pid = -1;                        }                    }                }                ppool-&gt;stop = 1;                for ( j = 0; j &lt; ppool-&gt;cur_process_num; j++ ) {                    PRINTINFO( LEVEL0, &quot;pid:%d&quot;, ppool-&gt;sub_process[j].pid );                    if ( ppool-&gt;sub_process[j].pid != -1 ) {                        ppool-&gt;stop = 0;                        break;                    }                }                break;            }            case SIGTERM:            case SIGINT:            {                PRINTINFO( LEVEL2, &quot;recv SIGINT/SIGTERM, kill all child process now.&quot; );                //PRINTINFO( LEVEL0, &quot;cur_process_num:%d&quot;, ppool-&gt;cur_process_num );                for ( i = 0; i &lt; ppool-&gt;cur_process_num; i++ ) {                    int pid = ppool-&gt;sub_process[i].pid;                    if ( pid != -1 ) {                        PRINTINFO( LEVEL0, &quot;kill process:%d&quot;, pid );                        ppool-&gt;sub_process[i].pid = -1;                        kill( pid, SIGTERM );                    }                }                ppool-&gt;stop = 1;                break;            }            default:            {                break;            }        }    }}static void run_parent( processpool *ppool ){    if ( !ppool ) {        PRINTINFO( LEVEL4, &quot;ppool is null!!!&quot; );        return;    }    init_signal( ppool );    ppool-&gt;epollfd          = Epoll_create( 5 );    Epoll_add_fd( ppool-&gt;epollfd, ppool-&gt;listenfd );    Epoll_add_fd( ppool-&gt;epollfd, sig_pipefd[1] );    struct epoll_event *events = NULL;    events = (struct epoll_event *)        calloc( sizeof(struct epoll_event), ppool-&gt;max_epoll_event );    if ( !events ) {        PRINTINFO( LEVEL5, &quot;calloc error!!!&quot; );        char sig = SIGINT;        parent_signal_handle( ppool, &amp;sig, 1 );        goto _free_source;    }    int event_num;    int i, onebyte = 1, ret, j;    //p_idx specifies current dispatched child process.    //roll_index specifies the next child process.    int p_idx , roll_index = 0;    //PRINTINFO( LEVEL0, &quot;epollfd:%d&quot;, ppool-&gt;epollfd );    while ( !ppool-&gt;stop ) {        //Specifying  a timeout of -1 causes epoll_wait()        //to block indefinitely.        event_num =            Epoll_wait( ppool-&gt;epollfd, events, ppool-&gt;max_epoll_event, -1 );        if ( event_num &lt; 0 &amp;&amp; errno != EINTR ) {            PRINTINFO_ERR( LEVEL5, &quot;Epoll_wait error!!!&quot; );            ppool-&gt;stop = 1;            break;        }        //PRINTINFO( LEVEL0, &quot;event_num:%d&quot;, event_num );        for ( i = 0; i &lt; event_num; i++ ) {            int event_fd = events[i].data.fd;            //listenfd,there is a new client connection.            //notify child process to accept            if ( event_fd == ppool-&gt;listenfd ) {                PRINTINFO( LEVEL0, &quot;event:parent listenfd&quot; );                //round robin dispatch                //easily roll polling                p_idx = roll_index;                do {                    if ( ppool-&gt;sub_process[p_idx].pid != -1 ) {                        break;                    }                    p_idx = ( p_idx + 1 ) % ppool-&gt;cur_process_num;                } while ( p_idx != roll_index );                //roll polling all the child process,but they are                //all run error.so p_idx equals to roll_index.                if ( ppool-&gt;sub_process[p_idx].pid &lt; 0 ) {                    ppool-&gt;stop = 1;                    break;                }                roll_index = ( p_idx + 1 ) % ppool-&gt;cur_process_num;                if ( Send( ppool-&gt;sub_process[p_idx].pipefd[0],                        (char *)&amp;onebyte, 1, 0 ) &lt; 0 ) {                    PRINTINFO( LEVEL5, &quot;Send error!!!&quot; );                    ppool-&gt;stop = 1;                    break;                }            }            //receive signal from signal handler.            else if ( (event_fd == sig_pipefd[1])                &amp;&amp; (events[i].events &amp; EPOLLIN) ) {                PRINTINFO( LEVEL0, &quot;event:parent receive signal&quot; );                int sig;                char signals[1024];                ret = recv( sig_pipefd[1], signals, sizeof(signals), 0 );                if ( ret &lt;= 0 ) {                    continue;                } else {                    parent_signal_handle( ppool, signals, ret );                }            }        }    }_free_source:    free( events );    events = NULL;    close( ppool-&gt;epollfd );}void run( processpool *ppool ){    if ( ppool-&gt;index != -1 ) {        run_child( ppool );        return;    }    run_parent( ppool );}</code></pre><p><code>client_handle.h</code>:</p><pre><code>#ifndef _CLIENT_HANDLE_H#define _CLIENT_HANDLE_H#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;arpa/inet.h&gt;#define MAXRECVBUF  1024typedef struct client_param {    //用于recv返回出错移除sockfd    int epollfd;    int sockfd;    struct sockaddr_in addr;    char buf[ MAXRECVBUF ];} client_param;void client_param_init( client_param *cparam,    int connfd, struct sockaddr_in *addr );void client_handle( client_param *cparam );#endif</code></pre><p><code>client_handle.c</code>:</p><pre><code>#include &quot;client_handle.h&quot;#include &quot;util.h&quot;void client_param_init( client_param *cparam,    int connfd, struct sockaddr_in *addr ){    if ( !cparam ) {        PRINTINFO( LEVEL4, &quot;cparam is null!!!&quot; );        return;    }    cparam-&gt;sockfd = connfd;    memcpy( &amp;cparam-&gt;addr, addr, sizeof(struct sockaddr_in) );    memset( cparam-&gt;buf, 0, sizeof(cparam-&gt;buf) );}void client_handle( client_param *cparam ){    int i, ret;    while ( 1 ) {        memset( cparam-&gt;buf, 0, sizeof(cparam-&gt;buf) );        ret = recv( cparam-&gt;sockfd, cparam-&gt;buf, sizeof(cparam-&gt;buf), 0 );        if ( ret &lt; 0 ) {            if ( errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK                &amp;&amp; errno != EINTR ) {                Epoll_del_fd( cparam-&gt;epollfd, cparam-&gt;sockfd );            }            close( cparam-&gt;sockfd );            break;        }        else if ( 0 == ret ) {            Epoll_del_fd( cparam-&gt;epollfd, cparam-&gt;sockfd );            close( cparam-&gt;sockfd );            break;        }        else {            if ( ret &lt; 15 ) {                close( cparam-&gt;sockfd );                break;            }            //PRINTINFO( LEVEL0, &quot;child receive buf:\n%s&quot;, cparam-&gt;buf );            fflush(stdout);            char *p_get = strstr( cparam-&gt;buf, &quot;GET&quot; );            if ( !p_get ) {                close( cparam-&gt;sockfd );                break;            }            char *p_http = strstr( cparam-&gt;buf, &quot;HTTP&quot; );            if ( !p_http ) {                close( cparam-&gt;sockfd );                break;            }            cparam-&gt;buf[ret] = &apos;\0&apos;;            //GET filename HTTP/1.1 .....            char file_name[20] = {0};            int file_name_len = p_http - p_get - 6;            memcpy( file_name, p_get + 5, file_name_len );            if ( access( file_name, F_OK ) == -1 ) {                PRINTINFO( LEVEL3, &quot;file:(%s) dosen&apos;t exist!!&quot;, file_name );                Epoll_del_fd( cparam-&gt;epollfd, cparam-&gt;sockfd );                close( cparam-&gt;sockfd );                break;            }            PRINTINFO( LEVEL0, &quot;file name:%s--&quot;, file_name );            ret = fork();            if ( ret == -1 ) {                Epoll_del_fd( cparam-&gt;epollfd, cparam-&gt;sockfd );                close( cparam-&gt;sockfd );                break;            }            else if ( ret &gt; 0 ) {                Epoll_del_fd( cparam-&gt;epollfd, cparam-&gt;sockfd );                close( cparam-&gt;sockfd );                break;            }            else {                close( STDOUT_FILENO );                //relocate the stdou to sockfd                PRINTINFO( LEVEL0, &quot;sockfd:%d&quot;, cparam-&gt;sockfd );                dup( cparam-&gt;sockfd );                //printf(&quot;likun\n&quot;);                execl( file_name, file_name, NULL );                fflush(stdout);                Epoll_del_fd( cparam-&gt;epollfd, cparam-&gt;sockfd );                close( cparam-&gt;sockfd );                exit( 0 );            }        }    }}</code></pre><p><code>cgisrv.c</code>:</p><pre><code>#include &quot;myhshappool.h&quot;#include &quot;client_handle.h&quot;#include &quot;util.h&quot;#include &quot;epoll_wrapper.h&quot;//进程池最大数量#define MAXPROCESSNUMBER            16//每个进程支持客户连接任务#define USERPERPROCESS              65535//epool最大支持的监听事件数#define MAXEPOLLEVENT               10000processpool ppool;int main(){    int listenfd = Socket_create( &quot;192.168.1.250&quot;, 8888 );    init_process_pool( &amp;ppool, MAXPROCESSNUMBER,        USERPERPROCESS, MAXEPOLLEVENT, 5, listenfd );    run( &amp;ppool );    close( listenfd );    return 0;}</code></pre><p>贴一下makefile：</p><pre><code>CC = gccROOTDIR = $(shell pwd)OBJ = util.o myhshappool.o epoll_wrapper.o \client_handle.o cgisrc.oBIN = cgisrv.binCFLAG = -Wall -O2 -I./LDFLAG += -c$(BIN):${OBJ}    $(CC) $(CFLAG) -o $@ $^%:%.c    $(CC) $(CFLAG) -o $@ $&lt; $(LDFLAG).PHONY:cleanclean:    rm $(OBJ) $(BIN) -rf</code></pre><p>还有cgi执行程序：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;/*&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1&gt;&lt;u&gt;&lt;font color=00ff00&gt;..&lt;/font&gt;&lt;/u&gt;&lt;/h1&gt;    &lt;/body&gt;&lt;/html&gt;*/int main( int argc, char **argv ){    time_t tt = time(NULL);    printf(&quot;&lt;!DOCTYPE html&gt;&quot;);    printf(&quot;&lt;html&gt;&quot;);    printf(&quot;&lt;head&gt;&quot;);    printf(&quot;&lt;meta charset=\&quot;utf-8\&quot;&gt;&quot;);    printf(&quot;&lt;title&gt;get now time&lt;/title&gt;&quot;);    printf(&quot;&lt;/head&gt;&quot;);    printf(&quot;&lt;body&gt;&quot;);    printf(&quot;&lt;h1&gt;&lt;u&gt;&lt;font color=00ff00&gt;&quot;);    printf(&quot;当前服务器时间:%s&quot;, ctime(&amp;tt));    printf(&quot;&lt;/font&gt;&lt;/u&gt;&lt;/h1&gt;&quot;);    printf(&quot;&lt;/body&gt;&quot;);    printf(&quot;&lt;/html&gt;&quot;);    return 0;}</code></pre><p>测试：代码编译了，即可执行cgisrv.bin，主进程处于监听客户端连接情况，打开浏览器输入: <code>http://xxx.xxx.xxx.xxx:8888/now.cgi，可以看到出现一行加下划线的绿字：当前服务器时间:Sat Sep 17 21:49:07 2016</code>。</p><p>ip、端口、进程池数、最大epoll监听事件数等在入口模块(cgisrv)可以改。</p><p>本例子写完，调试了几个地方，运行几个客户端发送get请求就没有做测试了，练手的玩具demo ^_^。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对半同步半异步进程池模型垂涎已久，这次中秋放假撸了下代码。&lt;/p&gt;
&lt;p&gt;模型的简单介绍：主进程创建几个子进程作为工作进程，主进程监听客户端connect事件，一旦有连接事件，即通过round robin(简单轮询)选取一个子进程， 通过父子进程间的通信管道通知子进程有连接
      
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
  </entry>
  
</feed>
