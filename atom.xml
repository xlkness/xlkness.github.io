<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>My Blog</title>
  
  <subtitle>我的小站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-15T01:39:24.792Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>lkness</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux daemon守护进程的创建</title>
    <link href="http://yoursite.com/2018/06/14/004deamon/index/"/>
    <id>http://yoursite.com/2018/06/14/004deamon/index/</id>
    <published>2018-06-15T01:31:50.000Z</published>
    <updated>2018-06-15T01:39:24.792Z</updated>
    
    <content type="html"><![CDATA[<p>今天在看《UNIX网络编程》的时候，看到了守护进程的创建，代码中fork了两次，并且第一次fork后对子进程调用setsid()，有些懵。当时搜了下setsid也是看得有点云里雾里。后来折腾了一下午，才算有点明白，这里把自己的一点分析心得写上来，以后忘了可以翻翻：</p><p>这里我用ssh登陆ubuntu，在终端用vim编写。</p><h1 id="第一次fork"><a href="#第一次fork" class="headerlink" title="第一次fork"></a>第一次fork</h1><p>我们先写一个简单的代码来fork并创建一个后台程序，代码如下：</p><pre><code>//testdaemon1.c#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;int main(){    pid_t   pid;    if ( (pid = fork()) &lt; 0 )        return -1;    else if ( pid )        exit( 0 );    signal( SIGHUP, SIG_IGN );    int i = 10;    while ( i-- )        sleep( 5 );    return 0;}</code></pre><p>编译<code>gcc -o testdaemon1 testdaemon1.c</code><br>运行<code>./testdaemon1</code></p><p>然后我们用ps查看程序:<code>ps axjf | grep testdaemon1</code></p><blockquote><p>1 28511 28510 28168 pts/18 28168 S 0 0:00 ./testdaemon1</p></blockquote><p>这里看第二列是进程id(28511)，第四列是sessionId(28168)，第五列是控制终端(pts/18)，代码中子进程fork而来，会默认继承父进程的控制终端以及会话组。而如果我们查看linux后台守护进程的话，会发现进程控制终端为“？”，因此这个代码距离标准的守护进程还有距离，后面逐一分析。</p><p>什么是会话session呢？我大概的理解就是linux下进程组织结构分很多会话，一个会话有很多进程，会话的首进程会有一个控制终端，一个会话只能有一个控制终端。而我们现在用ssh登陆ubuntu创建了一个会话，此会话首进程id号就是28168,如果我们运行ps aux | grep 28168会输出下面值:</p><blockquote><p>root 28168 0.0 0.4 6904 4640 pts/18 Ss+ 16:06 0:00 -bash</p></blockquote><p>可以看到这个进程是 bash进程shell终端，其控制终端是pts/18，此后我们在此终端运行的进程都属于以这个首进程id为sessionId的会话组，我们可以运行一个后台的top程序:<br><code>top &amp;</code><br><code>ps axjf | grep top</code>得到下面输出：</p><blockquote><p>28168 28670 28670 28168 pts/18 28672 T 0 0:00 _ top</p></blockquote><p>再看28168的会话组：</p><p><code>ps axjf | grep 28168</code>得到下面输出：</p><blockquote><p>28141 28168 28168 28168 pts/18 28693 Ss 0 0:00 _ -bash</p></blockquote><blockquote><p>28168 28670 28670 28168 pts/18 28693 T 0 0:00 _ top</p></blockquote><blockquote><p>28168 28693 28693 28168 pts/18 28693 R+ 0 0:00 _ ps axjf</p></blockquote><blockquote><p>28168 28694 28693 28168 pts/18 28693 S+ 0 0:00 _ grep –color=auto 28168</p></blockquote><blockquote><p>1 28691 28690 28168 pts/18 28693 S 0 0:00 ./testdaemon1</p></blockquote><p>可以看到运行的几个后台程序sid都是28168。</p><p>说了这么多，这个会话组有什么作用呢？我们就要提到SIGHUP信号了，SIGHUP信号会在终端关闭时或者会话首进程退出时发送给会话组的其它进程，当其它进程收到此信号时如果不捕获或者忽略信号的话，默认会退出。<br>如果现在点击ssh窗口的×关闭终端界面或者kill -9 28618的话，下面所属的进程都会退出。</p><p>因此，我们在代码中要调用setsid()，将子进程与父进程会话分离、终端分离，我们加入setsis再编译执行：</p><p><code>./testdaemon1</code><br>执行<code>ps axjf | grep testdaemon1</code></p><blockquote><p>1 28891 28891 28891 ? -1 Ss 0 0:00 ./testdaemon1</p></blockquote><p>看到其所属会话组已经变成新的（它自己为首进程）会话组，而终端也变为？，这正是我们看linux下其他守护进程的状态。</p><h1 id="第二次fork"><a href="#第二次fork" class="headerlink" title="第二次fork"></a>第二次fork</h1><p>第一次fork还不够，因为我们setsid之后，第一子进程变为新会话首进程，它有权限重新申请打开一个终端，为了避免这种情况，可以通过使进程不再成为会话组长来禁止进程重新打开控制终端，这就需要第二次调用fork()函数</p><h1 id="改变工作路径"><a href="#改变工作路径" class="headerlink" title="改变工作路径"></a>改变工作路径</h1><p>第二次fork之后，我们在第二子进程里可以进行一些守护进程属性设置了， 改变工作路径可以用chdir(“/”)，为什么要改变工作路径呢？《unix网络编程》中Stevens大神说得很清楚，这里搬过来“守护进程可能是在某个任意的文件系统中启动，如果仍然在其中，那么该文件系统就无法拆卸(unmounting)，除非使用潜在的破坏性的强制措施。”</p><h1 id="关闭所有打开的文件描述符"><a href="#关闭所有打开的文件描述符" class="headerlink" title="关闭所有打开的文件描述符"></a>关闭所有打开的文件描述符</h1><p>守护进程从执行它的进程(当前的shell)继承所有打开的描述符。但没有现成的函数提供来检测打开的文件描述符，Stevens大神的解决办法是关闭前64个，而我在网上找到的有用getdtablesize()，有用NOFILE宏(sys/param.h)的，我的ubuntu前者为1024，后者为256，也不想去深究了。</p><h1 id="重定向stdin、stdout、stderr"><a href="#重定向stdin、stdout、stderr" class="headerlink" title="重定向stdin、stdout、stderr"></a>重定向stdin、stdout、stderr</h1><p>上一步关闭了0开始的描述符，而stdin stdout stderr分别对应0 1 2，因此关闭之后如果不进行重定向，守护进程分配文件描述符会从0开始，因此stevens大神打开/dev/null三次，分配了三次描述符，分别为012，都对应/dev/null</p><p>#<br>贴上整个代码吧（跟《UNIX网络编程》里代码有些出入，某些东西也懒得深究了）：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;int main(){    pid_t   pid;    //原代码的fork用的封装函数Fork，其实多了对fork查错    if ( (pid = fork()) &lt; 0 )        return -1;    else if ( pid )        exit( 0 );    setsid();    //原代码用的封装函数Sianal，这里懒得写了    //父进程退出，会给所有子进程发一个SIGHUP信号，进程接收到此信号如果不做捕获处理默认会退出    signal( SIGHUP, SIG_IGN );    if ( (pid = fork()) &lt; 0 )        return -1;    else if ( pid )        exit( 0 );    //daemon_proc = 1;//原代码有这句    chdir(&quot;/&quot;);    int i = 0;    for ( ; i &lt; 64; i++ )        close( i );    open(&quot;/dev/null&quot;, O_RDONLY);    open(&quot;/dev/null&quot;, O_RDWR);    open(&quot;/dev/null&quot;, O_RDWR);    //原代码有这句，就是往syslog里写运行本程序的日志，加上进程id，输出等级为facilit(LOG_WARN这样子)    //openlog(pname, LOG_PID, facility);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在看《UNIX网络编程》的时候，看到了守护进程的创建，代码中fork了两次，并且第一次fork后对子进程调用setsid()，有些懵。当时搜了下setsid也是看得有点云里雾里。后来折腾了一下午，才算有点明白，这里把自己的一点分析心得写上来，以后忘了可以翻翻：&lt;/p&gt;

      
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>编译60个小程序之makefile</title>
    <link href="http://yoursite.com/2018/06/14/003makefile/index/"/>
    <id>http://yoursite.com/2018/06/14/003makefile/index/</id>
    <published>2018-06-14T07:39:08.000Z</published>
    <updated>2018-06-14T07:42:09.756Z</updated>
    
    <content type="html"><![CDATA[<p>公司有个任务需要编译60个c语言小程序，工程目录结构为：</p><p>src：放所有小程序源文件.c</p><p>drv：所有小程序编译后都为对应.drv</p><p>其它头文件、库目录省略。</p><p>makefile不太熟，也很菜，我第一想法是用for循环进行循环编译，还用到了makefile自定义函数，贴代码：</p><pre><code>CC = arm-linux-gccCFLAGS +=-Wall -O -D_REENTRANT -fpic -sharedLDFLAGS += -L./lib -lutility -lcrc -lmxml -lserial -lsocket -lpthreadROOT_DIR = $(shell pwd)SRC_DIR = ./srcDRV_DIR = ./drv#src/*.cSRC := $(wildcard ${SRC_DIR}/*.c)SRC1 := $(notdir $(SRC))ALL_NAME := $(basename ${SRC1})#自定义了一个compile_file函数define compile_file        $(CC) $(CFLAGS) -o $1 $2 $(LDFLAGS)endefdefault:        for name in $(ALL_NAME); do \#这里调用自定义函数，传输两个参数:一个drv/xx.drv，一个src/xx.c        ${call compile_file, $(DRV_DIR)/$$name.drv, $(SRC_DIR)/$$name.c}; doneclean:        rm -f $(DRV_DIR)/*.drv</code></pre><p>编译的效果是将所有的小程序都编译一遍，不管有没有出错，不管是否为最新。我需要的效果是编译所有程序，编译到哪一个出错即停止，编译前还要检查目标文件和源文件的更新时间，因此这个makefile不好用，只是学习了一下makefile的循环和自定义函数。</p><p>然后又构思makefile该如何写，就在思考的过程中想起来了学裸机程序时工程有一个.S和一个.c文件的编译，再结合makefile的伪目标，结构就很清晰了，这里用一个变量ALL_NAME表示获取到的所有src目录下的.c文件的名字替换为.drv（去除src/目录名和.c后缀，再补上drv/和.drv后缀，形式为drv/xxx.drv），代码忘了拷，贴部分自己能记住的吧：</p><pre><code>.PHONY:default cleandefault:$(ALL_NAME)$(DRV_DIR)/%.drv:$(SRC_DIR)/%.c    $(CC) $(CFLAGS) -o $@ $&lt; $(LDFLAGS)clean:    rm $(DRV_DIR)/*.drv -r</code></pre><p>这个makefile就能满足之前的要求了。通过两个makefile的编写，学习了makefile的函数、自定义函数、循环、伪目标、makefile规则与shell规则的混合问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;公司有个任务需要编译60个c语言小程序，工程目录结构为：&lt;/p&gt;
&lt;p&gt;src：放所有小程序源文件.c&lt;/p&gt;
&lt;p&gt;drv：所有小程序编译后都为对应.drv&lt;/p&gt;
&lt;p&gt;其它头文件、库目录省略。&lt;/p&gt;
&lt;p&gt;makefile不太熟，也很菜，我第一想法是用for循环进行
      
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>v4l2capture</title>
    <link href="http://yoursite.com/2018/06/13/002v4l2capture/index/"/>
    <id>http://yoursite.com/2018/06/13/002v4l2capture/index/</id>
    <published>2018-06-14T01:38:53.000Z</published>
    <updated>2018-06-14T02:34:33.267Z</updated>
    
    <content type="html"><![CDATA[<p>虽然网上很多了，还是贴一下吧，自己刚入门的时候也是找苦逼很久找代码，代码我也是总结的。</p><h1 id="1-v4l2-c"><a href="#1-v4l2-c" class="headerlink" title="1.v4l2.c"></a>1.v4l2.c</h1><pre><code>void get_cam_info(struct camera *cam){    if(ioctl(cam-&gt;fd, VIDIOC_QUERYCAP, &amp;cam-&gt;cap) &lt; 0)    {        perror(&quot;query camera information error.\n&quot;);        exit(0);    }    if(!(cam-&gt;cap.capabilities &amp; V4L2_CAP_VIDEO_CAPTURE))    {        printf(&quot;device is not a capture device.\n&quot;);        exit(0);    }    printf(&quot;\nCapability Informations:\n&quot;);    printf(&quot;Driver Name:%s\nCard Name:%s\nBus info:%s\nDriver Version:%u.%u.%u\nCapabilities: %d\n&quot;,           cam-&gt;cap.driver,cam-&gt;cap.card,cam-&gt;cap.bus_info,           (cam-&gt;cap.version&gt;&gt;16)&amp;0XFF, (cam-&gt;cap.version&gt;&gt;8)&amp;0XFF,cam-&gt;cap.version&amp;0XFF,           cam-&gt;cap.capabilities );}void get_cam_fmtdesc(struct camera *cam){    cam-&gt;fmtdesc.index  = 0;    cam-&gt;fmtdesc.type   = V4L2_BUF_TYPE_VIDEO_CAPTURE;    while ((ioctl(cam-&gt;fd, VIDIOC_ENUM_FMT, &amp;cam-&gt;fmtdesc)) == 0)    {        printf(&quot;\t%d.\n\t{\n\tpixelformat = &apos;%c%c%c%c&apos;,\n\tdescription = &apos;%s&apos;\n \t}\n&quot;,                cam-&gt;fmtdesc.index+1,                cam-&gt;fmtdesc.pixelformat &amp; 0xFF,               (cam-&gt;fmtdesc.pixelformat &gt;&gt; 8) &amp; 0xFF,               (cam-&gt;fmtdesc.pixelformat &gt;&gt; 16) &amp; 0xFF,               (cam-&gt;fmtdesc.pixelformat &gt;&gt; 24) &amp; 0xFF,                cam-&gt;fmtdesc.description);                cam-&gt;fmtdesc.index++;    }}void set_cap_format(struct camera *cam){    memset(&amp;cam-&gt;format, 0, sizeof(cam-&gt;format));    cam-&gt;format.fmt.pix.width       = cam-&gt;width;    cam-&gt;format.fmt.pix.height      = cam-&gt;height;    cam-&gt;format.fmt.pix.pixelformat = cam-&gt;cap_format;    //cam-&gt;format.fmt.pix.field       = V4L2_FIELD_INTERLACED;    cam-&gt;format.fmt.pix.field       = V4L2_FIELD_ANY;    cam-&gt;format.type                = V4L2_BUF_TYPE_VIDEO_CAPTURE;    if(ioctl(cam-&gt;fd, VIDIOC_S_FMT, &amp;cam-&gt;format) &lt; 0)    {        perror(&quot;set capture format error.\n&quot;);        exit(0);    }}void get_cap_format(struct camera *cam){    struct v4l2_format fmt;    struct v4l2_fmtdesc fmtdesc;    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;    if(ioctl(cam-&gt;fd, VIDIOC_G_FMT, &amp;fmt) &lt; 0)    {        perror(&quot;get_cap_format:error.\n&quot;);        exit(0);    }    printf(&quot;\nCurrent data format information:\n width:%d\n height:%d\n&quot;,           fmt.fmt.pix.width,fmt.fmt.pix.height);    fmtdesc.index       = 0;    fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;    while(ioctl(cam-&gt;fd, VIDIOC_ENUM_FMT, &amp;fmtdesc) != -1)    {        if(fmtdesc.pixelformat == cam-&gt;format.fmt.pix.pixelformat)        {            printf(&quot; format:%s\n&quot;,fmtdesc.description);            break;        }        fmtdesc.index ++;    }}void get_framerate(struct camera *cam){    int ret;    memset(&amp;cam-&gt;setfps, 0, sizeof(struct v4l2_streamparm));    cam-&gt;setfps.type = V4L2_BUF_TYPE_VIDEO_CAPTURE ;    cam-&gt;setfps.parm.capture.capability = V4L2_CAP_TIMEPERFRAME;    ret = ioctl(cam-&gt;fd, VIDIOC_G_PARM, &amp;cam-&gt;setfps);    if(ret &lt; 0)    {        perror(&quot;get fps error.\n&quot;);    }    printf(&quot; fps:%d\n&quot;,cam-&gt;setfps.parm.capture.timeperframe.denominator);}void set_framerate(struct camera *cam){    int ret ;    memset(&amp;cam-&gt;setfps, 0, sizeof(struct v4l2_streamparm));    cam-&gt;setfps.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;    cam-&gt;setfps.parm.capture.timeperframe.numerator = 1;    cam-&gt;setfps.parm.capture.timeperframe.denominator = 25;    ret = ioctl(cam-&gt;fd, VIDIOC_S_PARM, &amp;cam-&gt;setfps);    if(ret &lt; 0)    {        perror(&quot;set fps error.\n&quot;);    }}void req_buffer(struct camera *cam){    memset(&amp;cam-&gt;reqbuf, 0, sizeof(cam-&gt;reqbuf));    cam-&gt;reqbuf.count   = cam-&gt;buf_num;    cam-&gt;reqbuf.type    = V4L2_BUF_TYPE_VIDEO_CAPTURE;    cam-&gt;reqbuf.memory  = V4L2_MEMORY_MMAP;    if(ioctl(cam-&gt;fd, VIDIOC_REQBUFS, &amp;cam-&gt;reqbuf) &lt; 0)    {        perror(&quot;reqbuf error.\n&quot;);        exit(0);    }}void init_mmap(struct camera *cam){    unsigned int i;    for(i=0; i&lt;cam-&gt;buf_num; i++)    {        //memset(&amp;cam-&gt;buf, 0, sizeof(cam-&gt;buf));        cam-&gt;buf.type   = V4L2_BUF_TYPE_VIDEO_CAPTURE;        cam-&gt;buf.memory = V4L2_MEMORY_MMAP;        cam-&gt;buf.index  = i;        if(-1 == ioctl(cam-&gt;fd, VIDIOC_QUERYBUF, &amp;cam-&gt;buf))        {            perror(&quot;ioctl querybuf error.\n&quot;);            exit(0);        }        cam-&gt;buffers[i].length = cam-&gt;buf.length;        cam-&gt;buffers[i].start = (unsigned char *)mmap(NULL,                                cam-&gt;buf.length,                                PROT_READ | PROT_WRITE,                                MAP_SHARED,                                cam-&gt;fd,                                cam-&gt;buf.m.offset);        if(MAP_FAILED == cam-&gt;buffers[i].start)        {            perror(&quot;mmap error.\n&quot;);            exit(0);        }    }}void start_capture(struct camera *cam){    unsigned int i;    for(i=0; i&lt;cam-&gt;buf_num; i++)    {        //memset(&amp;cam-&gt;buf, 0, sizeof(cam-&gt;buf));        cam-&gt;buf.type       = V4L2_BUF_TYPE_VIDEO_CAPTURE;        cam-&gt;buf.memory     = V4L2_MEMORY_MMAP;        cam-&gt;buf.index      = i;        if(-1 == ioctl(cam-&gt;fd, VIDIOC_QBUF, &amp;cam-&gt;buf))        {            perror(&quot;start capture:video ioctl qbuf error.\n&quot;);            exit(0);        }    }    if(-1 == ioctl(cam-&gt;fd, VIDIOC_STREAMON, &amp;cam-&gt;buf.type))    {        perror(&quot;start capture:video ioctl streamon error.\n&quot;);        exit(0);    }}int isHaveData(int fd){    fd_set fds;    struct timeval tv;    int r;    FD_ZERO (&amp;fds);//将指定的文件描述符集清空    FD_SET (fd, &amp;fds);//在文件描述符集合中增加一个新的文件描述符    tv.tv_sec = 2;    tv.tv_usec = 0;    for (;;) //这一段涉及到异步IO    {        r = select (fd + 1, &amp;fds, NULL, NULL, &amp;tv);//判断是否可读（即摄像头是否准备好），tv是定时        if (-1 == r)        {            if (EINTR == errno)            {                printf(&quot;select err\n&quot;);                continue;            }        }        if (0 == r)        {            fprintf (stderr, &quot;select timeout：%d\n&quot;,errno);            return 0;        }        return 1;    }}int get_one_frame_buf(struct camera * cam){    int index ;    if(isHaveData(cam-&gt;fd))    {        memset(&amp;cam-&gt;buf, 0, sizeof(cam-&gt;buf));        cam-&gt;buf.type       = V4L2_BUF_TYPE_VIDEO_CAPTURE;        cam-&gt;buf.memory     = V4L2_MEMORY_MMAP;        if(ioctl(cam-&gt;fd, VIDIOC_DQBUF, &amp;cam-&gt;buf) &lt; 0)        {            perror(&quot;get one frame buffer:video ioctl dqbuf error.\n&quot;);            exit(0);        }        assert(cam-&gt;buf.index &lt; cam-&gt;buf_num);        index = cam-&gt;buf.index;        //starter = (unsigned char *)buffers[cam-&gt;buf.index].start;        if(ioctl(cam-&gt;fd, VIDIOC_QBUF, &amp;cam-&gt;buf) &lt; 0)        {            perror(&quot;get one frame buffer:video ioctl qbuf error.\n&quot;);            exit(0);        }        return index;    }    else    {        printf(&quot;get one frame buffer error.\n&quot;);        exit(0);    }}void stop_capture(struct camera *cam){    if(-1 == ioctl(cam-&gt;fd,VIDIOC_STREAMOFF,&amp;cam-&gt;fmtdesc.type))    {        perror(&quot;stop capture error.\n&quot;);        exit(0);    }    close(cam-&gt;fd);    printf(&quot;stop capture successfully!\n&quot;);}void Munmap(int req_num, struct mmap_buffer *buffers){    unsigned int i;    for (i = 0; i &lt; req_num; ++i)        if (-1 == munmap(buffers[i].start, buffers[i].length))            free (buffers);}</code></pre><h1 id="2-v4l2-h"><a href="#2-v4l2-h" class="headerlink" title="2.v4l2.h"></a>2.v4l2.h</h1><p>这里的h4all.h包含的库函数,动手man一下吧 :-D</p><pre><code>#ifndef _V4L2_UVC_H#define _V4L2_UVC_H#include &quot;h4all.h&quot;struct mmap_buffer{    void *start;    size_t length;};typedef struct camera{    int fd; //摄像头文件描述符    int width;    int height;    int cap_format;    int buf_num;    struct v4l2_capability      cap;    struct v4l2_fmtdesc         fmtdesc;    struct v4l2_format          format;    struct v4l2_streamparm      setfps;    struct v4l2_requestbuffers  reqbuf;    struct v4l2_buffer          buf;    struct mmap_buffer          buffers[4];}Camera;void get_cam_info(struct camera *cam);void get_cam_fmtdesc(struct camera *cam);void set_cap_format(struct camera *cam);void get_cap_format(struct camera *cam);void get_framerate(struct camera *cam);void set_framerate(struct camera *cam);void req_buffer(struct camera *cam);void init_mmap(struct camera *cam);void start_capture(struct camera *cam);int get_one_frame_buf(struct camera * cam);void stop_capture(struct camera *cam);void Munmap(int req_num, struct mmap_buffer *buffers);void Init_v4l2(struct camera *cam);#endif</code></pre><h1 id="3-初始化：main-c"><a href="#3-初始化：main-c" class="headerlink" title="3.初始化：main.c"></a>3.初始化：main.c</h1><pre><code>#define DRIVER      &quot;/dev/video2&quot;#define WIDTH       176#define HEIGHT      144#define CAP_FORMAT  V4L2_PIX_FMT_YUYV#define REQ_BUFFER  4Camera *cam;struct mmap_buffer buffers[REQ_BUFFER];cam = (Camera *)malloc(sizeof(Camera));void set_cam(Camera *cam, const char *driver_path,    int width, int height, int format, int req_num){    cam-&gt;fd         = Open(driver_path);    cam-&gt;width      = width;    cam-&gt;height     = height;    cam-&gt;cap_format = format;    cam-&gt;buf_num    = req_num;}</code></pre><h1 id="4-获得数据"><a href="#4-获得数据" class="headerlink" title="4.获得数据"></a>4.获得数据</h1><p>调用v4l2_uvc.c的get_one_frame_buf(cam),用int型的index接收返回值，即是目前获得的底几个缓冲区的索引值，cam-&gt;buffers[index].start即是指向那段数据内存，cam-&gt;buffers[index].length即是大小</p><p><em>注：</em><br><em>当然，还有什么设置伽马值、曝光度这些套路跟上面差不多，可以百度一下，作为函数补充进去</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虽然网上很多了，还是贴一下吧，自己刚入门的时候也是找苦逼很久找代码，代码我也是总结的。&lt;/p&gt;
&lt;h1 id=&quot;1-v4l2-c&quot;&gt;&lt;a href=&quot;#1-v4l2-c&quot; class=&quot;headerlink&quot; title=&quot;1.v4l2.c&quot;&gt;&lt;/a&gt;1.v4l2.c&lt;/h
      
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="摄像头" scheme="http://yoursite.com/tags/%E6%91%84%E5%83%8F%E5%A4%B4/"/>
    
  </entry>
  
  <entry>
    <title>yuv422转换为yuv420p</title>
    <link href="http://yoursite.com/2018/06/12/001yuv422toyuv420p/index/"/>
    <id>http://yoursite.com/2018/06/12/001yuv422toyuv420p/index/</id>
    <published>2018-06-13T02:25:24.000Z</published>
    <updated>2018-06-14T02:34:33.271Z</updated>
    
    <content type="html"><![CDATA[<p>今天遇到一个问题，我的摄像头采集到的数据是yuyv格式(属于yuv422)，而X264在进行编码的时候需要标准的YUV（4：2：0）。所以有一个yuv422toyuv420的转换。在网上找了半天找到的方法拿过来转换了查看都很花。于是自己看了一下yuv格式的解释，准备写一个转换代码。以下许多解释都是按我的理解：</p><h1 id="1-yuv"><a href="#1-yuv" class="headerlink" title="1.yuv"></a>1.yuv</h1><p>yuv格式通常有两大类：打包(packed)和平面(planar)格式。前者在码流里是yuv挨一起，比如我的yuyv就是 Y0 U0 Y1 V1 Y2 U2 …. 每一个 Y对应一组UV分量。后者存储y u v分量是分开存储的，这种方式一般后面带P， 比如y uv420p就是Y0 Y1 Y2 … U0 U1 U2 … V0 V1 V2 … uv分量的多少根据格式来，yuv420也就是每四个 Y共用一组UV分量。</p><h1 id="2-转换"><a href="#2-转换" class="headerlink" title="2.转换"></a>2.转换</h1><p>理解了yuyv即yuv422与yuv420p中分量的排布，就要进行转换了。网上查到的资料说yuv422-&gt;yuv420p时 丢弃偶数行的uv分量。</p><h1 id="3-编码"><a href="#3-编码" class="headerlink" title="3.编码"></a>3.编码</h1><pre><code>定义：unsignedchar *y = out;unsignedchar *u = out + width*height;unsigned char*v = out + width*height + width*height/4;</code></pre><p>y u v分别指向yuv420buf中存储y u v分量的数组，这里out的类型为char型数组，按yuv420p的定义，4个y共用一对uv，那么一个y对应1/4个uv，一个分量占一个byte，out的大小为：总共的y分量(width<em>height) + 总共的u分量(width</em>height/4) + 总共的v分量(width<em>height/4) = width</em>height*3/2。通过上面的转换也可以得到yuyv(yuv422)一个像素占用2个字节，yuv420p一个像素占1.5个字节，rgb24的话占用3个字节，还是节约了一点点空间的。。。</p><pre><code>获取y分量并存储到yuv420buf中：         for(i=0; i&lt;yuv422_length; i+=2){               *(y+y_index) = *(in+i);               y_index++;         }这里的yuv422_length为width*height*2;y_index初始为0，存储一个y就自加一次。获取uv分量并存储到yuv420buf中：         for(i=0; i&lt;height; i+=2){               base_h = i*width*2;               for(j=base_h+1;j&lt;base_h+width*2; j+=2){                        if(is_u){                                 *(u+u_index)= *(in+j);                                 u_index++;                                 is_u = 0;                        }                        else{                                 *(v+v_index)= *(in+j);                                 v_index++;                                 is_u = 1;                        }               }          }</code></pre><p><em>总结：初入视频图像，我还是一个菜鸟，对于很多理解也不深，这个代码应该还有很多没考虑，对于我可用了。当然以上都是废话，直接贴代码</em></p><pre><code>int yuv422toyuv420(unsigned char *out, const unsigned char *in, unsigned int width, unsigned int height)    {    unsigned char *y = out;    unsigned char *u = out + width*height;    unsigned char *v = out + width*height + width*height/4;    unsigned int i,j;    unsigned int base_h;    unsigned int is_y = 1, is_u = 1;    unsigned int y_index = 0, u_index = 0, v_index = 0;    unsigned long yuv422_length = 2 * width * height;    //序列为YU YV YU YV，一个yuv422帧的长度 width * height * 2 个字节    //丢弃偶数行 u v    for(i=0; i&lt;yuv422_length; i+=2){        *(y+y_index) = *(in+i);        y_index++;    }    for(i=0; i&lt;height; i+=2){        base_h = i*width*2;        for(j=base_h+1; j&lt;base_h+width*2; j+=2){            if(is_u){                *(u+u_index) = *(in+j);                u_index++;                is_u = 0;            }            else{                *(v+v_index) = *(in+j);                v_index++;                is_u = 1;            }        }    }    return 1;    }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天遇到一个问题，我的摄像头采集到的数据是yuyv格式(属于yuv422)，而X264在进行编码的时候需要标准的YUV（4：2：0）。所以有一个yuv422toyuv420的转换。在网上找了半天找到的方法拿过来转换了查看都很花。于是自己看了一下yuv格式的解释，准备写一个转
      
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="摄像头" scheme="http://yoursite.com/tags/%E6%91%84%E5%83%8F%E5%A4%B4/"/>
    
  </entry>
  
</feed>
