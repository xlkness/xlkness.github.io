<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>My Blog</title>
  
  <subtitle>我的小站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lkness/"/>
  <updated>2018-06-20T12:18:22.090Z</updated>
  <id>http://lkness/</id>
  
  <author>
    <name>lkness</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>erlang底层c定时器设计-Erlang源码学习二</title>
    <link href="http://lkness/2018/06/20/030erlang-timer/index/"/>
    <id>http://lkness/2018/06/20/030erlang-timer/index/</id>
    <published>2018-06-20T12:09:25.000Z</published>
    <updated>2018-06-20T12:18:22.090Z</updated>
    
    <content type="html"><![CDATA[<p>Erlang底层的定时器实现位于源码的erts/emulator/beam/time.c文件，用时间轮的方式动态添加和删除定时器，结构体名为<code>typedef struct ErtsTimerWheel_ ErtsTimerWheel</code>，每一个定时器的结构体名为<code>typedef struct erl_timer ErtsTWheelTimer</code>，看结构体实现大体上可以知道定时器的设计。</p><h1 id="定时器-ErtsTWheelTimer"><a href="#定时器-ErtsTWheelTimer" class="headerlink" title="定时器 ErtsTWheelTimer"></a>定时器 ErtsTWheelTimer</h1><pre><code>typedef struct erl_timer {    struct erl_timer* next; /* next entry tiw slot or chain */    struct erl_timer* prev; /* prev entry tiw slot or chain */    union {    struct {        void (*timeout)(void*); /* called when timeout */        void (*cancel)(void*);  /* called when cancel (may be NULL) */        void* arg;              /* argument to timeout/cancel procs */    } func;    ErtsThrPrgrLaterOp cleanup;    } u;    ErtsMonotonicTime timeout_pos; /* Timeout in absolute clock ticks */    int slot;} ErtsTWheelTimer;</code></pre><p>每个定时器维护了前后向指针，有定时器到时作为回调的函数、取消定时器所调用的函数（可能做参数销毁用）和函数参数，还有定时器的到时点，以及此定时器位于时间轮的槽。</p><h1 id="时间轮-ErtsTimerWheel"><a href="#时间轮-ErtsTimerWheel" class="headerlink" title="时间轮 ErtsTimerWheel"></a>时间轮 ErtsTimerWheel</h1><pre><code>struct ErtsTimerWheel_ {    ErtsTWheelTimer *w[ERTS_TIW_SIZE];    ErtsMonotonicTime pos;    Uint nto;    struct {    ErtsTWheelTimer *head;    ErtsTWheelTimer *tail;    Uint nto;    } at_once;    int yield_slot;    int yield_slots_left;    int yield_start_pos;    ErtsTWheelTimer sentinel;    int true_next_timeout_time;    ErtsMonotonicTime next_timeout_time;};</code></pre><p>时间轮维护了一个ERTS_TIW_SIZE大小的定时器指针数组，看头文件定义可以得到ERTS_TIW_SIZE在小内存机器上是 1&lt;&lt;13的大小，大内存机器为1&lt;&lt;16=2^16=2^6*1024=65535大小，这里只看大内存机器；接着有一个pos字段，类型为ErtsMonotonicTime，这是一个long long的别名，顾名思义就是erlang的monotonic时间，简单说就是一个精确到纳秒的单调递增时间；接着有一个at_once空间，有头head、尾tail指针，至于数据结构可能为链表，可能为数组实现的栈或队列等；然后的字段光看名字也无法推断了。进入时间轮操作函数。</p><p>#</p><p>time.c的函数只有几个，先罗列简单的:</p><pre><code>ErtsTimerWheel *erts_create_timer_wheel(ErtsSchedulerData *esdp){    ErtsMonotonicTime mtime;    int i;    ErtsTimerWheel *tiw;    tiw = erts_alloc_permanent_cache_aligned(ERTS_ALC_T_TIMER_WHEEL,                         sizeof(ErtsTimerWheel));    for(i = 0; i &lt; ERTS_TIW_SIZE; i++)    tiw-&gt;w[i] = NULL;    mtime = erts_get_monotonic_time(esdp);    tiw-&gt;pos = ERTS_MONOTONIC_TO_CLKTCKS(mtime);    tiw-&gt;nto = 0;    tiw-&gt;at_once.head = NULL;    tiw-&gt;at_once.tail = NULL;    tiw-&gt;at_once.nto = 0;    tiw-&gt;yield_slot = ERTS_TWHEEL_SLOT_INACTIVE;    tiw-&gt;true_next_timeout_time = 0;    tiw-&gt;next_timeout_time = mtime + ERTS_MONOTONIC_DAY;    tiw-&gt;sentinel.next = &amp;tiw-&gt;sentinel;    tiw-&gt;sentinel.prev = &amp;tiw-&gt;sentinel;    tiw-&gt;sentinel.u.func.timeout = NULL;    tiw-&gt;sentinel.u.func.cancel = NULL;    tiw-&gt;sentinel.u.func.arg = NULL;    return tiw;}</code></pre><p>看操作是先分配内存，然后初始化w定时器指针数组为NULL，接着获取一次当前的monotonic时间，将它转换为时间轮滴答后赋给pos字段，monotonic时间是精确到纳秒，宏ERTS_MONOTONIC_TO_CLKTCKS将它除以了1000*1000，从这里我们可以知道时间轮每一次走动是1ms，即时间轮的粒度就是1ms了，接下来的操作就是常规的初始化了，到tiw-&gt;sentinel.next = $tiw-&gt;sentinel语句开始，是将一个sentinel（哨兵）变量变为一个指向自己的循环双向链表。</p><p><strong>结论：</strong></p><p>时间轮的pos字段初始值为创建时间轮时的monotonic时间，但时间轮的精度为ms，故需要将monotonic时间转换为ms（除以1000*1000），pos字段为时间轮的当前指针（想象成钟的分针）。</p><h1 id="插入定时器-insert-timer-into-slot"><a href="#插入定时器-insert-timer-into-slot" class="headerlink" title="插入定时器 insert_timer_into_slot"></a>插入定时器 insert_timer_into_slot</h1><pre><code>static ERTS_INLINE voidinsert_timer_into_slot(ErtsTimerWheel *tiw, int slot, ErtsTWheelTimer *p){    ERTS_TW_ASSERT(slot &gt;= 0);    ERTS_TW_ASSERT(slot &lt; ERTS_TIW_SIZE);    p-&gt;slot = slot;    if (!tiw-&gt;w[slot]) {    tiw-&gt;w[slot] = p;    p-&gt;next = p;    p-&gt;prev = p;    }    else {    ErtsTWheelTimer *next, *prev;    next = tiw-&gt;w[slot];    prev = next-&gt;prev;    p-&gt;next = next;    p-&gt;prev = prev;    prev-&gt;next = p;    next-&gt;prev = p;    }}</code></pre><p>先看插入的第1、2两句，断言slot要介于0-ERTS_TIW_SIZE之间：定时器要插到时间轮的槽上，因此必须介于这个范围。然后开始插入，先判断待插入的槽有没有定时器，如果没有，就直接将w[slot]指针指向这个定时器，并且赋值next、prev指针保证循环双向链表特性；如果槽上已经有了别的定时器，那么看else的操作是将待插入的定时器头插到链表中。</p><p>于是看完这个函数，知道了时间轮的主要逻辑如图：</p><p><img src="/img/erlang_timer1.png" alt="erlang_timer1"></p><p><strong>结论：</strong></p><p>时间轮的槽大小为65535；每个槽是一个定时器指针，指针又维护了一个定时器双向循环链表，跟链式散列表很像；定时器是头插。</p><h1 id="去除定时器-remove-timer"><a href="#去除定时器-remove-timer" class="headerlink" title="去除定时器 remove_timer"></a>去除定时器 remove_timer</h1><pre><code>static ERTS_INLINE voidremove_timer(ErtsTimerWheel *tiw, ErtsTWheelTimer *p){    int slot = p-&gt;slot;    ERTS_TW_ASSERT(slot != ERTS_TWHEEL_SLOT_INACTIVE);    if (slot &gt;= 0) {        /*         * Timer in wheel or in circular         * list of timers currently beeing         * triggered (referred by sentinel).         */        ERTS_TW_ASSERT(slot &lt; ERTS_TIW_SIZE);        if (p-&gt;next == p) {            ERTS_TW_ASSERT(tiw-&gt;w[slot] == p);            tiw-&gt;w[slot] = NULL;        }        else {            if (tiw-&gt;w[slot] == p)            tiw-&gt;w[slot] = p-&gt;next;            p-&gt;prev-&gt;next = p-&gt;next;            p-&gt;next-&gt;prev = p-&gt;prev;        }    }    else {        /* Timer in &quot;at once&quot; queue... */        ERTS_TW_ASSERT(slot == ERTS_TWHEEL_SLOT_AT_ONCE);        if (p-&gt;prev)            p-&gt;prev-&gt;next = p-&gt;next;        else {            ERTS_TW_ASSERT(tiw-&gt;at_once.head == p);            tiw-&gt;at_once.head = p-&gt;next;        }        if (p-&gt;next)            p-&gt;next-&gt;prev = p-&gt;prev;        else {            ERTS_TW_ASSERT(tiw-&gt;at_once.tail == p);            tiw-&gt;at_once.tail = p-&gt;prev;        }        ERTS_TW_ASSERT(tiw-&gt;at_once.nto &gt; 0);        tiw-&gt;at_once.nto--;    }    p-&gt;slot = ERTS_TWHEEL_SLOT_INACTIVE;    tiw-&gt;nto--;}</code></pre><p>先看第一个断言slot != ERTS_TWHEEL_SLOT_INACTIVE，这个宏值为-2，前面的函数知道槽数一定是介于0-65535之间，所以猜测如果槽数为-2了，表示定时器未激活。</p><p>往后看，如果槽存在，又分两种情况，一种是这个定时器所处的槽只有它一个定时器，那么需要将槽指针w[slot]置为空，另一种是槽上还有很多定时器，则从循环双向链表中取下一个结点。<br>如果槽不存在，且看else的slot为宏值ERTS_TWHEEL_SLOT_AT_ONCE，那么就从at_once队列中去除定时器，并且nto字段减1。</p><p>将定时器的slot字段置为ERTS_TWHEEL_SLOT_INACTIVE，时间轮的nto字段减1。</p><p><strong>结论：</strong></p><p>定时器有三种状态分别为正常、at_once、未激活；at_once队列实则为不循环双向链表；at_once的nto字段记录这个队列上的定时器个数；tiw的nto字段记录所有定时器包括at_once队列上的定时器个数。</p><h1 id="定时器到时回调-timeout-timer"><a href="#定时器到时回调-timeout-timer" class="headerlink" title="定时器到时回调 timeout_timer"></a>定时器到时回调 timeout_timer</h1><p>回调就很简单，将定时器的slot字段设置为未激活，然后调用回调函数</p><h1 id="取消定时器-erts-twheel-cancel-timer"><a href="#取消定时器-erts-twheel-cancel-timer" class="headerlink" title="取消定时器 erts_twheel_cancel_timer"></a>取消定时器 erts_twheel_cancel_timer</h1><p>逻辑与4的到时回调差不多，判断了定时器的slot不能为未激活状态，然后调用remove去除定时器，接着调用定时器的cancel回调函数</p><h1 id="创建定时器-erts-twheel-set-timer"><a href="#创建定时器-erts-twheel-set-timer" class="headerlink" title="创建定时器 erts_twheel_set_timer"></a>创建定时器 erts_twheel_set_timer</h1><pre><code>voiderts_twheel_set_timer(ErtsTimerWheel *tiw,              ErtsTWheelTimer *p, ErlTimeoutProc timeout,              ErlCancelProc cancel, void *arg,              ErtsMonotonicTime timeout_pos){    ErtsMonotonicTime timeout_time;    ERTS_MSACC_PUSH_AND_SET_STATE_M_X(ERTS_MSACC_STATE_TIMERS);    p-&gt;u.func.timeout = timeout;    p-&gt;u.func.cancel = cancel;    p-&gt;u.func.arg = arg;    ERTS_TW_ASSERT(p-&gt;slot == ERTS_TWHEEL_SLOT_INACTIVE);    if (timeout_pos &lt;= tiw-&gt;pos) {    tiw-&gt;nto++;    tiw-&gt;at_once.nto++;    p-&gt;next = NULL;    p-&gt;prev = tiw-&gt;at_once.tail;    if (tiw-&gt;at_once.tail) {        ERTS_TW_ASSERT(tiw-&gt;at_once.head);        tiw-&gt;at_once.tail-&gt;next = p;    }    else {        ERTS_TW_ASSERT(!tiw-&gt;at_once.head);        tiw-&gt;at_once.head = p;    }    tiw-&gt;at_once.tail = p;    p-&gt;timeout_pos = tiw-&gt;pos;    p-&gt;slot = ERTS_TWHEEL_SLOT_AT_ONCE;    timeout_time = ERTS_CLKTCKS_TO_MONOTONIC(tiw-&gt;pos);    }    else {    int slot;    /* calculate slot */    slot = (int) (timeout_pos &amp; (ERTS_TIW_SIZE-1));    insert_timer_into_slot(tiw, slot, p);    tiw-&gt;nto++;    timeout_time = ERTS_CLKTCKS_TO_MONOTONIC(timeout_pos);    p-&gt;timeout_pos = timeout_pos;    }    if (timeout_time &lt; tiw-&gt;next_timeout_time) {    tiw-&gt;true_next_timeout_time = 1;    tiw-&gt;next_timeout_time = timeout_time;    }    ERTS_MSACC_POP_STATE_M_X();}</code></pre><p>逻辑很清楚：传入一个时间轮、定时器、以及定时器要用的相关函数、时间轮上的超时位置（monotonic time / 1000*1000）。</p><p>然后判断超时位置是否小于等于时间轮当前的指针pos，如果是，就把它加入到at_once链表，pos的精度为ms，这个at_once的意思就是加入的定时器差1ms就要到时，而针对这种定时器，再把它插入到槽里做管理和到时是没有意义的，因为马上就到时了。</p><p>正常的定时器则可以插入到槽里了，槽的计算是用到时位置与槽总大小做与运算，举个例子：当前monotonic时间为10,000,000,000，表示开始或者erlang虚拟机开启了10s， 此时创建了一个时间轮，它的pos就该为10,000，然后插入一个5,000,000,000纳秒后到时的定时器，因为时间轮精度为ms，顾折算为(10,000,000,000 + 5,000,000,000)/1000*1000=15,000，即timeout_pos就为15000，那么timeout_pos &amp; ERTS_TIW_SIZE = 15000，那么槽就是15000位置，此时槽还在10000位置，要走5000个滴答才到，同理，如果插入一个距现在65536ms后到时的定时器，则65536超出了65535，但与运算，又变为了0，实现了定时器的循环相加。</p><p>相应nto计数加一，然后判断加入的定时器的到时时间是否小于等于时间轮的下一次到时时间，如果是，就更新时间轮的相应到时值。</p><p><strong>总结：</strong></p><p>定时器如果马上（差1ms）到时的，会加入到at_once队列，否则加入到时间槽里做管理；定时器的到时时间为一个精度为ms的值，然后用这个值跟ERTS_TIW_SIZE做与运算，保证了槽的循环；时间轮还有字段用来表示下一次最近的到时时间，true_next_timeout_time为1表示存在这个时间（即槽上至少存在一个激活的定时器还没到时）。</p><h1 id="寻找下一个最近到时时间-find-next-timeout"><a href="#寻找下一个最近到时时间-find-next-timeout" class="headerlink" title="寻找下一个最近到时时间 find_next_timeout"></a>寻找下一个最近到时时间 find_next_timeout</h1><pre><code>static ERTS_INLINE ErtsMonotonicTimefind_next_timeout(ErtsSchedulerData *esdp,          ErtsTimerWheel *tiw,          int search_all,          ErtsMonotonicTime curr_time,       /* When !search_all */          ErtsMonotonicTime max_search_time) /* When !search_all */{    int start_ix, tiw_pos_ix;    ErtsTWheelTimer *p;    int true_min_timeout = 0;    ErtsMonotonicTime min_timeout, min_timeout_pos, slot_timeout_pos;    if (tiw-&gt;nto == 0) { /* no timeouts in wheel */        if (!search_all)            min_timeout_pos = tiw-&gt;pos;        else {            curr_time = erts_get_monotonic_time(esdp);            tiw-&gt;pos = min_timeout_pos = ERTS_MONOTONIC_TO_CLKTCKS(curr_time);        }        min_timeout_pos += ERTS_MONOTONIC_TO_CLKTCKS(ERTS_MONOTONIC_DAY);        goto found_next;    }    slot_timeout_pos = min_timeout_pos = tiw-&gt;pos;    if (search_all)       min_timeout_pos += ERTS_MONOTONIC_TO_CLKTCKS(ERTS_MONOTONIC_DAY);    else       min_timeout_pos = ERTS_MONOTONIC_TO_CLKTCKS(curr_time + max_search_time);    start_ix = tiw_pos_ix = (int) (tiw-&gt;pos &amp; (ERTS_TIW_SIZE-1));    do {        if (++slot_timeout_pos &gt;= min_timeout_pos)            break;        p = tiw-&gt;w[tiw_pos_ix];        if (p) {            ErtsTWheelTimer *end = p;            do  {            ErtsMonotonicTime timeout_pos;            timeout_pos = p-&gt;timeout_pos;            if (min_timeout_pos &gt; timeout_pos) {                true_min_timeout = 1;                min_timeout_pos = timeout_pos;                if (min_timeout_pos &lt;= slot_timeout_pos)                goto found_next;            }            p = p-&gt;next;            } while (p != end);        }        tiw_pos_ix++;        if (tiw_pos_ix == ERTS_TIW_SIZE)            tiw_pos_ix = 0;    } while (start_ix != tiw_pos_ix);found_next:    min_timeout = ERTS_CLKTCKS_TO_MONOTONIC(min_timeout_pos);    tiw-&gt;next_timeout_time = min_timeout;    tiw-&gt;true_next_timeout_time = true_min_timeout;    return min_timeout;}</code></pre><p>函数作用是寻找时间轮所处指针到当前时间curr_time之间最近的一个定时器到时时间。</p><p>函数逻辑分两种情况，一种是时间轮上没有定时器，则判断search_all的值是否要将时间轮的指针拨到当前时间点，然后最小超时时间就为明天的这个时候（因为没有定时器，自然不存在下一个到时的定时器时间）；另一种是时间轮上有定时器，则判断search_all的值是，如果为1，寻找的间隔就是一天(24<em>60</em>60*1000)，否则间隔就是时间轮当前指针到curr_time+max_search_time的距离，然后从时间轮当前指针处开始循环判断每个槽链表，有无定时器的到时时间小于curr_time+max_search_time，如果找了一圈（即走过的距离为ERTS_TIW_SIZE）没找到，就退出，并设置时间轮的下一次到时时间。</p><p><strong>结论：</strong></p><p>时间轮维护了一个下一次到时时间，避免了一段连续的槽上都没有定时器，而在做到时判断时空循环破坏效率。</p><h1 id="时间轮嘀嗒-erts-bump-timers"><a href="#时间轮嘀嗒-erts-bump-timers" class="headerlink" title="时间轮嘀嗒 erts_bump_timers"></a>时间轮嘀嗒 erts_bump_timers</h1><pre><code>voiderts_bump_timers(ErtsTimerWheel *tiw, ErtsMonotonicTime curr_time){    int tiw_pos_ix, slots, yielded_slot_restarted, yield_count;    ErtsMonotonicTime bump_to, tmp_slots, old_pos;    ERTS_MSACC_PUSH_AND_SET_STATE_M_X(ERTS_MSACC_STATE_TIMERS);    yield_count = ERTS_TWHEEL_BUMP_YIELD_LIMIT;    /*     * In order to be fair we always continue with work     * where we left off when restarting after a yield.     */    if (tiw-&gt;yield_slot &gt;= 0) {        yielded_slot_restarted = 1;        tiw_pos_ix = tiw-&gt;yield_slot;        slots = tiw-&gt;yield_slots_left;        bump_to = tiw-&gt;pos;        old_pos = tiw-&gt;yield_start_pos;        goto restart_yielded_slot;    }    do {        yielded_slot_restarted = 0;        bump_to = ERTS_MONOTONIC_TO_CLKTCKS(curr_time);        while (1) {            ErtsTWheelTimer *p;            old_pos = tiw-&gt;pos;            if (tiw-&gt;nto == 0) {                empty_wheel:                ERTS_DBG_CHK_SAFE_TO_SKIP_TO(tiw, bump_to);                tiw-&gt;true_next_timeout_time = 0;                tiw-&gt;next_timeout_time = curr_time + ERTS_MONOTONIC_DAY;                tiw-&gt;pos = bump_to;                tiw-&gt;yield_slot = ERTS_TWHEEL_SLOT_INACTIVE;                        ERTS_MSACC_POP_STATE_M_X();                return;            }            p = tiw-&gt;at_once.head;            while (p) {                if (--yield_count &lt;= 0) {                    ERTS_TW_ASSERT(tiw-&gt;nto &gt; 0);                    ERTS_TW_ASSERT(tiw-&gt;at_once.nto &gt; 0);                    tiw-&gt;yield_slot = ERTS_TWHEEL_SLOT_AT_ONCE;                    tiw-&gt;true_next_timeout_time = 1;                    tiw-&gt;next_timeout_time = ERTS_CLKTCKS_TO_MONOTONIC(old_pos);                            ERTS_MSACC_POP_STATE_M_X();                    return;                }                ERTS_TW_ASSERT(tiw-&gt;nto &gt; 0);                ERTS_TW_ASSERT(tiw-&gt;at_once.nto &gt; 0);                tiw-&gt;nto--;                tiw-&gt;at_once.nto--;                tiw-&gt;at_once.head = p-&gt;next;                if (p-&gt;next)                    p-&gt;next-&gt;prev = NULL;                else                    tiw-&gt;at_once.tail = NULL;                timeout_timer(p);                p = tiw-&gt;at_once.head;            }            if (tiw-&gt;pos &gt;= bump_to) {                ERTS_MSACC_POP_STATE_M_X();                break;            }            if (tiw-&gt;nto == 0)                goto empty_wheel;            if (tiw-&gt;true_next_timeout_time) {                ErtsMonotonicTime skip_until_pos;                /*                 * No need inspecting slots where we know no timeouts                 * to trigger should reside.                 */                skip_until_pos = ERTS_MONOTONIC_TO_CLKTCKS(tiw-&gt;next_timeout_time);                if (skip_until_pos &gt; bump_to)                    skip_until_pos = bump_to;                skip_until_pos--;                if (skip_until_pos &gt; tiw-&gt;pos) {                    ERTS_DBG_CHK_SAFE_TO_SKIP_TO(tiw, skip_until_pos);                    tiw-&gt;pos = skip_until_pos;                }            }            tiw_pos_ix = (int) ((tiw-&gt;pos+1) &amp; (ERTS_TIW_SIZE-1));            tmp_slots = (bump_to - tiw-&gt;pos);            if (tmp_slots &lt; (ErtsMonotonicTime) ERTS_TIW_SIZE)              slots = (int) tmp_slots;            else              slots = ERTS_TIW_SIZE;            tiw-&gt;pos = bump_to;            while (slots &gt; 0) {                p = tiw-&gt;w[tiw_pos_ix];                if (p) {                    if (p-&gt;next == p) {                        ERTS_TW_ASSERT(tiw-&gt;sentinel.next == &amp;tiw-&gt;sentinel);                        ERTS_TW_ASSERT(tiw-&gt;sentinel.prev == &amp;tiw-&gt;sentinel);                    } else {                        tiw-&gt;sentinel.next = p-&gt;next;                        tiw-&gt;sentinel.prev = p-&gt;prev;                        tiw-&gt;sentinel.next-&gt;prev = &amp;tiw-&gt;sentinel;                        tiw-&gt;sentinel.prev-&gt;next = &amp;tiw-&gt;sentinel;                    }                    tiw-&gt;w[tiw_pos_ix] = NULL;                    while (1) {                        if (p-&gt;timeout_pos &gt; bump_to) {                            /* Very unusual case... */                            ++yield_count;                            insert_timer_into_slot(tiw, tiw_pos_ix, p);                        } else {                            /* Normal case... */                            timeout_timer(p);                            tiw-&gt;nto--;                        }                        restart_yielded_slot:                        p = tiw-&gt;sentinel.next;                        if (p == &amp;tiw-&gt;sentinel) {                            ERTS_TW_ASSERT(tiw-&gt;sentinel.prev == &amp;tiw-&gt;sentinel);                            break;                        }                        if (--yield_count &lt;= 0) {                            tiw-&gt;true_next_timeout_time = 1;                            tiw-&gt;next_timeout_time = ERTS_CLKTCKS_TO_MONOTONIC(old_pos);                            tiw-&gt;yield_slot = tiw_pos_ix;                            tiw-&gt;yield_slots_left = slots;                            tiw-&gt;yield_start_pos = old_pos;                            ERTS_MSACC_POP_STATE_M_X();                            return; /* Yield! */                        }                        tiw-&gt;sentinel.next = p-&gt;next;                        p-&gt;next-&gt;prev = &amp;tiw-&gt;sentinel;                    }                }                tiw_pos_ix++;                if (tiw_pos_ix == ERTS_TIW_SIZE)                    tiw_pos_ix = 0;                slots--;            }        }    } while (yielded_slot_restarted);    tiw-&gt;yield_slot = ERTS_TWHEEL_SLOT_INACTIVE;    tiw-&gt;true_next_timeout_time = 0;    tiw-&gt;next_timeout_time = curr_time + ERTS_MONOTONIC_DAY;    /* Search at most two seconds ahead... */    (void) find_next_timeout(NULL, tiw, 0, curr_time, ERTS_SEC_TO_MONOTONIC(2));    ERTS_MSACC_POP_STATE_M_X();}</code></pre><p>这是最重要的一个函数，erlang虚拟机启动后，有一个线程做周期性调用，来检测有无定时器到时。</p><p>函数接收一个curr_time形参，将时间轮上小于等于此时间的定时器都视为到时，所以估计是1ms调用一次。</p><p>函数定义了yield_count=100，如果at_once或者某个槽上大于100个定时器，就丢弃多的。</p><p>这个函数写得很恶心，又是do while{}，又是while(1)，又是while，但剥离开，真正的逻辑就一段：循环将at_once链表的定时器全部到时，则at_once链表清空了；开始判断时间槽，先利用下一个最近的到时时间next_timeout_time跳过一段槽，然后开始遍历从时间轮的当前指针pos到curr_time之间的间隔槽，再遍历每个槽上的链表，对每个结点判断是否大于等于curr_time，即判断是否到时，如果到时就可以去掉定时器，并执行回调任务。</p><p>以上步骤就做完了到时任务，调用一下find_next_timeout寻找一次最近到时时间。</p><p>#</p><p>在看erts_bump_timers函数时候看到一段goto的代码形如：</p><pre><code>goto test_label:int a = 0;test_label:    a = 1;</code></pre><p>当时很诧异，a不是没定义吗？激动得不行，摩拳擦掌准备提bug，抱着谨慎的态度还是查了一下，这种用法是可以的，真是菜得不行 …… 自己猜想一下可能是编译期已经将a加入了符号表，goto只影响运行时。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Erlang底层的定时器实现位于源码的erts/emulator/beam/time.c文件，用时间轮的方式动态添加和删除定时器，结构体名为&lt;code&gt;typedef struct ErtsTimerWheel_ ErtsTimerWheel&lt;/code&gt;，每一个定时器的结
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Erlang" scheme="http://lkness/tags/Erlang/"/>
    
  </entry>
  
  <entry>
    <title>erlang:now()与os:timestamp()-Erlang源码学习一</title>
    <link href="http://lkness/2018/06/20/029erlang-time/index/"/>
    <id>http://lkness/2018/06/20/029erlang-time/index/</id>
    <published>2018-06-20T11:44:02.000Z</published>
    <updated>2018-06-20T12:04:28.254Z</updated>
    
    <content type="html"><![CDATA[<p>erlang中，关于erlang:now()与os:timestamp()两个接口，查看官方文档的解释：</p><p><img src="/img/erlang_time1.png" alt="erlang_time1"></p><p><img src="/img/erlang_time2.png" alt="erlang_time2"></p><p>按官方文档上说erlang:now/0是废弃了的，它可以获取一个持续递增的唯一时间戳。除此也没说讲到更多。</p><p>再看erlang:now/0文档给的<a href="http://erlang.org/doc/apps/erts/time_correction.html#Dos_and_Donts" target="_blank" rel="noopener">时间和时间修正</a>，里面详细描述了erlang对于时间的处理，暂不看。</p><p>直接跳到c源码看吧，在这之前可以看看<a href="https://blog.csdn.net/hytgxljh/article/details/52440837" target="_blank" rel="noopener">linux内核时间的管理</a>，明白什么是墙上时间(wall time)、单调递增时间(monotonic time)等。</p><h1 id="erlang-now-0"><a href="#erlang-now-0" class="headerlink" title="erlang:now/0"></a>erlang:now/0</h1><pre><code>erlang:now/0的bif函数对应erlang源码:erts/emulator/beam/bif.c</code></pre><p><img src="/img/erlang_time3.png" alt="erlang_time3"></p><p><code>now_0()</code>的获取时间调用<code>get_now()</code>函数，位于erts/emulator/beam/erl_time_sup.c</p><p><img src="/img/erlang_time4.png" alt="erlang_time4"></p><p>获取时间主要用一个回调<code>get_time()</code>，而获取时间之后会与上一次调用产生的值比较，并产生一个新的保证单调递增的唯一值，并加锁修改旧值。关于<code>get_time()</code>的初始化要在同文件的<code>erlang_init_time_sup()</code>函数</p><p><img src="/img/erlang_time5.png" alt="erlang_time5"></p><p>可以看到有一个条件编译宏 ERTS_HAVE_OS_MONOTONIC_TIME_SUPPORT，在没有配置erlang源码时，这些宏都未定义，但如果在源码根目录执行了./configure配置后，会在emulator目录生成一个文件夹（我的是x86_64-unknown-linux-gnu），里面放有config.h配置文件，里面根据操作系统类型做了对应宏定义，对应宏ERTS_HAVE_OS_MONOTONIC_TIME_SUPPORT就是在config.h里，表示这个操作系统有单调递增时间(monotonic time)，那么这里可以看到get_time回调指向了<code>get_os_grift_corrected_time()</code>，此函数直接返回<code>read_corrected_time()</code>函数结果：</p><p><img src="/img/erlang_time6.png" alt="erlang_time6"></p><p>可以看到<code>read_corrected_time()</code>函数主要执行了<code>erts_os_monitonic_time()</code>和<code>calc_corrected_erl_mtime()</code>来获取操作系统的monitonic_time以及修正时间。<br><code>erts_os_monitonic_time()</code>直接调用<code>posix_clock_gettime()</code>函数，参数为MONOTONIC_CLOCK_ID，获取monotonic time：</p><p><img src="/img/erlang_time7.png" alt="erlang_time7"></p><p>获取时间的函数实则调用了linux的系统函数<code>clock_gettime()</code>，可以man手册看一看；<br><code>calc_corrected_erl_time()</code>函数：</p><p><img src="/img/erlang_time8.png" alt="erlang_time8"></p><p>将获取的当前操作系统monitonic time与最近一次更新的操作系统monitonic time做一个差值计算，然后根据erlang时间的设计来计算一个新的erlang monitonic time。</p><h1 id="os-timestamp-0"><a href="#os-timestamp-0" class="headerlink" title="os:timestamp/0"></a>os:timestamp/0</h1><p><code>os:timestamp()</code>函数代码：</p><p><img src="/img/erlang_time9.png" alt="erlang_time9"></p><p>代码里调用了<code>erts_os_system_time()</code>函数来获取操作系统的时间：</p><p><img src="/img/erlang_time10.png" alt="erlang_time10"></p><p>又是熟悉的<code>posix_clock_gettime()</code>，并且参数为WALL_CLOCK_ID获取墙上时间。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>erlang:now/0</code>获取的是erlang系统的monotonic time，它从操作系统获取后还要用erlang时间处理的方式在调整为erlang monotonic time，期间几次会对全局变量加锁，故效率会有损耗，而每一次获取时间值后会与上一次获取的值做一个对比，并加一来保证获取值的严格单调递增，所以可以用来作为唯一名(unique name)的生成，但是，erts7.0之后就不建议用这个函数了，可以用<code>erlang:timestamp/0</code>替代，如果要生成唯一名可以用<code>erlang:unique_integer/0</code>等等。 而<code>os:timestamp/0</code>则是获取操作系统的墙上时间(wall time)，并做调整变为erlang system time。</p><p><code>erlang:now/0</code>获取时间的文件为erl_time_sup.c，所有的erlang关于时间处理方式的逻辑都定义在里面，包括维护全局变量来处理操作系统转变为erlang规则的内部时间、注册定时器周期检查erlang时间与os时间对比的偏移量等；<code>os:timestamp/0</code>获取时间的文件为sys_time.c，是对os获取时间的库函数的封装、以及对获取的时间进行简单调整的文件，比较轻量级。</p><p>后记：看了erlang时间的处理，感觉很有趣，后面学习一下erlang源码中对时间的管理代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;erlang中，关于erlang:now()与os:timestamp()两个接口，查看官方文档的解释：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/erlang_time1.png&quot; alt=&quot;erlang_time1&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/er
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Erlang" scheme="http://lkness/tags/Erlang/"/>
    
  </entry>
  
  <entry>
    <title>图的简单表示-算法学习笔记十七</title>
    <link href="http://lkness/2018/06/20/028graph/index/"/>
    <id>http://lkness/2018/06/20/028graph/index/</id>
    <published>2018-06-20T04:49:36.000Z</published>
    <updated>2018-06-20T04:50:55.817Z</updated>
    
    <content type="html"><![CDATA[<p>基于邻接矩阵和邻接链表的图表示法，以及各自的深度优先遍历和广度优先遍历，但图的表示中没有加带权的边，只是简单写一写，学习一下，底层链表和队列用了通用链表</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#define PRINT(format, arg...) \do{ \    printf(&quot;[%s/%d]:&quot;, __func__, __LINE__); \    printf(format, ##arg); \    printf(&quot;\n&quot;); \}while(0)/*****************************图********************************/#define MAX_VERTEX_NUM 100typedef struct init_array {    int start_v;    int end_v;} init_array;/**************邻接矩阵表示****************/typedef struct matrix_graph {    int vertex[MAX_VERTEX_NUM];  // 存放顶点信息    int v_num;  // 顶点数    int e_num;  // 边数    int matrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];} matrix_graph;matrix_graph *init_matrix_graph(    int v_num,    int e_num ){    int i = 0, j = 0;    matrix_graph *graph = NULL;    graph = ( matrix_graph * )malloc( sizeof(matrix_graph) );    graph-&gt;v_num = v_num;    graph-&gt;e_num = e_num;    for ( i = 0; i &lt; MAX_VERTEX_NUM; i++ ) {        if ( i &lt; v_num )            graph-&gt;vertex[i] = i;        else            graph-&gt;vertex[i] = -1;        for ( j = 0; j &lt; MAX_VERTEX_NUM; j++ ) {            graph-&gt;matrix[i][j] = 0;        }    }    return graph;}matrix_graph *create_matrix_graph(    init_array *i_arr,    int arr_size,    int v_num ){    int i = 0;    matrix_graph *graph = NULL;    graph = init_matrix_graph( v_num, arr_size );    for ( i = 0; i &lt; arr_size; i++ ) {        graph-&gt;matrix[i_arr[i].start_v][i_arr[i].end_v] = 1;    }    return graph;}int visited[MAX_VERTEX_NUM] = {0};// 深度优先遍历void dfs_matrix_graph1(    matrix_graph *g,    int v ){    visited[v] = 1;    printf(&quot;%d &quot;, v);    // 搜索此结点的下一个结点    int i = 0;    for ( i; i &lt; g-&gt;v_num; i++ ) {        if ( g-&gt;matrix[v][i] &amp;&amp; !visited[i] )            dfs_matrix_graph1( g, i );    }}void dfs_matrix_graph(    matrix_graph *g ){    int i = 0;    for ( i; i &lt; g-&gt;v_num; i++ )        visited[i] = 0;    printf(&quot;deep first visit:\n\t&quot;);    for ( i = 0; i &lt; g-&gt;v_num; i++ ) {        if ( !visited[i] )            dfs_matrix_graph1( g, i );    }    printf(&quot;\n&quot;);}// 广度优先搜索void bfs_matrix_graph(    matrix_graph *g ){    int i = 0;    // 栈结点数据域，需要void *    int tmp_vertex[MAX_VERTEX_NUM] = {0};    queue *q = create_queue();    for ( i = 0; i &lt; g-&gt;v_num; i++ )        visited[i] = 0;    printf(&quot;broad first visit:\n\t&quot;);    for ( i = 0; i &lt; g-&gt;v_num; i++ ) {        if ( !visited[i] ) {            tmp_vertex[i] = i;            q-&gt;enqueue(q-&gt;this, &amp;tmp_vertex[i]);            while ( q-&gt;size(q-&gt;this) != 0 ) {                int tmp = *( int * )q-&gt;dequeue( q-&gt;this );                if ( !visited[tmp] )                    printf(&quot;%d &quot;, tmp);                visited[tmp] = 1;                int j = 0;                for ( j = 0; j &lt; g-&gt;v_num; j++ ) {                    if ( g-&gt;matrix[tmp][j] &amp;&amp; !visited[j] ) {                        tmp_vertex[j] = j;                        q-&gt;enqueue( q-&gt;this, &amp;tmp_vertex[j] );                    }                }            }        }    }    q-&gt;free( q-&gt;this );    printf(&quot;\n&quot;);}void free_matrix_graph(    matrix_graph *g ){    free( g );}#undef DEBUG_MATRIX_GRAPH#ifdef DEBUG_MATRIX_GRAPHint main(){    init_array i_arr[20] =        {            {0, 4},            {0, 9},            {1, 5},            {2, 1},            {2, 6},            {3, 2},            {3, 6},            {4, 7},            {4, 8},            {5, 2},            {6, 5},            {7, 6},            {7, 3},            {8, 7},            {8, 4},            {9, 8},        };    matrix_graph *g = create_matrix_graph( i_arr, 16, 10 );    dfs_matrix_graph( g );    bfs_matrix_graph( g );    free_matrix_graph( g );}#endif/********************************************//**************图的邻接链表*******************/typedef struct link_list_graph {    int vertex[MAX_VERTEX_NUM];    int v_num;    int e_num;    link_list v_list[MAX_VERTEX_NUM];} link_list_graph;// 链表数据域，需要void *int tmp_vertex[MAX_VERTEX_NUM] = {0};link_list_graph *create_link_list_graph(    init_array *i_arr,    int arr_size,    int v_num ){    int i = 0;    link_list_graph *graph = NULL;    graph = ( link_list_graph * )malloc( sizeof(link_list_graph) );    graph-&gt;e_num = arr_size;    graph-&gt;v_num = v_num;    for ( i = 0; i &lt; v_num; i++ ) {        tmp_vertex[i] = i;        //定制链表操作        graph-&gt;v_list[i].size = 0;        graph-&gt;v_list[i].insert = insert_tail;        graph-&gt;v_list[i].get_first = get_head;        graph-&gt;v_list[i].get_last = get_tail;        graph-&gt;v_list[i].del = del_tail;        graph-&gt;v_list[i].insert( &amp;graph-&gt;v_list[i], &amp;tmp_vertex[i]);    }    for ( i = 0; i &lt; arr_size; i++ ) {        int start = i_arr[i].start_v;        int end = i_arr[i].end_v;        graph-&gt;v_list[start].insert( &amp;graph-&gt;v_list[start], &amp;tmp_vertex[end]);        printf(&quot;start:%d-&gt;end:%d, size:%d\n&quot;, start, end, graph-&gt;v_list[start].size);    }    return graph;}void dfs_link_list_graph1(    link_list_graph *g,    int v ){    link_list_node *p = g-&gt;v_list[v].head;    if ( !visited[*(int *)(p-&gt;data)] ) {        printf(&quot;%d &quot;, *(int *)(p-&gt;data));        visited[v] = 1;        while ( 1 ) {            p = p-&gt;next;            if ( p == g-&gt;v_list[v].head )                break;            if ( !visited[*(int *)(p-&gt;data)] ) {                dfs_link_list_graph1( g, *(int *)(p-&gt;data) );            }        }    }}void dfs_link_list_graph(    link_list_graph *g ){    int i = 0;    printf(&quot;深度优先遍历：\n\t&quot;);    for ( i = 0; i &lt; g-&gt;v_num; i++ )        visited[i] = 0;    for ( i = 0; i &lt; g-&gt;v_num; i++ ) {        if ( g-&gt;v_list[i].size &gt; 0 &amp;&amp; !visited[i] )            dfs_link_list_graph1( g, i );    }    printf(&quot;\n&quot;);}void bfs_link_list_graph(    link_list_graph *g ){    int i = 0;    // 栈结点数据域，需要void *    int tmp_vertex[MAX_VERTEX_NUM] = {0};    queue *q = create_queue();    for ( i = 0; i &lt; g-&gt;v_num; i++ ){        tmp_vertex[i] = i;        visited[i] = 0;    }    printf(&quot;广度优先遍历:\n\t&quot;);    for ( i = 0; i &lt; g-&gt;v_num; i++ ) {        if ( !visited[i] ) {            tmp_vertex[i] = i;            q-&gt;enqueue(q-&gt;this, &amp;tmp_vertex[i]);            while ( q-&gt;size(q-&gt;this) != 0 ) {                int tmp = *( int * )q-&gt;dequeue( q-&gt;this );                if ( !visited[tmp] )                    printf(&quot;%d &quot;, tmp);                visited[tmp] = 1;                int j = 0;                link_list_node *p = g-&gt;v_list[tmp].head-&gt;next;                while ( p != g-&gt;v_list[tmp].head ) {                    if ( !visited[*(int *)p-&gt;data] ) {                        q-&gt;enqueue( q-&gt;this, &amp;tmp_vertex[*(int *)p-&gt;data] );                    }                    p = p-&gt;next;                }            }        }    }    q-&gt;free( q-&gt;this );    printf(&quot;\n&quot;);}void free_link_list_graph(    link_list_graph *g ){    int i = 0;    for ( i = 0; i &lt; g-&gt;v_num; ++i ) {        del_list( &amp;g-&gt;v_list[i] );    }    free( g );}#define DEBUG_LINK_LIST_GRAPH#ifdef DEBUG_LINK_LIST_GRAPHint main(){    init_array i_arr[20] =        {            {0, 4},            {0, 9},            {1, 5},            {2, 1},            {2, 6},            {3, 2},            {3, 6},            {4, 7},            {4, 8},            {5, 2},            {6, 5},            {7, 6},            {7, 3},            {8, 7},            {8, 4},            {9, 8},        };    link_list_graph *g = create_link_list_graph( i_arr, 16, 10 );    dfs_link_list_graph( g );    bfs_link_list_graph( g );    free_link_list_graph( g );}#endif/********************************************//***************************************************************/</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基于邻接矩阵和邻接链表的图表示法，以及各自的深度优先遍历和广度优先遍历，但图的表示中没有加带权的边，只是简单写一写，学习一下，底层链表和队列用了通用链表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://lkness/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>通用链表/栈/队列-算法学习笔记十六</title>
    <link href="http://lkness/2018/06/20/027list-stack-queue/index/"/>
    <id>http://lkness/2018/06/20/027list-stack-queue/index/</id>
    <published>2018-06-20T04:47:44.000Z</published>
    <updated>2018-06-20T04:49:04.717Z</updated>
    
    <content type="html"><![CDATA[<p>今天准备学习数据结构-图，会用到栈和队列，因此写了下代码，底层用了通用链表，为循环双向结构，结点数据域为void *；通用链表层之上封装了栈和队列，比较简单，但是代码行数有点多，单独摘出：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#define MAX_VERTEX_NUM 1000#define PRINT(format, arg...) \do{ \    printf(&quot;[%s/%d]:&quot;, __func__, __LINE__); \    printf(format, ##arg); \    printf(&quot;\n&quot;); \}while(0)/*****************************底层链表***************************/// 循环双向链表typedef struct link_list_node {    void *data;    struct link_list_node *pre;    struct link_list_node *next;} link_list_node;typedef struct link_list {    int size;    //链表插入函数    void (*insert)( struct link_list *list, void *data );    //链表取第一个结点    void *(*get_first)( struct link_list *list );    //链表取最后一个结点    void *(*get_last)( struct link_list *list );    //链表删除第一个结点    void *(*del)( struct link_list *list );    struct link_list_node *head;} link_list;link_list_node *create_link_list_node(    void *data ){    link_list_node *node = NULL;    node = ( link_list_node * )malloc( sizeof(link_list_node) );    node-&gt;data = data;    node-&gt;pre = NULL;    node-&gt;next = NULL;    return node;}//头插void insert_head(    link_list *list,    void *data ){    if ( !list ) {        PRINT(&quot;list is null.&quot;);        return;    }    link_list_node *node = create_link_list_node( data );    if ( !list-&gt;head ) {        node-&gt;next = node;        node-&gt;pre = node;        list-&gt;head = node;        list-&gt;size = 1;        return;    }    node-&gt;next = list-&gt;head;    node-&gt;pre = list-&gt;head-&gt;pre;    list-&gt;head-&gt;pre-&gt;next = node;    list-&gt;head-&gt;pre = node;    list-&gt;head = node;    list-&gt;size += 1;}//尾插，栈/队列的插入void insert_tail (    link_list *list,    void *data ){    if ( !list ) {        return;    }    link_list_node *node = create_link_list_node( data );    if ( !list-&gt;head ) {        node-&gt;next = node;        node-&gt;pre = node;        list-&gt;head = node;        list-&gt;size = 1;        return;    }    node-&gt;pre = list-&gt;head-&gt;pre;    node-&gt;next = list-&gt;head;    list-&gt;head-&gt;pre-&gt;next = node;    list-&gt;head-&gt;pre = node;    list-&gt;size += 1;}//获取链表头数据void *get_head(    link_list *list ){    if ( !list || !list-&gt;head ) {        PRINT(&quot;list is null.&quot;);        return NULL;    }    return list-&gt;head-&gt;data;}//获取链表尾数据void *get_tail(    link_list *list ){    if ( !list || !list-&gt;head ){        PRINT(&quot;list is null.&quot;);        return NULL;    }    return list-&gt;head-&gt;pre-&gt;data;}//删除链表头，并返回删除结点的数据void *del_head(    link_list *list ){    if ( !list || !list-&gt;head ) {        return NULL;    }    if ( list-&gt;size == 1 ) {        void *data = list-&gt;head-&gt;data;        free( list-&gt;head );        list-&gt;head = NULL;        list-&gt;size = 0;        return data;    }    link_list_node *p = list-&gt;head;    void *data = p-&gt;data;    list-&gt;head-&gt;pre-&gt;next = list-&gt;head-&gt;next;    list-&gt;head-&gt;next-&gt;pre = list-&gt;head-&gt;pre;    list-&gt;head = list-&gt;head-&gt;next;    list-&gt;size -= 1;    free( p );    return data;}//删除链表尾，并返回删除结点的数据void *del_tail(    link_list *list ){    if ( !list || !list-&gt;head ) {        PRINT(&quot;list is null.&quot;);        return NULL;    }    if ( list-&gt;size == 1 ) {        void *data = list-&gt;head-&gt;data;        free( list-&gt;head );        list-&gt;head = NULL;        list-&gt;size = 0;        return data;    }    link_list_node *p = list-&gt;head-&gt;pre;    void *data = p-&gt;data;    list-&gt;head-&gt;pre-&gt;pre-&gt;next = list-&gt;head;    list-&gt;head-&gt;pre = list-&gt;head-&gt;pre-&gt;pre;    list-&gt;size -= 1;    free( p );    return data;}/******************************************************************//********************************队列***********************************/typedef struct queue {    void *(*first)( struct queue *this );    void *(*last)( struct queue *this );    void (*enqueue)( struct queue *this, void *data );    void *(*dequeue)( struct queue *this );    int (*size)( struct queue *this );    void (*free)( struct queue *this );    struct link_list *list;    struct queue *this;} queue;void *queue_get_first(    queue *q ){    if ( !q || !q-&gt;list )        return NULL;    return q-&gt;list-&gt;get_first( q-&gt;list );}void *queue_get_last(    queue *q ){    if ( !q || !q-&gt;list )        return NULL;    return q-&gt;list-&gt;get_last( q-&gt;list );}void enqueue(    queue *q,    void *data ){    if ( !q || !q-&gt;list )        return ;    q-&gt;list-&gt;insert( q-&gt;list, data );}void *dequeue(    queue *q ){    if ( !q || !q-&gt;list )        return NULL;    q-&gt;list-&gt;del( q-&gt;list );}int queue_size(    queue *q ){    if ( !q || !q-&gt;list)        return 0;    return q-&gt;list-&gt;size;}void queue_free(    queue *q ){    if ( !q )        return ;    if ( !q-&gt;list ) {        free( q );        return;    }    while ( q-&gt;dequeue( q-&gt;this ) );    free( q-&gt;list );    free( q );}queue *create_queue(){    queue *q = NULL;    q = ( queue * )malloc( sizeof(queue) );    q-&gt;first = queue_get_first;    q-&gt;last = queue_get_last;    q-&gt;enqueue = enqueue;    q-&gt;dequeue = dequeue;    q-&gt;size = queue_size;    q-&gt;free = queue_free;    q-&gt;list = ( link_list * )malloc( sizeof(link_list) );    q-&gt;list-&gt;size = 0;    q-&gt;list-&gt;insert = insert_tail;    q-&gt;list-&gt;get_first = get_head;    q-&gt;list-&gt;get_last = get_tail;    q-&gt;list-&gt;del = del_head;    q-&gt;this = q;}#undef DEBUG_QUEUE#ifdef DEBUG_QUEUEvoid test_queue(){    queue *q = create_queue();    int data1 = 5;    int data2 = 6;    int data3 = 7;    q-&gt;enqueue(q-&gt;this, (void *)&amp;data1);    PRINT(&quot;q-&gt;last:%d&quot;, *(int *)q-&gt;last(q-&gt;this));    q-&gt;enqueue(q-&gt;this, (void *)&amp;data2);    PRINT(&quot;q-&gt;last:%d&quot;, *(int *)q-&gt;last(q-&gt;this));    q-&gt;enqueue(q-&gt;this, (void *)&amp;data3);    PRINT(&quot;q-&gt;last:%d\n&quot;, *(int *)q-&gt;last(q-&gt;this));    PRINT(&quot;q-&gt;size:%d\n&quot;, q-&gt;size(q-&gt;this));    PRINT(&quot;q-&gt;first:%d&quot;, (int)*(int *)(q-&gt;first(q-&gt;this)));    PRINT(&quot;q-&gt;last:%d\n&quot;, (int)*(int *)(q-&gt;last(q-&gt;this)));    PRINT(&quot;q-&gt;dequeue:%d&quot;, (int)*(int *)(q-&gt;dequeue(q-&gt;this)));    PRINT(&quot;q-&gt;first:%d&quot;, (int)*(int *)(q-&gt;first(q-&gt;this)));    PRINT(&quot;q-&gt;size:%d\n&quot;, q-&gt;size(q-&gt;this));    PRINT(&quot;q-&gt;dequeue:%d&quot;, (int)*(int *)(q-&gt;dequeue(q-&gt;this)));    PRINT(&quot;q-&gt;first:%d&quot;, (int)*(int *)(q-&gt;first(q-&gt;this)));    PRINT(&quot;q-&gt;size:%d\n&quot;, q-&gt;size(q-&gt;this));    PRINT(&quot;q-&gt;dequeue the last element&quot;);    q-&gt;dequeue(q-&gt;this);    PRINT(&quot;q-&gt;size:%d\n&quot;, q-&gt;size(q-&gt;this));    q-&gt;free( q-&gt;this );}int main(){    test_queue();    return 0;}#endif/*****************************************************************//*****************************栈********************************/typedef struct stack {    void *(*first)( struct stack *this );    void *(*last)( struct stack *this );    void (*push)( struct stack *this, void *data );    void *(*pop)( struct stack *this );    int (*size)( struct stack *this );    void (*free)( struct stack *this );    struct link_list *list;    struct stack *this;} stack;void *stack_get_first(    stack *s ){    if ( !s || !s-&gt;list )        return NULL;    return s-&gt;list-&gt;get_first( s-&gt;list );}void *stack_get_last(    stack *s ){    if ( !s || !s-&gt;list )        return NULL;    return s-&gt;list-&gt;get_last( s-&gt;list );}void stack_push(    stack *s,    void *data ){    if ( !s || !s-&gt;list )        return ;    s-&gt;list-&gt;insert( s-&gt;list, data );}void *stack_pop(    stack *s ){    if ( !s || !s-&gt;list )        return NULL;    s-&gt;list-&gt;del( s-&gt;list );}int stack_size(    stack *s ){    if ( !s || !s-&gt;list)        return 0;    return s-&gt;list-&gt;size;}void stack_free(    stack *s ){    if ( !s )        return ;    if ( !s-&gt;list ) {        free( s );        return;    }    while ( s-&gt;pop( s-&gt;this ) );    free( s-&gt;list );    free( s );}stack *create_stack(){    stack *s = NULL;    s = ( stack * )malloc( sizeof(stack) );    s-&gt;first = stack_get_first;    s-&gt;last = stack_get_last;    s-&gt;push = stack_push;    s-&gt;pop = stack_pop;    s-&gt;size = stack_size;    s-&gt;free = stack_free;    s-&gt;list = ( link_list * )malloc( sizeof(link_list) );    s-&gt;list-&gt;size = 0;    s-&gt;list-&gt;insert = insert_tail;    s-&gt;list-&gt;get_first = get_tail;    s-&gt;list-&gt;get_last = get_head;    s-&gt;list-&gt;del = del_tail;    s-&gt;this = s;}#define DEBUG_STACK#ifdef DEBUG_STACKvoid test_stack(){    stack *s = create_stack();    int data1 = 5;    int data2 = 6;    int data3 = 7;    s-&gt;push(s-&gt;this, (void *)&amp;data1);    PRINT(&quot;s-&gt;first:%d&quot;, *(int *)s-&gt;first(s-&gt;this));    s-&gt;push(s-&gt;this, (void *)&amp;data2);    PRINT(&quot;s-&gt;first:%d&quot;, *(int *)s-&gt;first(s-&gt;this));    s-&gt;push(s-&gt;this, (void *)&amp;data3);    PRINT(&quot;s-&gt;first:%d\n&quot;, *(int *)s-&gt;first(s-&gt;this));    PRINT(&quot;s-&gt;size:%d\n&quot;, s-&gt;size(s-&gt;this));    PRINT(&quot;s-&gt;last:%d&quot;, (int)*(int *)(s-&gt;last(s-&gt;this)));    PRINT(&quot;s-&gt;first:%d\n&quot;, (int)*(int *)(s-&gt;first(s-&gt;this)));    PRINT(&quot;s-&gt;pop:%d&quot;, (int)*(int *)(s-&gt;pop(s-&gt;this)));    PRINT(&quot;s-&gt;first:%d&quot;, (int)*(int *)(s-&gt;first(s-&gt;this)));    PRINT(&quot;s-&gt;size:%d\n&quot;, s-&gt;size(s-&gt;this));    PRINT(&quot;s-&gt;pop:%d&quot;, (int)*(int *)(s-&gt;pop(s-&gt;this)));    PRINT(&quot;s-&gt;first:%d&quot;, (int)*(int *)(s-&gt;first(s-&gt;this)));    PRINT(&quot;s-&gt;size:%d\n&quot;, s-&gt;size(s-&gt;this));    PRINT(&quot;s-&gt;pop the first element&quot;);    s-&gt;pop(s-&gt;this);    PRINT(&quot;s-&gt;size:%d\n&quot;, s-&gt;size(s-&gt;this));    s-&gt;free( s-&gt;this );}int main(){    test_stack();    return 0;}#endif</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天准备学习数据结构-图，会用到栈和队列，因此写了下代码，底层用了通用链表，为循环双向结构，结点数据域为void *；通用链表层之上封装了栈和队列，比较简单，但是代码行数有点多，单独摘出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#i
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://lkness/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>外排序多路归并+败者树-算法学习笔记十五</title>
    <link href="http://lkness/2018/06/20/026out-sort/index/"/>
    <id>http://lkness/2018/06/20/026out-sort/index/</id>
    <published>2018-06-20T04:40:53.000Z</published>
    <updated>2018-06-20T04:46:12.233Z</updated>
    
    <content type="html"><![CDATA[<p>问题：一个文件有大量的数，现要对文件排序，但内存无法一次读取完全，而磁盘空间足够，要如何排序。</p><p>学习了几篇博客：</p><ol><li>july<a href="https://blog.csdn.net/v_july_v/article/details/6451990" target="_blank" rel="noopener">大神的海量数据排序</a>(他的其他博客都很值得看)</li><li>对july大神的算法进行改进不用选择法而是败者树的<a href="www.cnblogs.com/harryshayne/archive/2011/07/02/2096196.html">博客</a></li><li>以及另一篇但不知道是否为原创的<a href="http://kenby.iteye.com/blog/1017532" target="_blank" rel="noopener">博客</a></li><li>还有<a href="http://www.cnblogs.com/eaglet/archive/2011/01/17/1937083.html" target="_blank" rel="noopener">生成不重复乱序m-n的数的博客</a>(先生成m-n的数，然后洗牌算法)</li></ol><p>#<br>以上几篇博客写得很完全了，看懂了思路，自己临摹写一个简单的测试 ….<br><strong>先用生成随机数的代码生成data.txt待排序大文件:</strong></p><pre><code>//生成随机的不重复的测试数据#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;assert.h&gt;#include &lt;stdlib.h&gt;  // RAND_MAXusing namespace std;//产生[i,u]区间的随机数int randint(int l, int u){    int a = RAND_MAX * rand();    int b = rand();    //取低31位    int c = ( a + b ) &amp; (0x7fffffff) % ( u - l + 1 );    int d = l + c;    return d;}const int size = 10000000;// const int size = 10;int num[size];int main(){    srand((int)time(NULL));    int i, j;    FILE *fp = fopen(&quot;data.txt&quot;, &quot;w&quot;);    assert(fp);    for (i = 0; i &lt; size; i++)        num[i] = i+1;    // printf(&quot;rand_max:%d\n&quot;, RAND_MAX);    for (i = 0; i &lt; size; i++)    {        j = randint(i, size-1);        // printf(&quot;%d &quot;, j);        fflush(stdout);        int t = num[i]; num[i] = num[j]; num[j] = t;        //swap(num[i], num[j]);    }    // printf(&quot;\n&quot;);    for (i = 0; i &lt; size; i++)        fprintf(fp, &quot;%d\n&quot;, num[i]);    fclose(fp);    return 0;}</code></pre><p><strong>对data.txt文件开始外排序:</strong></p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;time.h&gt;#define TEMP_PREFIX &quot;ftemp_&quot;#define OUTPUT_FILE &quot;out_data.txt&quot;#define MAX_WAYS  100// 无穷大，用于某一路文件或缓冲区读到尾了// 败者树产生一个注定失败的结点#define INFINITY 1000000000int *buf;int lst[MAX_WAYS];void read_data(FILE *fp, int *buf){    if ( fscanf(fp, &quot;%d &quot;, buf) == EOF )        *buf = INFINITY;}int partition( int *arr, int p, int r ){    int x = arr[r];    int i = p - 1;    int j = 0, temp;    for ( j = p; j &lt;= r - 1; j++ ) {        if ( arr[j] &lt;= x ) {            i += 1;            temp = arr[i];            arr[i] = arr[j];            arr[j] = temp;        }    }    temp = arr[i + 1];    arr[i + 1] = arr[r];    arr[r] = temp;    return i + 1;}void quick_sort( int *arr, int p, int r ){    if ( p &lt; r ) {        int q = partition( arr, p, r );        quick_sort( arr, p, q - 1 );        quick_sort( arr, q + 1, r );    }}void adjust( int k, int s ){    // t为结点s在败者树数组的父结点，    // 例如64路归并，输入63/62，他们    // 的父结点均为 63    int t = ( k + s ) / 2;    while ( t &gt; 0 ) {        if ( s == -1 ) {            break;        }        // 第一趟，输入一个叶子结点s，让s与父结点的值比较        // （这里父结点一定保存上一次比较的较大者），如果s        // 大于父结点的值，表示s为新的败者，将表示s结点的        // 索引放到父结点处，胜者（父结点）继续到更上层的        // 父结点进行比较，这样比较完后，顶点一定放置的最        // 小的值        // 将败者树想象为一场淘汰赛，假如有8个参赛者入口，        // 8个参赛者编号1-8，第一轮（即初始化败者树），假        // 设产生了2/4/6/8四强败者，放置到8个入口上一层（        // 即父结点），然后再产生两强败者5/7，放置到更上一        // 层的结点，然后产生最后的失败者1，而剩余的8就是最        // 终的胜者，这样一棵败者树就初始化好了，        // 8个入口，之后我们可以随便哪个入口加入一个参赛者，        // 这个参赛者只需要与父结点进行比较，败者留下，胜者        // 可以往更高的父结点去参加比赛....这样每一轮进入一        // 个参赛者，每次能得到一个新的冠军(最小值)，然后写入        // 文件末尾        // 这里的8其实就是8路归并，这个入口的参赛者每次就去        // 读取8个排好序的文件或缓冲区        if ( buf[s] &gt; buf[lst[t]] ) {            int temp = s;            s = lst[t];            lst[t] = temp;        }        t &gt;&gt;= 1;    }    // 以2^n次方来算，顶层败者编号为1，所以败者树数组lst[0]一定    // 没存东西，可以用来存放最后的冠军    lst[0] = s;}void create_loser_tree(int k){    int i = 0;    for( i; i &lt; k; i++ ) {        lst[i] = -1;    }    for( i = k - 1; i &gt;= 0; i-- ) {        adjust(k, i);    }}void k_merge(    int k ){    int i = 0;    FILE **ftemp = ( FILE * )malloc( sizeof(FILE *) * k );    FILE *fout = NULL;    // 归并路数大小的数组，每个数组值存放每一个归并路文件读取的    // 一个值，某一个索引的值写入输出文件，又读取对应文件下一个    // 值补充    buf = ( int * )malloc( sizeof(int) * k );    fout = fopen( OUTPUT_FILE, &quot;w+&quot; );    for ( i; i &lt; k; i++ ) {        char file_name[20] = {0};        snprintf( file_name, sizeof(file_name), TEMP_PREFIX&quot;%d&quot;, i );        ftemp[i] = fopen( file_name, &quot;r&quot; );        // 读取每个排序好的临时文件第一个数        fscanf( ( FILE * )ftemp[i], &quot;%d &quot;, buf + i );    }    // 以排好序文件第一个数的数组来创建败者树，    // 树结点产生败者，这样以后的每轮比较只需要    // 去文件或缓冲区读取下一个值加入败者树入口即可    create_loser_tree( k );    // 开始归并， 哪一个入口产生的冠军，先把冠军写入输出文件，    // 然后冠军所属的文件或缓冲区再读入一个数进行比赛，如果某一路    // 文件或缓冲区读到尾了，那么这个入口的参赛者为无限大，这样    // 与之共有一个父结点的兄弟结点每次读取的值都能成为胜者，参加    // 父结点以上的比较，到所有节点都读完时，最终败者结点，即lst[1]    // 为无穷大，再加入一个参赛者，lst[0]也为无穷大了，    while ( buf[lst[0]] != INFINITY ) {        // 读取冠军的值        int q = lst[0];        // 将冠军写入输出文件        fprintf(fout, &quot;%d\n&quot;, buf[q]);        // 读取冠军所属队列（文件或缓冲区）的下一个值        read_data(ftemp[q], &amp;buf[q]);        // 加入了一个新参赛者，调整败者树        adjust(k, q);    }    // 清理    free( buf );    for ( i = 0; i &lt; k; i++ ) {        fclose(ftemp[i]);    }}void memory_sort_small_file(    FILE *fp,    int num, // 待排序数的数量    int k ){    int i = 0;    int num_per_ways = num / k; // 每一路多少个数    int *buf = NULL;    FILE **ftemp = ( FILE * )malloc( sizeof(FILE *) * k );    buf = ( int * )malloc( sizeof(int) * num_per_ways + 1000 );    // for ( i = 0; i &lt; k; i++ ) {    //     char temp_buf[20] = {0};    //     snprintf( temp_buf, sizeof(temp_buf), TEMP_PREFIX&quot;%d&quot;, i);    //     ftemp[i] = fopen( temp_buf, &quot;w+&quot; );    //     if ( ftemp[i] == NULL ) {    //         printf(&quot;[%s:%d],error occured!!(%s)\n&quot;, __func__, __LINE__, strerror(errno));    //         exit( 0 );    //     }    // }    // 先不处理最后一个，可能总数/k路带余数，多余的    // 留到最后一个文件处理    k--;    while ( k &gt; 0 ) {        char temp_buf[20] = {0};        snprintf( temp_buf, sizeof(temp_buf), TEMP_PREFIX&quot;%d&quot;, k);        ftemp[k] = fopen( temp_buf, &quot;w+&quot; );        if ( ftemp[k] == NULL ) {            printf(&quot;[%s:%d],error occured!!(%s)\n&quot;, __func__, __LINE__, strerror(errno));            exit( 0 );        }        i = 0;        memset( buf, 0, sizeof(buf) );        for ( i; i &lt; num_per_ways; i++ ) {            fscanf(fp, &quot;%d &quot;, &amp;buf[i]);        }        printf(&quot;%s:%d, K:%d\n&quot;, __func__, __LINE__, k);        quick_sort( buf, 0, num_per_ways - 1 );        for ( i = 0; i &lt; num_per_ways; i++ ) {            fprintf(ftemp[k], &quot;%d &quot;, buf[i]);        }        fclose( ftemp[k] );        k--;    }    // 处理剩余的最后一个待排序文件    char temp_buf[20] = {0};    snprintf( temp_buf, sizeof(temp_buf), TEMP_PREFIX&quot;%d&quot;, 0);    ftemp[0] = fopen( temp_buf, &quot;w+&quot; );    if ( ftemp[0] == NULL ) {        printf(&quot;[%s:%d],error occured!!(%s)\n&quot;, __func__, __LINE__, strerror(errno));        exit( 0 );    }    i = 0;    while ( fscanf(fp, &quot;%d &quot;, &amp;buf[i]) != EOF ) i++;    printf(&quot;%s:%d, K:%d\n&quot;, __func__, __LINE__, 0);    quick_sort( buf, 0, i );    int j = 0;    for ( j = 0; j &lt;= i; j++ ) {        fprintf(ftemp[0], &quot;%d &quot;, buf[j]);    }    free( buf );    fclose( ftemp[0] );}int main(    int argc,    char **argv ){    if ( argc != 3 ) {        printf(&quot;usage:\n\t./xxx file_name k ways to merge\n&quot;);        exit( 0 );    }    int k = atoi( argv[2] );    char *file_name = argv[1];    FILE *fp = fopen(file_name, &quot;r&quot;);    if ( fp == NULL ) {        printf(&quot;[%s:%d],error occured!!(%s)\n&quot;, __func__, __LINE__, strerror(errno));        exit( 0 );    }    time_t t1 = time(NULL), t2, t3;    memory_sort_small_file( fp, 10000000, k );    t2 = time(NULL);    k_merge( k );    t3 = time(NULL);    printf(&quot;---------------------------finish-----------------------------\n&quot;);    printf(&quot;\tmemory sort &amp; ouput to temp file cost:  %ds\n&quot;, (int)(t2 - t1));    printf(&quot;\tk_merge &amp; ouput to file cost:  %ds\n&quot;, (int)(t3 - t2));    printf(&quot;\ttotal cost time:  %ds\n&quot;, (int)(t3 - t1));    printf(&quot;--------------------------------------------------------------\n&quot;);    fclose( fp );    return 0;}</code></pre><p>64路归并排序1000w个数用时：</p><p><img src="/img/out_sort1.png" alt="out_sort1"></p><p>生成文件：</p><p><img src="/img/out_sort2.png" alt="out_sort2"></p><p>排序后的文件头和尾：</p><p><img src="/img/out_sort3.png" alt="out_sort3"><br><img src="/img/out_sort4.png" alt="out_sort4"></p><p>代码注释写了很多了，以后忘了回头看看也能记起来 …..</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;问题：一个文件有大量的数，现要对文件排序，但内存无法一次读取完全，而磁盘空间足够，要如何排序。&lt;/p&gt;
&lt;p&gt;学习了几篇博客：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;july&lt;a href=&quot;https://blog.csdn.net/v_july_v/article/details/
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://lkness/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>trie树-《算法导论》学习笔记十四</title>
    <link href="http://lkness/2018/06/20/025trie-tree/index/"/>
    <id>http://lkness/2018/06/20/025trie-tree/index/</id>
    <published>2018-06-20T04:34:50.000Z</published>
    <updated>2018-06-20T04:38:29.448Z</updated>
    
    <content type="html"><![CDATA[<p>引用一下百度百科的话吧：<br>Trie树，又称单词查找树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p><p>这里构建了一棵字典树，每个结点有52个孩子指针，对应26个小写字母和26个大写字母，根节点不存储数据，一个单词从第一个字母开始经由根结点走对应分支进行插入和统计。</p><p>trie树结点卫星数据包含了字母、出现次数、是否构成一个单词，孩子指针就是一个52大小的trie树结点指针数组。</p><p>实现了几个操作：</p><h1 id="插入单词"><a href="#插入单词" class="headerlink" title="插入单词"></a>插入单词</h1><blockquote><p>遍历每个字母，从根结点出发，如果结点对应字母的孩子结点为空，就创建结点，出现次数为1，如果存在这个结点，出现次数就+1，并且如果单词结束，结束处的结点是否构成一个单词字段标识为构成</p></blockquote><h1 id="遍历树，并打印所有单词和每个单词出现次数"><a href="#遍历树，并打印所有单词和每个单词出现次数" class="headerlink" title="遍历树，并打印所有单词和每个单词出现次数"></a>遍历树，并打印所有单词和每个单词出现次数</h1><h1 id="统计树，按给定的数字统计出现次数前几的单词"><a href="#统计树，按给定的数字统计出现次数前几的单词" class="headerlink" title="统计树，按给定的数字统计出现次数前几的单词"></a>统计树，按给定的数字统计出现次数前几的单词</h1><blockquote><p>树统计，与遍历类似，用尾递归，并传入一个大于单词最大长度的数组来存储每个分支的单词，如果遇到结点能构成一个单词，就判断你单词个数，并以插入排序的方式插入创建的统计链表（类似打扑克的插排序）；<br> 统计链表有更新操作，根据输入的统计前几的数字来维护这个链表该去掉哪些结点，该更新哪些结点的顺序等</p></blockquote><p>##<br>获取单词来源为编写的一个简单单词随机生成代码，写入一个文件中，可指定单词最大长度，全大写/全小写/大小写均有，单词个数，单词范围（只支持a-<em>或A-</em>，例如5，就是生成a-e/A-E的单词）<br>贴代码：<br><strong>随机生成单词</strong></p><pre><code>#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int word_len = 0;int upper_low = 65;int lowwer_low = 97;// if letter_size = 5// it will generate a-e or A-E letter.int letter_size = 0;int random_letter(){    return rand() % letter_size;}int random_word(    char *word,    int opt ){    // minimum word&apos;length is 3.    int true_word_len = rand() % word_len + 3;    int true_word_len1 = true_word_len;    while ( true_word_len-- ) {        char letter = 0;        if ( opt == 0 ) {            letter = random_letter() + lowwer_low;        } else if ( opt == 1 ) {            letter = random_letter() + upper_low;        } else {            int opt_case = rand() % 2;            if ( opt_case == 0 )                letter = random_letter() + lowwer_low;            else                letter = random_letter() + upper_low;        }        word[true_word_len] = letter;    }    return true_word_len1;}void gen_word(    int fd,    int word_num,    int opt ){    char word[20] = {0};    int true_word_len = 0;    while ( word_num-- ) {        memset( word, 0, 20);        true_word_len = random_word( word, opt );        word[true_word_len] = &apos;\n&apos;;        write( fd, word, true_word_len + 1 );    }}int main(    int argc,    char **argv ){    srand((int)time(NULL));    if ( argc != 5 ) {        printf(&quot;please input &quot;                &quot;word&apos;s length &amp; &quot;                &quot;words&apos; number &amp; &quot;                &quot;word&apos;s range &amp; &quot;                &quot;gen_case(0:lowwer case,1:upper case,other:both\n&quot;);        exit( 0 );    }    word_len = atoi( argv[1] );    int word_num = atoi( argv[2] );    letter_size = atoi( argv[3] );    int opt = atoi( argv[4] );    int fd = open(&quot;word.txt&quot;, O_RDWR | O_TRUNC, 0777);    gen_word( fd, word_num, opt );    close( fd );    return 0;}</code></pre><p><strong>trie树</strong></p><pre><code>#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#define MAX_CHILD_NUM 52#define UPPER_LOW 65#define UPPER_UP 90#define LOWER_LOW 97#define LOWER_UP 122#define PRINT(format, arg...) \do { \    printf(&quot;[%s/%d]:&quot;, __func__, __LINE__); \    printf(format, ##arg); \    printf(&quot;\n&quot;); \}while(0)typedef struct trieTreeNode {    char letter;    int count;    int is_word;    struct trieTreeNode *next[MAX_CHILD_NUM];} trieTreeNode;typedef struct trieTree {    trieTreeNode *root;} trieTree;typedef struct count_data {    int order;    int count;    char string[20];    struct count_data *next;} count_data;int trans_letter_2_index(    char letter ){    int index = -1;    if ( letter &gt;= LOWER_LOW        &amp;&amp; letter &lt;= LOWER_UP ) {        index = letter - LOWER_LOW + 26;    } else if ( letter &gt;= UPPER_LOW        &amp;&amp; letter &lt;= UPPER_UP ) {        index = letter - UPPER_LOW;    } else {        PRINT(&quot;error letter input:%c&quot;, letter);        exit( 0 );    }    return index;}trieTreeNode *create_node(    char letter ){    trieTreeNode *node =        ( trieTreeNode * )calloc( 1, sizeof(trieTreeNode) );    node-&gt;letter = letter;    node-&gt;count = 0;    node-&gt;is_word = 0;}void insert(    trieTreeNode *root,    char *word ){    if ( root == NULL ) {        PRINT(&quot;root node is null.&quot;);        return;    }    int i = 0;    trieTreeNode *cur = root;    for ( i; word[i] != &apos;\0&apos;; i++ ) {        int next_index = trans_letter_2_index(word[i]);        //PRINT(&quot;letter:%c, index:%d&quot;, word[i], next_index);        if ( cur-&gt;next[next_index] == NULL ) {            cur-&gt;next[next_index] = create_node( word[i] );        } else {            //cur-&gt;next[next_index]-&gt;count += 1;        }        if ( word[i+1] == &apos;\0&apos; ) {            cur-&gt;next[next_index]-&gt;count += 1;            cur-&gt;next[next_index]-&gt;is_word = 1;        }        cur = cur-&gt;next[next_index];    }}// 删除链表所有结点void delete_list_all_node(    count_data *node ){    count_data *p = NULL;    while ( node ) {        p = node;        node = node-&gt;next;        free( p );    }}void print_list_all_node(    count_data *node ){    printf(&quot;\n&quot;);    node = node-&gt;next;    while ( node ) {        printf(&quot;[%d],count:%d\tword:%s\n&quot;,            node-&gt;order, node-&gt;count, node-&gt;string);        node = node-&gt;next;    }    printf(&quot;\n&quot;);}void update_insert_node(    count_data *insert_node ){    if ( !insert_node-&gt;next )        return;    count_data *print_p = insert_node;    if ( insert_node-&gt;order == 1 ) {        delete_list_all_node( insert_node-&gt;next );        insert_node-&gt;next = NULL;    } else if ( insert_node-&gt;order &lt; 1 ) {        PRINT(&quot;ERROR!!!!!&quot;);        exit( 0 );    } else {        count_data *p = insert_node;        insert_node = insert_node-&gt;next;        while ( insert_node ) {            if ( insert_node-&gt;count &lt; p-&gt;count ) {                insert_node-&gt;order = p-&gt;order - 1;            } else if ( insert_node-&gt;count &gt; p-&gt;count ) {                PRINT(&quot;ERROR!!!cur-&gt;count:%d, pre-&gt;count:%d&quot;,                    insert_node-&gt;count, p-&gt;count);                exit( 0 );            } else {                insert_node-&gt;order = p-&gt;order;            }            if ( insert_node-&gt;order &lt; 1 ) {                delete_list_all_node( insert_node );                p-&gt;next = NULL;                break;            }            p = insert_node;            insert_node = insert_node-&gt;next;        }    }}void list_insert(    char *tmp_word,    int cur_count,    int tail,    count_data *head,    int top_num ){    tmp_word[tail] = &apos;\0&apos;;    count_data *new_data = ( count_data * )malloc( sizeof(count_data) );    new_data-&gt;count = cur_count;    memcpy( new_data-&gt;string, tmp_word, tail + 1 );    new_data-&gt;next = NULL;    //PRINT(&quot;count:%d\ttmp_word:%s, string:%s&quot;, cur_count, tmp_word, new_data-&gt;string);    if ( head-&gt;next == NULL ) {        head-&gt;next = new_data;        new_data-&gt;order = top_num;    } else if ( cur_count &gt; head-&gt;next-&gt;count ) {        new_data-&gt;order = head-&gt;next-&gt;order;        new_data-&gt;next = head-&gt;next;        head-&gt;next = new_data;        update_insert_node( new_data );    } else {        while ( 1 ) {            head = head-&gt;next;            if ( head-&gt;next == NULL ) {                if ( head-&gt;order &gt; 1 ) {                    head-&gt;next = new_data;                    if ( head-&gt;count == new_data-&gt;count )                        new_data-&gt;order = head-&gt;order;                    else                        new_data-&gt;order = head-&gt;order - 1;                    head-&gt;next = new_data;                } else if ( head-&gt;count &gt; new_data-&gt;count ) {                    // 不插入                    free( new_data );                } else if ( head-&gt;count == new_data-&gt;count ) {                    head-&gt;next = new_data;                    new_data-&gt;order = head-&gt;order;                } else if ( head-&gt;count &lt; new_data-&gt;count ) {                    // 此种情况只有求出现次数最多的前1个单词时有                    head-&gt;count = new_data-&gt;count;                    free( new_data );                }                break;            } else if ( head-&gt;count &gt;= cur_count                &amp;&amp; head-&gt;next-&gt;count &lt; cur_count ) {                new_data-&gt;next = head-&gt;next;                head-&gt;next = new_data;                new_data-&gt;order = head-&gt;order;                update_insert_node( new_data );                break;            }        }    }}void find_top_count1(    trieTreeNode *root,    char *tmp_word,    int tail,    count_data *head,    int top_num ){    if ( !root )        return;    tmp_word[tail] = root-&gt;letter;    tail++;    if ( root-&gt;is_word ) {        /*        printf(&quot;\n--------------before delete------------------\n&quot;);        print_list_all_node( head );        printf(&quot;\n--------------------------------------------\n&quot;);        */        list_insert( tmp_word, root-&gt;count, tail, head, top_num );        /*        printf(&quot;\n--------------------after delete----------------------------\n&quot;);        print_list_all_node( head );        printf(&quot;\n-----------------------------------------------------------\n&quot;);        */    }    int i = 0;    for ( i; i &lt; MAX_CHILD_NUM; i++ ) {        find_top_count1( root-&gt;next[i], tmp_word, tail, head, top_num );    }}void find_top_count(    trieTreeNode *root,    int top_num ){    if ( !root )        return;    int i = 0;    count_data *head = ( count_data * )malloc( sizeof(count_data) );    for ( i; i &lt; MAX_CHILD_NUM; i++ ) {        char tmp_word[20] = {0};        find_top_count1( root-&gt;next[i], tmp_word, 0, head, top_num );    }    printf(&quot;出现次数最大前%d次的单词:\n&quot;, top_num);    count_data *p = head-&gt;next;    count_data *free_p = NULL;    while ( p != NULL ) {        free_p = p;        printf(&quot;前%d,count:%d\t%s\n&quot;, p-&gt;order, p-&gt;count, p-&gt;string);        p = p-&gt;next;        free( free_p );    }    free( head );}void tree_walk1(    trieTreeNode *root,    char *tmp_word,    int tail ){    if ( !root )        return;    tmp_word[tail] = root-&gt;letter;    tail++;    //printf(&quot;%c\n&quot;, root-&gt;letter);    if ( root-&gt;is_word ) {        int j = 0;        printf(&quot;count:%d\t&quot;, root-&gt;count);        for ( j; j &lt; tail; j++ ) {            printf(&quot;%c&quot;, tmp_word[j]);        }        printf(&quot;\n&quot;);    }    int i = 0;    for ( i; i &lt; MAX_CHILD_NUM; i++ ) {        tree_walk1( root-&gt;next[i], tmp_word, tail );    }}void tree_walk(    trieTreeNode *root ){    if ( !root )        return;    int i = 0;    for ( i; i &lt; MAX_CHILD_NUM; i++ ) {        char tmp_word[20] = {0};        tree_walk1( root-&gt;next[i], tmp_word, 0 );    }}int main(    int argc,    char **argv ){    if ( argc != 3 ) {        PRINT(&quot;USAGE: please input words file &amp; top number&quot;);        exit( 0 );    }    char *file_name = argv[1];    int top_num = atoi( argv[2] );    trieTree *tree = ( trieTree * )malloc( sizeof(trieTree) );    tree-&gt;root = create_node( -1 );    int fd = open(file_name, O_RDONLY);    if ( fd &lt; 0 ) {        PRINT(&quot;OPEN FILE %s ERROR!!!(%s)&quot;, file_name, (char *)strerror(errno));        exit( 0 );    }    // 每次读取文件的缓冲区    char buf[1024 * 10] = {0};    // 每次读取的大小    int read_len = 1024;    // 读取的返回值    int read_bytes = 0;    // 从读取的缓冲区每次提取&apos;\n&apos; - &apos;\n&apos;之间的单词    char tmp_word[20] = {0};    // 读取文件缓冲区如果出现单词隔断，剩余部分在下一次    // read才能读到，这个index做单词继续拼接    int tmp_index = 0;    while ( 1 ) {        memset( buf, 0, read_len );        read_bytes = read( fd, buf, read_len );        if ( read_bytes &lt;= 0 )            break;        //printf(&quot;readbytes:%d------\n%s\n&quot;, read_bytes, buf);        int cur = 0;        while ( cur &lt; read_bytes ) {            // 单词文件最后一个单词末尾一定要有&apos;\n&apos;            if ( buf[cur] == &apos;\n&apos; ) {                tmp_word[tmp_index] = &apos;\0&apos;;                //printf(&quot;insert word:%s\n&quot;, tmp_word);                insert( tree-&gt;root, tmp_word );                memset( tmp_word, 0, 20 );                tmp_index = 0;            } else {                tmp_word[tmp_index] = buf[cur];                tmp_index++;            }            cur++;        }    }    printf(&quot;\n========================================\n&quot;);    tree_walk( tree-&gt;root );    find_top_count( tree-&gt;root, top_num );    close( fd );    return 0;}</code></pre><p>trie树的代码使用：./xxx word.txt 10即统计出现次数前10的单词，并打印单词和次数</p><p>例如对生成了10000个单词的word.txt文件，统计前5：<br>./xxx word.txt 5</p><p><img src="/img/trie_tree.png" alt="trie_tree"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引用一下百度百科的话吧：&lt;br&gt;Trie树，又称单词查找树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://lkness/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>avl树-《算法导论》学习笔记十三</title>
    <link href="http://lkness/2018/06/20/024avl-tree/index/"/>
    <id>http://lkness/2018/06/20/024avl-tree/index/</id>
    <published>2018-06-20T02:55:19.000Z</published>
    <updated>2018-06-20T04:39:26.707Z</updated>
    
    <content type="html"><![CDATA[<p>（引用算法导论）AVL树是一种高度平衡的二叉搜索树：对每一个结点x，y的左子树与右子树的高度至多为1。AVL树相比二叉搜索树，每个结点维护一个额外的属性：结点的高度。</p><p>AVL树实现了几个操作：</p><h1 id="树结点创建"><a href="#树结点创建" class="headerlink" title="树结点创建"></a>树结点创建</h1><h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><blockquote><p>递归的前序、中序、后序遍历，以及基于层序遍历的简单图形打印</p></blockquote><h1 id="后序遍历释放树结点"><a href="#后序遍历释放树结点" class="headerlink" title="后序遍历释放树结点"></a>后序遍历释放树结点</h1><h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h1 id="寻找结点子树最小关键字结点、寻找结点子树最大关键字结点"><a href="#寻找结点子树最小关键字结点、寻找结点子树最大关键字结点" class="headerlink" title="寻找结点子树最小关键字结点、寻找结点子树最大关键字结点"></a>寻找结点子树最小关键字结点、寻找结点子树最大关键字结点</h1><h1 id="求结点高度"><a href="#求结点高度" class="headerlink" title="求结点高度"></a>求结点高度</h1><h1 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h1><h1 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h1><h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><blockquote><p>先以普通二叉搜索树的方式插入结点；</p><p>插入结点后可能影响平衡（一个子树高度-另一子树高度等于2），具体的不平衡的情况分四种：</p><ol><li>结点左子树高度-右子树高度=2，且结点左孩子的左子树更高</li><li>结点左子树高度-右子树高度=2，且结点右孩子的右子树更高</li><li>结点右子树高度-左子树高度=2，且结点右孩子的右子树更高</li><li>结点右子树高度-左子树高度=2，且结点右孩子的左子树更高</li></ol><p>对于情况1，只需对结点进行右旋即可重新平衡；</p><p>对于情况3，只需对结点进行左旋即可重新平衡；</p><p>对于情况2，需要先对结点的左孩子进行左旋，然后对结点进行右旋即可平衡；</p><p>对于情况4，需要先对结点的右孩子进行右旋，然后对结点进行左旋即可平衡；</p><p>旋转之后，结点的左子树与右子树达到平衡，但结点父结点的树可能不平衡，</p><p>需要循环向根节点判断结点高度有无平衡，直至根节点。</p></blockquote><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><blockquote><ol><li><p>先查询相同的key的结点；</p></li><li><p>找到待删除结点，如果待删除结点的左孩子与右孩子都不为空，则判断左右孩子的树高：</p></li></ol><ul><li>若左子树更高，则将左子树的最大关键字结点的关键字替换掉待删除结点的关键字，然后再删除那个左子树最大关键字结点</li><li>若右子树与左子树同高或更高，则将右子树的最小关键字结点的关键字替换掉待删除节点的关键字，然后再删除那个右子树最小关键字结点</li></ul><ol start="3"><li>删除结点后，会影响树平衡，具体不平衡情况与插入时相同，依然进行相同操作来重新平衡树</li></ol></blockquote><p>#</p><p>代码:</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#include &lt;math.h&gt;#define MAX(a, b) ((a &gt; b) ? (a) : (b))typedef struct avlTreeNode {    int key;    int height;    //这里有父结点，有了父结点多很多代码，    //大部分的调试都是父结点的值没注意，    //可取消这个字段    struct avlTreeNode *parent;    struct avlTreeNode *left;    struct avlTreeNode *right;}avlTreeNode;typedef struct avlTree {    int node_num;    avlTreeNode *root;}avlTree;// 随机基数尽量大，代码不支持key值相同的// 树节点，但不影响插入，删除会出错，所以// 尽量保证不同int random_num(){    int a = 1;    int b = 10000;    return rand() % ( b - a ) + a;}avlTreeNode *tree_create_node(    int key,    avlTreeNode *parent,    avlTreeNode *left,    avlTreeNode *right ){    avlTreeNode *node = ( avlTreeNode * )malloc( sizeof(avlTreeNode) );    node-&gt;height = 1;    node-&gt;key = key;    node-&gt;parent = parent;    node-&gt;left = left;    node-&gt;right = right;    return node;}//后续遍历释放树结点void postorder_tree_free(    avlTreeNode *root ){    if ( root != NULL ) {        postorder_tree_free( root-&gt;left );        postorder_tree_free( root-&gt;right );        printf(&quot;%d &quot;, root-&gt;key);        free( root );    }}void inorder_tree_walk(    avlTreeNode *root ){    if ( root != NULL ) {        inorder_tree_walk( root-&gt;left );        printf(&quot;%d(%d) &quot;, root-&gt;key, root-&gt;height);        inorder_tree_walk( root-&gt;right );    }}void preorder_tree_walk(    avlTreeNode *root ){    if ( root != NULL ) {        printf(&quot;%d(%d) &quot;, root-&gt;key, root-&gt;height);        preorder_tree_walk( root-&gt;left );        preorder_tree_walk( root-&gt;right );    }}void postorder_tree_walk(    avlTreeNode *root ){    if ( root != NULL ) {        postorder_tree_walk( root-&gt;left );        postorder_tree_walk( root-&gt;right );        printf(&quot;%d(%d) &quot;, root-&gt;key, root-&gt;height);    }}//层序遍历，支持简单的树形打印//为了调试代码，而不用中序和前序//去推算树int queue_pre = -1;int queue_post = 0;avlTreeNode *node_queue[1000] = {NULL};int factor( int n ){    if ( n == 1 )        return 1;    return (pow(2,n-1) + factor( n - 1 ));}void graph_tree_walk(    avlTreeNode *root,    int height,    int root_height ){    if ( queue_pre == factor( root_height ) - 1 )        return ;    queue_pre++;    if ( root == NULL ) {        printf(&quot;* &quot;);        node_queue[queue_post] = NULL;        queue_post++;        node_queue[queue_post] = NULL;        queue_post++;    } else {        node_queue[queue_post] = root-&gt;left;        queue_post++;        node_queue[queue_post] = root-&gt;right;        queue_post++;        printf(&quot;%d &quot;, root-&gt;key);    }    int new_height = height;    if ( queue_pre == factor( height ) - 1 ) {        printf(&quot;\n&quot;);        new_height = height + 1;    }    graph_tree_walk( node_queue[queue_pre], new_height, root_height );}void print_tree(    avlTree *tree ){    printf(&quot;中序:&quot;);    inorder_tree_walk( tree-&gt;root );    printf(&quot;\n&quot;);    printf(&quot;前序:&quot;);    preorder_tree_walk( tree-&gt;root );    printf(&quot;\n&quot;);    printf(&quot;后序:&quot;);    postorder_tree_walk( tree-&gt;root );    printf(&quot;\n&quot;);    printf(&quot;图形:\n&quot;);    graph_tree_walk( tree-&gt;root, 1, tree-&gt;root-&gt;height );    queue_pre = -1;    queue_post = 0;    int i = 999;    for ( i ; i &gt;=0; i-- )        node_queue[i] = NULL;    printf(&quot;\n\n&quot;);}//检查avl树的树高是否差2以内int check_is_avltree(    avlTreeNode *root ){    if ( root == NULL )        return 0;    int left_height = check_is_avltree( root-&gt;left );    int right_height = check_is_avltree( root-&gt;right );    if ( left_height - right_height &gt;= 2 || right_height - left_height &gt;= 2 )        printf(&quot;it&apos;s not a avl tree!!!! l:%d, r:%d\n&quot;, left_height, right_height);    else        //printf(&quot;left:%d,right:%d\n&quot;, left_height, right_height);    return (left_height &gt; right_height ? left_height : right_height ) + 1;}avlTreeNode *tree_search_recursion(    avlTreeNode *root,    int key ){    if ( root == NULL || key == root-&gt;key ) {        return root;    }    if ( key &lt; root-&gt;key )        return tree_search_recursion( root-&gt;left, key );    else        return tree_search_recursion( root-&gt;right, key );}avlTreeNode *tree_search(    avlTreeNode *root,    int key ){    while ( root != NULL &amp;&amp; key != root-&gt;key ) {        if ( key &lt; root-&gt;key )            root = root-&gt;left;        else            root = root-&gt;right;    }    return root;}avlTreeNode *tree_minimum(    avlTreeNode *root ){    while ( root-&gt;left != NULL ) {        root = root-&gt;left;    }    return root;}avlTreeNode *tree_maximum(    avlTreeNode *root ){    while ( root-&gt;right != NULL ) {        root = root-&gt;right;    }    return root;}int node_height(    avlTreeNode *node ){    if ( node == NULL )        return 0;    return node-&gt;height;}int tree_height(    avlTree *tree ){    return node_height( tree-&gt;root );}avlTreeNode *left_rotate(    avlTreeNode *node ){    if ( node != NULL &amp;&amp; node-&gt;right != NULL ) {        avlTreeNode *p = node-&gt;right-&gt;left;        if ( node-&gt;parent == NULL ) {            node-&gt;right-&gt;parent = NULL;        } else if ( node == node-&gt;parent-&gt;left ) {            node-&gt;parent-&gt;left = node-&gt;right;            node-&gt;right-&gt;parent = node-&gt;parent;        } else {            node-&gt;parent-&gt;right = node-&gt;right;            node-&gt;right-&gt;parent = node-&gt;parent;        }        node-&gt;parent = node-&gt;right;        node-&gt;right-&gt;left = node;        node-&gt;right = p;        if ( p != NULL )            p-&gt;parent = node;        node-&gt;height = MAX( node_height(node-&gt;left),                            node_height(node-&gt;right) ) + 1;        node-&gt;parent-&gt;height = MAX( node_height(node-&gt;parent-&gt;left),                                    node_height(node-&gt;parent-&gt;right) ) + 1;        return node-&gt;parent;    }    return node;}avlTreeNode *right_rotate(    avlTreeNode *node ){    if ( node != NULL &amp;&amp; node-&gt;left != NULL ) {        avlTreeNode *p = node-&gt;left-&gt;right;        if ( node-&gt;parent == NULL ) {            node-&gt;left-&gt;parent = NULL;        } else if ( node == node-&gt;parent-&gt;left ) {            node-&gt;parent-&gt;left = node-&gt;left;            node-&gt;left-&gt;parent = node-&gt;parent;        } else {            node-&gt;parent-&gt;right = node-&gt;left;            node-&gt;left-&gt;parent = node-&gt;parent;        }        node-&gt;parent = node-&gt;left;        node-&gt;left-&gt;right = node;        node-&gt;left = p;        if ( p != NULL )            p-&gt;parent = node;        node-&gt;height = MAX( node_height(node-&gt;left),                            node_height(node-&gt;right) ) + 1;        node-&gt;parent-&gt;height = MAX( node_height(node-&gt;parent-&gt;right),                                    node_height(node-&gt;parent-&gt;left) ) + 1;        return node-&gt;parent;    }    return node;}avlTreeNode *tree_insert1(    avlTreeNode *root,    avlTreeNode *node ){    if ( root == NULL ) {        node-&gt;height = 1;        return node;    } else if ( node-&gt;key &lt; root-&gt;key ) {        root-&gt;left = tree_insert1( root-&gt;left, node );        root-&gt;left-&gt;parent = root;        if ( node_height( root-&gt;left ) - node_height( root-&gt;right ) == 2 ) {            if ( node-&gt;key &lt; root-&gt;left-&gt;key ) {                // right rotate;                root = right_rotate( root );            } else {                // left right rotate;                root-&gt;left = left_rotate( root-&gt;left );                root = right_rotate( root );            }        }        root-&gt;height = MAX( node_height(root-&gt;left), node_height(root-&gt;right) ) + 1;    } else {        root-&gt;right = tree_insert1( root-&gt;right, node );        root-&gt;right-&gt;parent = root;        if ( node_height( root-&gt;right ) - node_height( root-&gt;left ) == 2 ) {            if ( node-&gt;key &gt;= root-&gt;right-&gt;key ) {                root = left_rotate( root );            } else {                root-&gt;right = right_rotate( root-&gt;right );                root = left_rotate( root );            }        }        root-&gt;height = MAX( node_height(root-&gt;right), node_height(root-&gt;left) ) + 1;    }    return root;}void tree_insert(    avlTree *tree,    int key ){    avlTreeNode *node = tree_create_node( key, NULL, NULL, NULL );    if ( tree-&gt;root == NULL ) {        tree-&gt;root = node;    } else {        tree-&gt;root = tree_insert1( tree-&gt;root, node );    }}avlTreeNode *tree_delete1(    avlTreeNode *root,    int key ){    if ( root == NULL )        return NULL;    if ( key &lt; root-&gt;key ) {        root-&gt;left = tree_delete1( root-&gt;left, key );        if ( node_height(root-&gt;right) - node_height(root-&gt;left) == 2 ) {            if ( node_height(root-&gt;right-&gt;left) &gt; node_height(root-&gt;right-&gt;right) ) {                root-&gt;right = right_rotate( root-&gt;right );                root = left_rotate( root );            } else {                root = left_rotate( root );            }        }    } else if ( key &gt; root-&gt;key ) {        root-&gt;right = tree_delete1( root-&gt;right, key );        if ( node_height(root-&gt;left) - node_height(root-&gt;right) == 2 ) {            if ( node_height(root-&gt;left-&gt;right) &gt; node_height(root-&gt;left-&gt;left) ) {                root-&gt;left = left_rotate( root-&gt;left );                root = right_rotate( root );            } else {                root = right_rotate( root );            }        }    } else {        if ( root-&gt;left != NULL &amp;&amp; root-&gt;right != NULL ) {            avlTreeNode *replace = NULL;            // 这里做了替换后要删除最大值结点，但匹配无法确认同key值的不同结点            // ，因此树不能有相同key值的结点，但插入没有这个问题            if ( node_height(root-&gt;left) &gt; node_height(root-&gt;right) ) {                replace = tree_maximum( root-&gt;left );                root-&gt;key = replace-&gt;key;                root-&gt;left = tree_delete1( root-&gt;left, replace-&gt;key );            } else {                replace = tree_minimum( root-&gt;right );                root-&gt;key = replace-&gt;key;                root-&gt;right = tree_delete1( root-&gt;right, replace-&gt;key );            }        } else {            avlTreeNode *delete = root;            if ( root-&gt;left ) {                root-&gt;left-&gt;parent = root-&gt;parent;                root = delete-&gt;left;            } else if ( root-&gt;right ) {                root-&gt;right-&gt;parent = root-&gt;parent;                root = delete-&gt;right;            } else {                root = NULL;            }            free( delete );        }    }    if ( root != NULL )        root-&gt;height = MAX( node_height(root-&gt;left), node_height(root-&gt;right) ) + 1;    return root;}void tree_delete(    avlTree *tree,    int key ){    if ( tree-&gt;root != NULL ) {        tree-&gt;root = tree_delete1( tree-&gt;root, key );    }}void free_tree(    avlTree *tree ){    printf(&quot;\ndelete tree node...\n&quot;);    postorder_tree_free( tree-&gt;root );    tree-&gt;root = NULL;    printf(&quot;\ndelete tree...\n&quot;);    free( tree );    printf(&quot;free tree over!\n&quot;);}int main(    int argc,    char **argv ){    srand((int)time(NULL));    int i = 10;    int len = 20;    int arr[10] = {10,4,15,14,5, 2,8,13,1,19};    avlTree *tree = ( avlTree * )malloc( sizeof(avlTree) );    int delete_key_a, delete_key_b, delete_key_c;    for ( i = 0; i &lt; len; i++ ) {        //tree_insert( tree, arr[i] );        int randomnum = random_num();        if ( i == 2 )            delete_key_a = randomnum;        if ( i == 5 )            delete_key_b = randomnum;        if ( i == 9 )            delete_key_c = randomnum;        //printf(&quot;randon num:%d\n&quot;, randomnum);        tree_insert( tree, randomnum );    }    print_tree( tree );    check_is_avltree( tree-&gt;root );    printf(&quot;删除结点%d\n&quot;, delete_key_a);    tree_delete( tree, delete_key_a );    print_tree( tree );    check_is_avltree( tree-&gt;root );    tree_delete( tree, delete_key_b );    printf(&quot;删除结点%d\n&quot;, delete_key_b );    print_tree( tree );    check_is_avltree( tree-&gt;root );    tree_delete( tree, delete_key_c );    printf(&quot;删除结点%d\n&quot;, delete_key_c );    print_tree( tree );    check_is_avltree( tree-&gt;root );    printf(&quot;\n===========================================free================================================\n&quot;);    free_tree( tree );    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;（引用算法导论）AVL树是一种高度平衡的二叉搜索树：对每一个结点x，y的左子树与右子树的高度至多为1。AVL树相比二叉搜索树，每个结点维护一个额外的属性：结点的高度。&lt;/p&gt;
&lt;p&gt;AVL树实现了几个操作：&lt;/p&gt;
&lt;h1 id=&quot;树结点创建&quot;&gt;&lt;a href=&quot;#树结点创
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://lkness/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>红黑树-《算法导论》学习笔记十二</title>
    <link href="http://lkness/2018/06/19/023red-black-tree/index/"/>
    <id>http://lkness/2018/06/19/023red-black-tree/index/</id>
    <published>2018-06-19T12:38:53.000Z</published>
    <updated>2018-06-20T04:39:52.623Z</updated>
    
    <content type="html"><![CDATA[<p>红黑树是一种二叉搜索树，它在每个结点上增加了一个存储为来表示结点的颜色，或红或黑，通过从根到叶子的简单路径上各个结点的颜色进行约束，红黑树确保没有一条路径会比其它路径长出2倍，近似平衡的。</p><p>树种每个结点包含5个属性：color、key、left、right、parent，如果一个结点没有子结点或父结点，则该结点相应指针属性值指向空（这里的空不是空指针，而是定义一个空结点，结点颜色为黑色），一颗红黑树是满足几个特殊性质的二叉搜索树：</p><ul><li>每个结点或是红色的，或是黑色的</li><li>根结点是黑色的</li><li>每个叶结点（亦即空结点）为黑色的</li><li>如果一个结点是红色的，则它的两个子结点都是黑色的</li><li>对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点（经过的黑色结点数为黑高）</li></ul><p>与二叉搜索树相似，红黑树也有一些操作接口：</p><ul><li>遍历</li><li>寻找结点中序遍历的后继:tree_minimum</li><li>寻找结点中序遍历的前驱:tree_maximum</li><li>结点左右旋转（红黑树不同于二叉搜索树的操作），用来平衡黑高<ul><li>左旋：结点的父结点的左孩子指向结点的右孩子，右孩子的左孩子变为结点的右孩子，右孩子变为它的父结点</li><li>右旋：结点的父结点的右孩子指向结点的左孩子，做孩子的右孩子变为结点的左孩子，左孩子变为它的父结点*</li></ul></li><li>插入，插入一个新结点时，考虑如果插入黑色结点，破坏了原树的红黑性质（黑高），要进行重新平衡</li><li>删除，删除了一个结点后，考虑如果删除的是黑色结点，或删除了结点，后继提升到删除节点的位置后，平衡红黑性质</li></ul><p><strong>———-插入</strong></p><ol><li><p>如果结点的父结点为黑色，表示没插入这个结点前满足红黑树<br>性质，且插入这个红色结点后，也不影响红黑树黑高，故保持当前位置</p></li><li><p>如果结点的父结点为红色，那么判断插入结点与父结点，以及父结点的<br>父结点，叔结点，这四个结点是否组成一个倒立的”v”字形：</p><p> (1). 如果是倒立”v”，则插入结点的父结点为红色，破坏了红黑树的：红<br>色结点的左右孩子都为黑色的性质，故父结点一定要变为黑色;<br>那么将父结点变为黑色;</p><p> 判断叔结点若为红色，则将叔结点变为黑色，父结点的父结点变为红色，<br>插入结点的指针指向父结点的父结点，再次从步骤1判断（因为经过变换，<br>从插入结点的父结点的父结点开始的子数都满足红黑树性质，只需要将<br>父结点的父结点单独当作一个新插入它的父结点的子结点再进行处理即可）;</p><p> 否则叔结点为黑色，则直接将父结点的父结点变为红色，但是这样做之后，<br>父结点因为变为黑色，而叔结点还是黑色，两个子树路径的黑高相差1,要<br>维持黑高相等，则将父结点的父结点的父结点向叔结点相同的方向旋转（<br>可以针对这种情况画图，会发现这样旋转后，两个黑高不一样的子树分开了，<br>，且满足红黑树性质）。</p><p> (2). 如果不是倒立”v”，即插入结点的父结点所处子树为某方向上的子树，但插入<br>结点又是父结点另一方的孩子结点，则只需要进行一下旋转，就将结点变为<br>倒立的”v”形状，继续从步骤1开始作为倒立”v”子树判断。</p></li><li><p>将根结点变为黑色</p></li></ol><p><strong>———-删除</strong></p><ol><li><p>以指针p指向待删除结点node，p_color记录node颜色</p></li><li><p>判断node的左右孩子<br> (1). 如果左孩子为空<br>寻找node的右孩子，记为q（不管是否指向空）<br>用q结点替换node结点</p><p> (2). 但如果右孩子为空<br>寻找node的左孩子，记为q（不管是否指向空）<br>用q结点替换node结点</p><p> (3). 否则左右孩子都不为空<br>寻找node的中序遍历后继(tree_minimum())，p指向它;</p><p> p_color记录后继的颜色;</p><p> q指向p的右结点（不管是否为空）;</p><p> 判断p的父结点是否为node:是，则， q的父结点设为p（只有当q为空结点时有用）/否，则，用p的右结点替换p(rb_transplant(tree, p, p-&gt;right))，用p结点接管node结点右子树（p-&gt;right = node-&gt;right, p-&gt;right-&gt;parent = p）;</p><p> 用p结点替换node结点(rb_transplant(tree, node, p));</p><p> p结点接管node结点左子树(p-&gt;left = node-&gt;left,p-&gt;left-&gt;parent = p);</p><p> p结点的颜色设置为node结点的颜色</p></li><li><p>判断p_color的颜色如果为黑色，表示删除结点后，黑高可能-1,<br>要修复红黑树，从结点q处开始修复红黑树，根据q的颜色来修复</p></li><li><p>循环.直到q结点不为根结点以及p结点的颜色不为黑色</p><p> (1). 如果node的兄弟结点为红色<br>（因为node结点替换了删除结点，黑高-1,与兄弟结点子树黑高差1）<br>设置兄弟结点为黑色，父结点设置为红色，从父结点开始向node一侧旋转，兄弟结点成为新的子树根结点，因为兄弟结点为黑色，则经过兄弟结点到node结点的子树黑高+1,平衡，但对于兄弟结点的父结点的子树，黑高又可能不平衡，node指针指向兄弟结点，继续步骤4</p><p> (2). 如果node的兄弟结点为黑色，且兄弟结点的左右孩子均为黑色<br>（因为node结点替换了删除结点，黑高-1,与兄弟结点子树黑高差1）<br>设置兄弟结点颜色为红色，兄弟结点子树黑高-1,达到平衡，但父结点以上的子树可能受影响，node指针指向父结点，继续步骤4</p><p> (3). 如果node的兄弟结点为黑色，且兄弟结点的靠近node一侧的孩子结点颜色为红色，另一侧的孩子结点为黑色<br>（因为node结点替换了删除结点，黑高-1,与兄弟结点子树黑高差1）<br>兄弟结点靠近node一侧的孩子结点设置为黑色，兄弟结点设置为红色，从兄弟结点开始进行向远离node一侧旋转，兄弟结点的孩子结点成为它的父结点，原兄弟结点的左右子树黑高不变，但node结点所处子树因为替换删除结点，黑高-1，还是没有平衡，node指针指向新的兄弟结点的孩子结点，继续4</p><p> (4). 如果node的兄弟结点为黑色，且兄弟结点的远离node一侧的孩子结点颜色为红色，另一侧颜色未知<br>（因为node结点替换了删除结点，黑高-1,与兄弟结点子树黑高差1）<br>兄弟结点设置为node父结点的颜色，父结点设置为黑色，兄弟结点为红色的设置为黑色，然后从node父结点开始进行向node一侧旋转，旋转前，可以思考，父结点若为红色，旋转后不改变子树黑高，若父结点为黑色，旋转后也不会改变黑高经过一轮变换后，node结点的父结点的父结点左右子树黑高一样，且经过node替换后-1的黑高，因为变换，又+1,本子树在整个红黑树中没有破坏黑高一致性，故将node指针指向整个树的根结点，跳出循环<br>设置node指针的结点颜色为黑色</p></li></ol><p>代码：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;//#define COLOR_RED   1;//#define COLOR_BLACK 2;typedef enum color {    COLOR_RED,    COLOR_BLACK}color;typedef struct rbTreeNode {    int key;    color color;    struct rbTreeNode *parent;    struct rbTreeNode *left;    struct rbTreeNode *right;}rbTreeNode;typedef struct rbTree {    int node_num;    int height;    rbTreeNode *root;    rbTreeNode *null;}rbTree;void print_tree( rbTree * );rbTreeNode *tree_minimum(    rbTreeNode *root,    rbTreeNode *null ){    while ( root-&gt;left != null ) {        root = root-&gt;left;    }    return root;}rbTreeNode *tree_maximum(    rbTreeNode *root,    rbTreeNode *null ){    while ( root-&gt;right != null ) {        root = root-&gt;right;    }    return root;}void left_rotate(    rbTree *tree,    rbTreeNode *node ){    rbTreeNode *p = node-&gt;right;    node-&gt;right = p-&gt;left;    if ( p-&gt;left != tree-&gt;null )        p-&gt;left-&gt;parent = node;    p-&gt;parent = node-&gt;parent;    if ( node-&gt;parent == tree-&gt;null )        tree-&gt;root = p;    else if ( node == node-&gt;parent-&gt;left )        node-&gt;parent-&gt;left = p;    else        node-&gt;parent-&gt;right = p;    p-&gt;left = node;    node-&gt;parent = p;}void right_rotate(    rbTree *tree,    rbTreeNode *node ){    rbTreeNode *p = node-&gt;left;    node-&gt;left = p-&gt;right;    if ( p-&gt;right != tree-&gt;null )        p-&gt;right-&gt;parent = node;    p-&gt;parent = node-&gt;parent;    if ( node-&gt;parent == tree-&gt;null )        tree-&gt;root = p;    else if ( node == node-&gt;parent-&gt;right )        node-&gt;parent-&gt;right = p;    else        node-&gt;parent-&gt;left = p;    p-&gt;right = node;    node-&gt;parent = p;}void rb_insert_fixup(    rbTree *tree,    rbTreeNode *node ){    rbTreeNode *p = tree-&gt;null;    while ( node-&gt;parent-&gt;color == COLOR_RED ) {        if ( node-&gt;parent == node-&gt;parent-&gt;parent-&gt;left ) {            p = node-&gt;parent-&gt;parent-&gt;right;            if ( p-&gt;color == COLOR_RED ) {                node-&gt;parent-&gt;color = COLOR_BLACK;                p-&gt;color = COLOR_BLACK;                node-&gt;parent-&gt;parent-&gt;color = COLOR_RED;                node = node-&gt;parent-&gt;parent;            } else if ( node == node-&gt;parent-&gt;right ) {                node = node-&gt;parent;                left_rotate( tree, node );            } else {                node-&gt;parent-&gt;color = COLOR_BLACK;                node-&gt;parent-&gt;parent-&gt;color = COLOR_RED;                right_rotate( tree, node-&gt;parent-&gt;parent );            }        } else {            p = node-&gt;parent-&gt;parent-&gt;left;            if ( p-&gt;color == COLOR_RED ) {                node-&gt;parent-&gt;color = COLOR_BLACK;                p-&gt;color = COLOR_BLACK;                node-&gt;parent-&gt;parent-&gt;color = COLOR_RED;                node = node-&gt;parent-&gt;parent;            } else if ( node == node-&gt;parent-&gt;left ) {                node = node-&gt;parent;                right_rotate( tree, node );            } else {                node-&gt;parent-&gt;color = COLOR_BLACK;                node-&gt;parent-&gt;parent-&gt;color = COLOR_RED;                left_rotate( tree, node-&gt;parent-&gt;parent );            }        }    }    tree-&gt;root-&gt;color = COLOR_BLACK;}void rb_insert(    rbTree *tree,    rbTreeNode *node ){    rbTreeNode *p = tree-&gt;null;    rbTreeNode *q = tree-&gt;root;    while ( q != tree-&gt;null ) {        p = q;        if ( node-&gt;key &lt; q-&gt;key )            q = q-&gt;left;        else            q = q-&gt;right;    }    node-&gt;parent = p;    if ( p == tree-&gt;null )        tree-&gt;root = node;    else if ( node-&gt;key &lt; p-&gt;key )        p-&gt;left = node;    else        p-&gt;right = node;    node-&gt;left = tree-&gt;null;    node-&gt;right = tree-&gt;null;    node-&gt;color = COLOR_RED;    rb_insert_fixup( tree, node );}void rb_transplant(    rbTree *tree,    rbTreeNode *node_a,    rbTreeNode *node_b ){    if ( node_a-&gt;parent == tree-&gt;null )        tree-&gt;root = node_b;    else if ( node_a == node_a-&gt;parent-&gt;left )        node_a-&gt;parent-&gt;left = node_b;    else        node_a-&gt;parent-&gt;right = node_b;    node_b-&gt;parent = node_a-&gt;parent;    free( node_a );}void rb_delete_fixup(    rbTree *tree,    rbTreeNode *node ){    rbTreeNode *p = tree-&gt;null;    while ( node != tree-&gt;null &amp;&amp; node-&gt;color == COLOR_BLACK ) {        if ( node == node-&gt;parent-&gt;left ) {            p = node-&gt;parent-&gt;right;            if ( p-&gt;color == COLOR_RED ) {                p-&gt;color = COLOR_BLACK;                node-&gt;parent-&gt;color = COLOR_RED;                left_rotate( tree, node-&gt;parent );                p = node-&gt;parent-&gt;right;            } else if ( p-&gt;left-&gt;color == COLOR_BLACK                &amp;&amp; p-&gt;right-&gt;color == COLOR_BLACK ) {                p-&gt;color = COLOR_RED;                node = node-&gt;parent;            } else if ( p-&gt;right-&gt;color == COLOR_BLACK ) {                p-&gt;left-&gt;color = COLOR_BLACK;                p-&gt;color = COLOR_RED;                right_rotate( tree, p );                p = node-&gt;parent-&gt;right;            } else {                p-&gt;color = node-&gt;parent-&gt;color;                node-&gt;parent-&gt;color = COLOR_BLACK;                left_rotate( tree, node-&gt;parent );                node = tree-&gt;root;            }        } else {            p = node-&gt;parent-&gt;left;            if ( p-&gt;color == COLOR_RED ) {                p-&gt;color = COLOR_BLACK;                node-&gt;parent-&gt;color = COLOR_RED;                right_rotate( tree, node-&gt;parent );                p = node-&gt;parent-&gt;left;            } else if ( p-&gt;left-&gt;color == COLOR_BLACK                &amp;&amp; p-&gt;right-&gt;color == COLOR_BLACK ) {                p-&gt;color = COLOR_RED;                node = node-&gt;parent;            } else if ( p-&gt;left-&gt;color == COLOR_BLACK ) {                p-&gt;right-&gt;color = COLOR_BLACK;                p-&gt;color = COLOR_RED;                left_rotate( tree, p );                p = node-&gt;parent-&gt;left;            } else {                p-&gt;color = node-&gt;parent-&gt;color;                node-&gt;parent-&gt;color = COLOR_BLACK;                right_rotate( tree, node-&gt;parent );                node = tree-&gt;root;            }        }    }    node-&gt;color = COLOR_BLACK;}void rb_delete(    rbTree *tree,    rbTreeNode *node ){    rbTreeNode *p = node;    rbTreeNode *q = tree-&gt;null;    color origin_color = p-&gt;color;    if ( node-&gt;left == tree-&gt;null ) {        q = node-&gt;right;        rb_transplant( tree, node, node-&gt;right );    } else if ( node-&gt;right == tree-&gt;null ) {        q = node-&gt;left;        rb_transplant( tree, node, node-&gt;left );    } else {        p = tree_minimum( node-&gt;right, tree-&gt;null );        origin_color = p-&gt;color;        q = p-&gt;right;        if ( p-&gt;parent == node )            q-&gt;parent = p;        else {            rb_transplant( tree, p, p-&gt;right );            p-&gt;right = node-&gt;right;            p-&gt;right-&gt;parent = p;        }        rb_transplant( tree, node, p );        p-&gt;left = node-&gt;left;        p-&gt;left-&gt;parent = p;        p-&gt;color = node-&gt;color;    }    if ( origin_color == COLOR_BLACK )        rb_delete_fixup( tree, q );}int random_num(){    int a = 1;    int b = 100;    return rand() % ( b - a ) + a;}void postorder_tree_free(    rbTreeNode *root,    rbTreeNode *null ){    if ( root != null ) {        postorder_tree_free( root-&gt;left, null );        postorder_tree_free( root-&gt;right, null );        free( root );    }}void inorder_tree_walk(    rbTreeNode *root,    rbTreeNode *null ){    if ( root != null ) {        inorder_tree_walk( root-&gt;left, null );        printf(&quot;%d(%d) &quot;, root-&gt;key, root-&gt;color);        inorder_tree_walk( root-&gt;right, null );    }}void preorder_tree_walk(    rbTreeNode *root,    rbTreeNode *null ){    if ( root != null ) {        printf(&quot;%d(%d) &quot;, root-&gt;key, root-&gt;color);        preorder_tree_walk( root-&gt;left, null );        preorder_tree_walk( root-&gt;right, null );    }}void postorder_tree_walk(    rbTreeNode *root,    rbTreeNode *null ){    if ( root != null ) {        postorder_tree_walk( root-&gt;left, null );        postorder_tree_walk( root-&gt;right, null );        printf(&quot;%d(%d) &quot;, root-&gt;key, root-&gt;color);    }}void print_tree(    rbTree *tree ){    printf(&quot;中序:&quot;);    inorder_tree_walk( tree-&gt;root, tree-&gt;null );    printf(&quot;\n&quot;);    printf(&quot;前序:&quot;);    preorder_tree_walk( tree-&gt;root, tree-&gt;null );    printf(&quot;\n&quot;);    printf(&quot;后序:&quot;);    postorder_tree_walk( tree-&gt;root, tree-&gt;null );    printf(&quot;\n\n&quot;);}rbTreeNode *tree_search_recursion(    rbTreeNode *root,    int key,    rbTreeNode *null){    if ( root == null || key == root-&gt;key ) {        return root;    }    if ( key &lt; root-&gt;key )        return tree_search_recursion( root-&gt;left, key, null );    else        return tree_search_recursion( root-&gt;right, key, null );}rbTreeNode *tree_search(    rbTreeNode *root,    int key,    rbTreeNode *null ){    while ( root != null &amp;&amp; key != root-&gt;key ) {        if ( key &lt; root-&gt;key )            root = root-&gt;left;        else            root = root-&gt;right;    }    return root;}// 找前驱 即中序遍历的前一个位置值rbTreeNode *tree_predecessor(    rbTreeNode *node,    rbTreeNode *null ){    if ( node-&gt;left != null )        return tree_maximum( node-&gt;left, null );    rbTreeNode *p = node-&gt;parent;    while ( p != null &amp;&amp; node == p-&gt;left ) {        node = p;        p = p-&gt;parent;    }    return p;}// 找后继 即中序遍历的后一个位置值rbTreeNode *tree_successor(    rbTreeNode *node,    rbTreeNode *null ){    if ( node-&gt;right != null )        return tree_minimum( node-&gt;right, null );    rbTreeNode *p = node-&gt;parent;    while ( p != null &amp;&amp; node == p-&gt;right ) {        node = p;        p = p-&gt;parent;    }    return p;}void free_tree(    rbTree *tree ){    rbTreeNode *root = tree-&gt;root;    postorder_tree_free( root, tree-&gt;null );    free( tree );}int main(    int argc,    char **argv ){    srand((int)time(NULL));    int i = 10;    int len = 10;    int arr[10] = {10,4,15,14,5, 2,8,13,1,19};    rbTree *tree = ( rbTree * )malloc( sizeof(rbTree) );    tree-&gt;node_num = 0;    tree-&gt;height = 0;    tree-&gt;null = ( rbTreeNode * )malloc( sizeof(rbTreeNode) );    tree-&gt;null-&gt;color = COLOR_BLACK;    tree-&gt;root = tree-&gt;null;    for ( i = 0; i &lt; len; i++ ) {        rbTreeNode *node =            ( rbTreeNode * )malloc( sizeof(rbTreeNode) );        //node-&gt;key = random_num();        node-&gt;key = arr[i];        node-&gt;parent = tree-&gt;null;        node-&gt;left = tree-&gt;null;        node-&gt;right = tree-&gt;null;        rb_insert( tree, node );        printf(&quot;insert %d successfully\n&quot;, arr[i]);    }    print_tree( tree );    rbTreeNode *delete_node = tree_search( tree-&gt;root, 4, tree-&gt;null );    if ( delete_node != tree-&gt;null ) {        rb_delete( tree, delete_node );    }    printf(&quot;\n删除%d的节点后遍历顺序为:\n&quot;, 4);    print_tree( tree );    printf(&quot;\n&quot;);    delete_node = tree_search( tree-&gt;root, 15, tree-&gt;null );    if ( delete_node != tree-&gt;null ) {        rb_delete( tree, delete_node );    }    printf(&quot;\n删除%d的节点后中序遍历顺序为:\n&quot;, 15);    print_tree( tree );    printf(&quot;\n&quot;);    free_tree( tree );    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;红黑树是一种二叉搜索树，它在每个结点上增加了一个存储为来表示结点的颜色，或红或黑，通过从根到叶子的简单路径上各个结点的颜色进行约束，红黑树确保没有一条路径会比其它路径长出2倍，近似平衡的。&lt;/p&gt;
&lt;p&gt;树种每个结点包含5个属性：color、key、left、right、p
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://lkness/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树-《算法导论》学习笔记十一</title>
    <link href="http://lkness/2018/06/19/022bin-search-tree/index/"/>
    <id>http://lkness/2018/06/19/022bin-search-tree/index/</id>
    <published>2018-06-19T12:36:13.000Z</published>
    <updated>2018-06-19T12:38:27.885Z</updated>
    
    <content type="html"><![CDATA[<p>二叉搜索树是以一颗二叉树来组织的，每个节点除数据外，还包括三个分别指向父结点、左孩子、右孩子的指针，二叉搜索树有个特性：某个结点root的左子树的某个节点x的关键值小于等于root结点右子树某个结点y的关键值。</p><p>二叉搜索树有几个操作：</p><p><strong>1、查找</strong></p><p>查找与给定关键值相等的结点</p><p><strong>2、遍历</strong></p><p>前序、中序、后序遍历输出</p><p><strong>3、从某结点出发，寻找子树中最小关键值的结点</strong></p><p><strong>4、从某结点出发，寻找子树中最大关键值的结点</strong></p><p><strong>5、以某种遍历方式的次数，寻找某结点的前驱结点和后继结点</strong></p><p>例如中序遍历的顺序为123456，则4结点的前驱为3，后继为5</p><p><strong>6、插入结点</strong></p><p><strong>7、删除结点</strong></p><p>删除某个结点后，要把它的后继结点补在删除的位置上，要注意：</p><ul><li>如果结点没有孩子结点，那么只是简单地将它删除，并删改它的父结点的孩子指针指向它</li><li><p>如果结点只有一个孩子，那么将它孩子提升到它的位置，并修改它的父结点的孩子指针指向它</p></li><li><p>如果节点有两个孩子，那么寻找它的后继（按中序遍历来说一定在右子树），并让后继占据它的位置，后继（按中序遍历来说一定没有左子树）的子树提升到后继的位置</p></li><li><p>情况如上，具体删除时如何替换，又有不同情况：</p></li><li><p>如果结点只有左或孩子，用孩子替换结点</p></li><li>如果结点有左右两个孩子，那么要查找结点的后继：(1)、如果后继是结点的右孩子，用后继替换结点，并留下后继的右孩子；(2)、后继位于结点的右子树，但并不是结点的右孩子，则，先用后继的右孩子替换后继，再用后继替换结点</li></ul><p>代码：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;typedef struct biSearchTreeNode {    int key;    struct biSearchTreeNode *parent;    struct biSearchTreeNode *left;    struct biSearchTreeNode *right;}biSearchTreeNode;typedef struct biSearchTree {    int node_num;    int height;    biSearchTreeNode *root;}biSearchTree;int random_num(){    int a = 1;    int b = 100;    return rand() % ( b - a ) + a;}void postorder_tree_free(    biSearchTreeNode *root ){    if ( root != NULL ) {        postorder_tree_free( root-&gt;left );        postorder_tree_free( root-&gt;right );        free( root );    }}void inorder_tree_walk(    biSearchTreeNode *root ){    if ( root != NULL ) {        inorder_tree_walk( root-&gt;left );        printf(&quot;%d &quot;, root-&gt;key);        inorder_tree_walk( root-&gt;right );    }}void preorder_tree_walk(    biSearchTreeNode *root ){    if ( root != NULL ) {        printf(&quot;%d &quot;, root-&gt;key);        preorder_tree_walk( root-&gt;left );        preorder_tree_walk( root-&gt;right );    }}void postorder_tree_walk(    biSearchTreeNode *root ){    if ( root != NULL ) {        postorder_tree_walk( root-&gt;left );        postorder_tree_walk( root-&gt;right );        printf(&quot;%d &quot;, root-&gt;key);    }}void print_tree(    biSearchTree *tree ){    printf(&quot;中序:&quot;);    inorder_tree_walk( tree-&gt;root );    printf(&quot;\n&quot;);    printf(&quot;前序:&quot;);    preorder_tree_walk( tree-&gt;root );    printf(&quot;\n&quot;);    printf(&quot;后序:&quot;);    postorder_tree_walk( tree-&gt;root );    printf(&quot;\n\n&quot;);}biSearchTreeNode *tree_search_recursion(    biSearchTreeNode *root,    int key ){    if ( root == NULL || key == root-&gt;key ) {        return root;    }    if ( key &lt; root-&gt;key )        return tree_search_recursion( root-&gt;left, key );    else        return tree_search_recursion( root-&gt;right, key );}biSearchTreeNode *tree_search(    biSearchTreeNode *root,    int key ){    while ( root != NULL &amp;&amp; key != root-&gt;key ) {        if ( key &lt; root-&gt;key )            root = root-&gt;left;        else            root = root-&gt;right;    }    return root;}biSearchTreeNode *tree_minimum(    biSearchTreeNode *root ){    while ( root-&gt;left != NULL ) {        root = root-&gt;left;    }    return root;}biSearchTreeNode *tree_maximum(    biSearchTreeNode *root ){    while ( root-&gt;right != NULL ) {        root = root-&gt;right;    }    return root;}// 找前驱 即中序遍历的前一个位置值biSearchTreeNode *tree_predecessor(    biSearchTreeNode *node ){    if ( node-&gt;left != NULL )        return tree_maximum( node-&gt;left );    biSearchTreeNode *p = node-&gt;parent;    while ( p != NULL &amp;&amp; node == p-&gt;left ) {        node = p;        p = p-&gt;parent;    }    return p;}// 找后继 即中序遍历的后一个位置值biSearchTreeNode *tree_successor(    biSearchTreeNode *node ){    if ( node-&gt;right != NULL )        return tree_minimum( node-&gt;right );    biSearchTreeNode *p = node-&gt;parent;    while ( p != NULL &amp;&amp; node == p-&gt;right ) {        node = p;        p = p-&gt;parent;    }    return p;}void tree_insert(    biSearchTree *tree,    biSearchTreeNode *node ){    biSearchTreeNode *root = tree-&gt;root;    biSearchTreeNode *p = NULL;    biSearchTreeNode *q = root;    while ( q != NULL ) {        p = q;        if ( node-&gt;key &lt; q-&gt;key )            q = q-&gt;left;        else            q = q-&gt;right;    }    node-&gt;parent = p;    if ( p == NULL ) {        tree-&gt;root = node;    }    else if ( node-&gt;key &lt; p-&gt;key )        p-&gt;left = node;    else        p-&gt;right = node;}void transplant(    biSearchTree *tree,    biSearchTreeNode *node_a,    biSearchTreeNode *node_b ){    if ( node_a-&gt;parent == NULL )        tree-&gt;root = node_b;    else if ( node_a == node_a-&gt;parent-&gt;left )        node_a-&gt;parent-&gt;left = node_b;    else        node_a-&gt;parent-&gt;right = node_b;    if ( node_b != NULL )        node_b-&gt;parent = node_a-&gt;parent;}void tree_delete(    biSearchTree *tree,    biSearchTreeNode *node ){    if ( node-&gt;left == NULL )        transplant( tree, node, node-&gt;right );    else if ( node-&gt;right == NULL )        transplant( tree, node, node-&gt;left );    else {        biSearchTreeNode *p = tree_minimum( node-&gt;right );        if ( p-&gt;parent != node ) {            transplant( tree, p, p-&gt;right );            p-&gt;right = node-&gt;right;            p-&gt;right-&gt;parent = p;        }        transplant( tree, node, p );        p-&gt;left = node-&gt;left;        p-&gt;left-&gt;parent = p;    }    free( node );}void free_tree(    biSearchTree *tree ){    biSearchTreeNode *root = tree-&gt;root;    postorder_tree_free( root );    free( tree );}int main(    int argc,    char **argv ){    srand((int)time(NULL));    int i = 10;    int len = 10;    int arr[10] = {10,4,15,14,5, 2,8,13,1,19};    biSearchTree *tree = ( biSearchTree * )malloc( sizeof(biSearchTree) );    tree-&gt;node_num = 0;    tree-&gt;height = 0;    for ( i = 0; i &lt; len; i++ ) {        biSearchTreeNode *node =            ( biSearchTreeNode * )malloc( sizeof(biSearchTreeNode) );        //node-&gt;key = random_num();        node-&gt;key = arr[i];        node-&gt;parent = NULL;        node-&gt;left = NULL;        node-&gt;right = NULL;        tree_insert( tree, node );    }    print_tree( tree );    for ( i = 0; i &lt; len; i++ ) {        biSearchTreeNode *pre = tree_predecessor( tree_search(tree-&gt;root, arr[i]) );        biSearchTreeNode *post = tree_successor( tree_search(tree-&gt;root, arr[i]) );        printf(&quot;\n&quot;);        if ( pre != NULL )            printf(&quot;查找%d的中序遍历前驱为:%d\n&quot;, arr[i], pre-&gt;key);        else            printf(&quot;查找%d的中序遍历前驱为空！\n&quot;, arr[i]);        if ( post != NULL )            printf(&quot;查找%d的中序遍历后继为:%d\n&quot;, arr[i], post-&gt;key);        else            printf(&quot;查找%d的中序遍历后继为空！\n&quot;, arr[i]);    }    biSearchTreeNode *delete_node = tree_search( tree-&gt;root, 4 );    if ( delete_node != NULL ) {        tree_delete( tree, delete_node );    }    printf(&quot;\n删除%d的节点后中序遍历顺序为:&quot;, 4);    inorder_tree_walk( tree-&gt;root );    printf(&quot;\n&quot;);    delete_node = tree_search( tree-&gt;root, 15 );    if ( delete_node != NULL ) {        tree_delete( tree, delete_node );    }    printf(&quot;\n删除%d的节点后中序遍历顺序为:&quot;, 15);    inorder_tree_walk( tree-&gt;root );    printf(&quot;\n&quot;);    free_tree( tree );    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;二叉搜索树是以一颗二叉树来组织的，每个节点除数据外，还包括三个分别指向父结点、左孩子、右孩子的指针，二叉搜索树有个特性：某个结点root的左子树的某个节点x的关键值小于等于root结点右子树某个结点y的关键值。&lt;/p&gt;
&lt;p&gt;二叉搜索树有几个操作：&lt;/p&gt;
&lt;p&gt;&lt;stro
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://lkness/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>查找数组第i小的数-《算法导论》学习笔记十</title>
    <link href="http://lkness/2018/06/19/021search-min-i/index/"/>
    <id>http://lkness/2018/06/19/021search-min-i/index/</id>
    <published>2018-06-19T12:32:13.000Z</published>
    <updated>2018-06-19T12:35:17.286Z</updated>
    
    <content type="html"><![CDATA[<p>查找第i小的数利用了快速排序的一点思想，即以数组某个值作为比较值，然后遍历数组中除这个数以外的数，小于它的就放左边，大于它的放右边，然后作为比较值的数放中间，并返回比较值的下标，如果下标等于i，表示就找到了，如果下标大于i，又再次从大于此下标的数组递归进行此过程，同理，小于i就从小于此下标的数组递归进行此过程，代码：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int partition( int *arr, int p, int r ){    int x = arr[r];    int i = p - 1;    int j = 0;    int temp = 0;    for ( j = p; j &lt; r; j++ ) {        if ( arr[j] &lt;= x ) {            i += 1;            temp = arr[i];            arr[i] = arr[j];            arr[j] = temp;        }    }    temp = arr[i + 1];    arr[i + 1] = arr[r];    arr[r] = temp;    return i + 1;}int randomized_partition( int *arr, int p, int r ){    int i = rand() % (r - p) + p;    int temp = arr[r];    arr[r] = arr[i];    arr[i] = temp;    return partition( arr, p, r );}int randomized_select(    int *arr,    int p,    int r,    int i ){    if ( p == r )        return arr[p];    int q = 0, k = 0;    q = randomized_partition( arr, p, r );    k = q - p + 1;    if ( i == k )        return arr[q];    else if ( i &lt; k )        return randomized_select( arr, p, q - 1, i );    else        return randomized_select( arr, q + 1, r, i - k );}int main(){    int arr[10] = {1,2,3,4,5,6,7,8,9,10};    int len = 10;    int i = 8;    printf(&quot;第%d小的数是:%d\n&quot;, i, randomized_select(arr, 0, 9, i));    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;查找第i小的数利用了快速排序的一点思想，即以数组某个值作为比较值，然后遍历数组中除这个数以外的数，小于它的就放左边，大于它的放右边，然后作为比较值的数放中间，并返回比较值的下标，如果下标等于i，表示就找到了，如果下标大于i，又再次从大于此下标的数组递归进行此过程，同理，小于
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://lkness/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>桶排序-《算法导论》学习笔记九</title>
    <link href="http://lkness/2018/06/19/020bucket-sort/index/"/>
    <id>http://lkness/2018/06/19/020bucket-sort/index/</id>
    <published>2018-06-19T12:28:14.000Z</published>
    <updated>2018-06-19T12:29:00.827Z</updated>
    
    <content type="html"><![CDATA[<p>桶排序要求数据均匀、独立分布在某个区间上，然后将待排序值按某个区间划分为几个区间数组，然后将待排序的数按这个区间划分公式有序放入对应桶中，这样放完之后再按顺序从桶中拿出来一个一个放入原数组。<br>c代码桶可以用链表，如待排序数组的值为0-99，那么桶可以划分为0-9、10-19、20-29…..，这样就得到了10个桶数组链表，然后遍历待排序的数组，将值/10后以链表插入排序方式放入对应桶链表中（就像打扑克一样从前往后遍历，能插入就插入），待所有数遍历完后，就得到了桶数据了，然后再排序0-9的桶，每个桶做链表遍历取数据，直接从数组0开始插入到待排序数组，代码：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;//#define DEBUGtypedef struct bucket_data {    int no;    struct bucket_data *next;} bucket_data;void sort_insert( bucket_data *, int );void bucket_sort( int *arr, int len ){    bucket_data *tmp_arr = ( bucket_data * )malloc( sizeof(bucket_data) * 10 );    int i = 0, count = 0;    //初始化链表头数组    for ( i = 0; i &lt; 10; i++ ) {        tmp_arr[i].next = NULL;    }    //遍历数据并有序插入到相应链表中    for ( i = 0; i &lt; len; i++ ) {        sort_insert( &amp;tmp_arr[arr[i] / 10], arr[i] );    }    //从链表中取数据到数组    count = 0;    for ( i = 0; i &lt; 10; i++ ) {        bucket_data *p = tmp_arr[i].next;        bucket_data *free_p = NULL;        #ifdef DEBUG            printf(&quot;bucket[%d]:\n&quot;, i);        #endif        while( p != NULL ) {        #ifdef DEBUG            printf(&quot;%d &quot;, p-&gt;no);        #endif            free_p = p;            arr[count] = p-&gt;no;            count++;            p = p-&gt;next;            free( free_p );        }        #ifdef DEBUG            printf(&quot;\n&quot;);        #endif    }    free( tmp_arr );}void sort_insert( bucket_data *head, int no ){    bucket_data *p = head;    bucket_data *data = ( bucket_data * )malloc( sizeof(bucket_data) );    data-&gt;no = no;    data-&gt;next = NULL;    while ( p != NULL &amp;&amp; p-&gt;next != NULL ) {        if ( p-&gt;next-&gt;no &gt;= no ) {            data-&gt;next = p-&gt;next;            p-&gt;next = data;            break;        }        p = p-&gt;next;    }    if ( p-&gt;next == NULL ) {        p-&gt;next = data;    }}void check_is_inc_arr(    int *arr,    int len ){    int i = 0;    for ( i = 0; i &lt; len; i++ ) {        if ( arr[i] &lt; arr[i - 1] ) {            printf(&quot;check_is_inc_arr fail.\n&quot;);            return;        }    }}//初始化随机数组void initArr( int *arr, int lowV,    int upV, int len ){    int i = 0;    int size = upV - lowV;    for ( i = 0; i &lt; len; i++ )    {        arr[i] = rand() % size + lowV;    }}void print_arr(    int *arr,    int len ){    int i = 0;    printf(&quot;\n=============================================\n&quot;);    for ( i = 0; i &lt; len; i++ ) {        printf(&quot;%d &quot;, arr[i]);    }    printf(&quot;\n=============================================\n&quot;);}int main(    int argc,    char **argv ){    if ( argc != 4 ) {        printf(&quot;input array length and the random value range.\n&quot;);        exit( 0 );    }    srand( (int)time(NULL) );    int length = atoi( argv[1] );    int lowV = atoi( argv[2] );    int upV = atoi( argv[3] );    int *arr = ( int * )malloc( sizeof(int) * (length) );    int i = 1000;    for ( ; i &gt; 0; i-- ) {        initArr( arr, lowV, upV, length );        //print_arr( arr, length );        bucket_sort( arr, length );        //print_arr( arr, length );        check_is_inc_arr( arr, length );    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;桶排序要求数据均匀、独立分布在某个区间上，然后将待排序值按某个区间划分为几个区间数组，然后将待排序的数按这个区间划分公式有序放入对应桶中，这样放完之后再按顺序从桶中拿出来一个一个放入原数组。&lt;br&gt;c代码桶可以用链表，如待排序数组的值为0-99，那么桶可以划分为0-9、10
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://lkness/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计数排序-《算法导论》学习笔记八</title>
    <link href="http://lkness/2018/06/19/019count-sort/index/"/>
    <id>http://lkness/2018/06/19/019count-sort/index/</id>
    <published>2018-06-19T12:27:08.000Z</published>
    <updated>2018-06-19T12:27:51.135Z</updated>
    
    <content type="html"><![CDATA[<p>计数排序：假设n个输入元素中的每一个都是在0-k区间内的一个整数(k为正整数)，对每一个输入元素x，确定小于x的元素个数，用一个0-k长度的数组做记录，例如输入数组的数为0-10长度，随机出[2,5,3,0,2,3,0,3]，可以计算出一个0-10的数组，分别表示小于等于x的数的个数，于是有：0-&gt;2,1-&gt;2,2-&gt;4,3-&gt;7,4-&gt;7,5-&gt;8,6-&gt;8,7-&gt;8,9-&gt;8,10-&gt;8，然后再倒序遍历待排序数组，根据值去0-10数组取索引，然后将数组值放入一个新的等长数组那个索引处，取过的索引值要减一，这是为了下次再取到相同值不会放在同一位置，代码：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;void counting_sort(    int *in_arr,    int *out_arr,    int arr_len,    int k ){    int *tmp_arr = ( int * )malloc( sizeof(int) * (k + 1) );    int i = 0, j = 0;    for ( i = 0; i &lt; k; i++ ) {        tmp_arr[i]  = 0;    }    for ( j = 0; j &lt; arr_len; j++ ) {        tmp_arr[in_arr[j]] = tmp_arr[in_arr[j]] + 1;    }    for ( i = 1; i &lt; k + 1; i++ ) {        tmp_arr[i] = tmp_arr[i] + tmp_arr[i - 1];    }    for ( j = arr_len - 1; j &gt;= 0; j-- ) {        //printf(&quot;j:%d, in_arr[j]:%d, tmp_arr[in_arr[j]]:%d\n&quot;,        //  j, in_arr[j], tmp_arr[in_arr[j]]);        out_arr[tmp_arr[in_arr[j]] - 1] = in_arr[j];        tmp_arr[in_arr[j]] = tmp_arr[in_arr[j]] - 1;    }    free( tmp_arr );}void check_is_inc_arr(    int *arr,    int len ){    int i = 0;    for ( i = 0; i &lt; len; i++ ) {        if ( arr[i] &lt; arr[i - 1] ) {            printf(&quot;check_is_inc_arr fail.\n&quot;);            return;        }    }}//初始化随机数组void initArr( int *arr, int lowV,    int upV, int len ){    int i = 0;    int size = upV - lowV;    for ( i = 0; i &lt; len; i++ )    {        arr[i] = rand() % size + lowV;    }}void print_arr(    int *arr,    int len ){    int i = 0;    printf(&quot;\n=============================================\n&quot;);    for ( i = 0; i &lt; len; i++ ) {        printf(&quot;%d &quot;, arr[i]);    }    printf(&quot;\n=============================================\n&quot;);}int main(    int argc,    char **argv ){    if ( argc != 4 ) {        printf(&quot;input array length and the random value range.\n&quot;);        exit( 0 );    }    srand( (int)time(NULL) );    int length = atoi( argv[1] );    int lowV = atoi( argv[2] );    int upV = atoi( argv[3] );    int *arr = ( int * )malloc( sizeof(int) * (length) );    int *new_arr = ( int * )malloc( sizeof(int) * length );    int i = 1000;    for ( ; i &gt; 0; i-- ) {        initArr( arr, lowV, upV, length );        //print_arr( arr, length );        counting_sort( arr, new_arr, length, upV );        //print_arr( new_arr, length );        check_is_inc_arr( new_arr, length );    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计数排序：假设n个输入元素中的每一个都是在0-k区间内的一个整数(k为正整数)，对每一个输入元素x，确定小于x的元素个数，用一个0-k长度的数组做记录，例如输入数组的数为0-10长度，随机出[2,5,3,0,2,3,0,3]，可以计算出一个0-10的数组，分别表示小于等于x
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://lkness/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>快速排序-《算法导论》学习笔记七</title>
    <link href="http://lkness/2018/06/19/018quick-sort/index/"/>
    <id>http://lkness/2018/06/19/018quick-sort/index/</id>
    <published>2018-06-19T12:24:39.000Z</published>
    <updated>2018-06-19T12:26:47.543Z</updated>
    
    <content type="html"><![CDATA[<p>快排利用分治的思想，将问题规模切分为小的子规模问题，类似归并排序，归并是将两个待排序的子数组合并为一个有序的数组，而快排是将数组以某个数组值划分为两个子数组，一个数组的所有数比这个值小，一个数组的所有数比这个值大，然后再递归地对两个子数组再以某个数组值做切分和交换：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;int partition( int *arr, int p, int r ){    int x = arr[r];    int i = p - 1;    int j = 0;    int temp = 0;    for ( j = p; j &lt; r; j++ ) {        if ( arr[j] &lt;= x ) {            i += 1;            temp = arr[i];            arr[i] = arr[j];            arr[j] = temp;        }    }    temp = arr[i + 1];    arr[i + 1] = arr[r];    arr[r] = temp;    return i + 1;}void quick_sort( int *arr, int p, int r ){    int q = 0;    if ( p &lt; r ) {        q = partition( arr, p, r );        //printf(&quot;p-&gt;%d, q-&gt;%d, r-&gt;%d\n&quot;, p, q, r);        quick_sort( arr, p, q - 1 );        quick_sort( arr, q + 1, r );    }}void check_is_inc_arr(    int *arr,    int len ){    int i = 0;    for ( i = 0; i &lt; len; i++ ) {        if ( arr[i] &lt; arr[i - 1] ) {            printf(&quot;check_is_inc_arr fail.\n&quot;);            return;        }    }}//初始化随机数组void initArr( int *arr, int lowV,    int upV, int len ){    int i = 0;    int size = upV - lowV;    for ( i = 0; i &lt; len; i++ )    {        arr[i] = rand() % size + lowV;    }}void print_arr(    int *arr,    int len ){    int i = 0;    printf(&quot;\n=============================================\n&quot;);    for ( i = 0; i &lt; len; i++ ) {        printf(&quot;%d &quot;, arr[i]);    }    printf(&quot;\n=============================================\n&quot;);}int main(    int argc,    char **argv ){    if ( argc != 4 ) {        printf(&quot;input array length and the random value range.\n&quot;);        exit( 0 );    }    srand( (int)time(NULL) );    int length = atoi( argv[1] );    int lowV = atoi( argv[2] );    int upV = atoi( argv[3] );    int *arr = ( int * )malloc( sizeof(int) * (length) );    initArr( arr, lowV, upV, length );    print_arr( arr, length );    quick_sort( arr, 0, length - 1 );    print_arr( arr, length );    check_is_inc_arr( arr, length );    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;快排利用分治的思想，将问题规模切分为小的子规模问题，类似归并排序，归并是将两个待排序的子数组合并为一个有序的数组，而快排是将数组以某个数组值划分为两个子数组，一个数组的所有数比这个值小，一个数组的所有数比这个值大，然后再递归地对两个子数组再以某个数组值做切分和交换：&lt;/p&gt;
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://lkness/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>erlang的终端带颜色输出与中文字符串输出</title>
    <link href="http://lkness/2018/06/19/017erlang-shell-color/index/"/>
    <id>http://lkness/2018/06/19/017erlang-shell-color/index/</id>
    <published>2018-06-19T12:19:59.000Z</published>
    <updated>2018-06-19T12:21:25.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-带颜色输出"><a href="#1-带颜色输出" class="headerlink" title="1.带颜色输出"></a>1.带颜色输出</h1><p>erlang终端支持带颜色输出，例如lager日志库就可以。其实就是在输出前设置一下输出属性，正常的字体是：”\e[0;38m”<br>下面自己弄了一些宏：</p><pre><code>-define(CONSOLE_COLOR_RED,      &quot;\e[0;31m&quot;).-define(CONSOLE_COLOR_RED_BOLD, &quot;\e[1;31m&quot;).-define(CONSOLE_COLOR_YELLOW1,  &quot;\e[0;32m&quot;).-define(CONSOLE_COLOR_YELLOW2,  &quot;\e[0;33m&quot;).-define(CONSOLE_COLOR_BLUE,     &quot;\e[0;34m&quot;).-define(CONSOLE_COLOR_PURPLE,   &quot;\e[0;35m&quot;).-define(CONSOLE_COLOR_GREEN,    &quot;\e[0;36m&quot;).-define(CONSOLE_COLOR_GRAY,     &quot;\e[0;37m&quot;).-define(CONSOLE_COLOR_NORMAL,   &quot;\e[0;38m&quot;).</code></pre><p>用法就是打印的字符串前后加上要设置的属性例如<br><code>io:format(“~s~s~s~n”, [“\e[0;31m”, debug, “\e[0;38m”]).</code><br>就是在输出debug之前设置字体为红色，然后输出结束后设置字体为正常白色。</p><h1 id="2-中文输出"><a href="#2-中文输出" class="headerlink" title="2.中文输出"></a>2.中文输出</h1><p>中文输出乱码在rebar3插件里用rebar_info输出以及在ct里用io:format(user, ….)输出会遇到，带中文的字符串要转为utf8，代码形如：</p><pre><code>NewFormat = io_lib:format(Format, Args),io:format(&quot;~s&quot;, [unicode:characters_to_binary(NewFormat, utf8)]).</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-带颜色输出&quot;&gt;&lt;a href=&quot;#1-带颜色输出&quot; class=&quot;headerlink&quot; title=&quot;1.带颜色输出&quot;&gt;&lt;/a&gt;1.带颜色输出&lt;/h1&gt;&lt;p&gt;erlang终端支持带颜色输出，例如lager日志库就可以。其实就是在输出前设置一下输出属性，正常的
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Erlang" scheme="http://lkness/tags/Erlang/"/>
    
  </entry>
  
  <entry>
    <title>堆排序-《算法导论》学习笔记六</title>
    <link href="http://lkness/2018/06/19/016heap-sort/index/"/>
    <id>http://lkness/2018/06/19/016heap-sort/index/</id>
    <published>2018-06-19T12:18:42.000Z</published>
    <updated>2018-06-19T12:19:36.767Z</updated>
    
    <content type="html"><![CDATA[<p>堆排序就是将一组数按二叉树层序遍历的存储顺序，经过一系列比较转移，最终变成有序的数组，这里的二叉树堆一定是完全二叉树。堆排序能进行的基础是有个最大堆的数组，最大堆性质是指树上的每个节点的子节点都比自己小或等于。<br>因此最顶上的根节点一定是值最大的节点，有了最大堆在，堆排序就可以进行了，从层序遍历的最后一个节点开始倒序循环，交换当前节点与最顶层根节点，即最大值的节点，这样每次最大的节点都被放在层序遍历的最后位置，类似冒泡排序了，而放了最大值的节点即从堆中排除（只要堆长度减一即表示堆没有这个节点了），交换到顶点根节点的值再做一次下滤操作（以这个节点值与子树的最大值交换），保证剩余子树一定也是最大堆性质。<br>贴代码：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;int parent( int );int left( int );int right( int );inline int parent( int index ){    return index / 2;}inline int left( int index ){    return index * 2;}inline int right( int index ){    return index * 2 + 1;}//下滤void max_heapify(    int *arr,    int heap_size,    int index ){    int l = left( index );    int r = right( index );    int largest = 0;    if ( l &lt;= heap_size &amp;&amp; arr[l] &gt; arr[index] ) {        largest = l;    } else {        largest = index;    }    if ( r &lt;= heap_size &amp;&amp; arr[r] &gt; arr[largest] ) {        largest = r;    }    if ( largest != index ) {        int temp = arr[index];        arr[index] = arr[largest];        arr[largest] = temp;        max_heapify( arr, heap_size, largest );    }}//构建最大堆void build_max_heap(    int *arr,    int length,    int heap_size ){    int i = 0;    for ( i = length / 2; i &gt;= 1; i-- ) {        max_heapify( arr, heap_size, i );    }}//开始堆排序void heap_sort(    int *arr,    int length,    int heap_size ){    int i = 0;    build_max_heap( arr, length, heap_size );    for ( i = heap_size; i &gt;= 2; i-- ) {        int temp = arr[1];        arr[1] = arr[i];        arr[i] = temp;        heap_size -= 1;        max_heapify( arr, heap_size, 1 );    }}void check_is_inc_arr(    int *arr,    int len ){    int i = 0;    for ( i = 1; i &lt;= len; i++ ) {        if ( arr[i] &lt; arr[i - 1] ) {            printf(&quot;check_is_inc_arr fail.\n&quot;);            return;        }    }    printf(&quot;check_is_inc_arr ok.\n&quot;);}//初始化随机数组void initArr( int *arr, int lowV,    int upV, int len ){    int i = 0;    int size = upV - lowV;    for ( i = 1; i &lt; len + 1; i++ )    {        arr[i] = rand() % size + lowV;    }    arr[0] = 0;}void print_arr(    int *arr,    int len ){    int i = 0;    printf(&quot;\n=============================================\n&quot;);    for ( i = 0; i &lt;= len; i++ ) {        printf(&quot;%d &quot;, arr[i]);    }    printf(&quot;\n=============================================\n&quot;);}int main(    int argc,    char **argv ){    if ( argc != 4 ) {        printf(&quot;input array length and the random value range.\n&quot;);        exit( 0 );    }    srand( (int)time(NULL) );    int length = atoi( argv[1] );    int lowV = atoi( argv[2] );    int upV = atoi( argv[3] );    int *arr = ( int * )malloc( sizeof(int) * (length + 1) );    initArr( arr, lowV, upV, length );    //print_arr( arr, length );    heap_sort( arr, length, length );    //print_arr( arr, length );    check_is_inc_arr( arr, length );    return 0;}</code></pre><p>上面代码中因为c数组从0开始的原因，因此0位置不参与存储和运算，数据形式是{0, 2, 3, 4, 5, 6}。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;堆排序就是将一组数按二叉树层序遍历的存储顺序，经过一系列比较转移，最终变成有序的数组，这里的二叉树堆一定是完全二叉树。堆排序能进行的基础是有个最大堆的数组，最大堆性质是指树上的每个节点的子节点都比自己小或等于。&lt;br&gt;因此最顶上的根节点一定是值最大的节点，有了最大堆在，堆排
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://lkness/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>n阶矩阵一般乘法-《算法导论》学习笔记五</title>
    <link href="http://lkness/2018/06/19/015nmatrix/index/"/>
    <id>http://lkness/2018/06/19/015nmatrix/index/</id>
    <published>2018-06-19T12:16:29.000Z</published>
    <updated>2018-06-19T12:18:12.130Z</updated>
    
    <content type="html"><![CDATA[<p>A、B两个矩阵均是nxn的矩阵，则两个矩阵的乘法：</p><p><img src="/img/nmatrix1.png" alt="nmatrix1"></p><p>一般的矩阵乘法代码：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;class SquareMatrix {public:    SquareMatrix(){}    SquareMatrix( int row, int col ):        mRow(row), mCol(col)    {        Init();    }    ~SquareMatrix()    {        for ( int i = 0; i &lt; mRow; i++ ) {            delete[] mElement[i];            //printf(&quot;delete %d\n&quot;, i);        }        delete[] mElement;    }    void Init()    {        mElement = new int*[mRow];        for ( int i = 0; i &lt; mCol; i++ ) {            mElement[i] = new int[i];        }    }    void SetElement( int lowV, int upV )    {        int size = upV - lowV;        for ( int i = 0; i &lt; mRow; i++ ) {            for ( int j = 0; j &lt; mCol; j++ ) {                mElement[i][j] = rand() % size + lowV;            }        }    }    void PrintElement()    {        printf(&quot;=========================================\n&quot;);        for ( int i = 0; i &lt; mRow; i++ ) {            for ( int j = 0; j &lt; mCol; j++ ) {                printf(&quot;%d &quot;, mElement[i][j]);            }            printf(&quot;\n&quot;);        }        printf(&quot;=========================================\n&quot;);    }public:    int mRow;    int mCol;    int *(*mElement);};void SquareMatrixMultiply(    SquareMatrix &amp;a,    SquareMatrix &amp;b,    SquareMatrix &amp;c ){    int n = a.mRow;    c.mRow = c.mCol = n;    c.Init();    for ( int i = 0; i &lt; n; i++ ) {        for ( int j = 0; j &lt; n; j++ ) {            c.mElement[i][j] = 0;            for ( int k = 0; k &lt; n; k++ ) {                c.mElement[i][j] += a.mElement[i][k] * b.mElement[j][k];            }        }    }}int main( int argc, char **argv ){    if ( argc != 2 ) {        printf(&quot;Usage:./binaryfile num\n&quot;);        exit( 0 );    }    int n = atoi( argv[1] );    SquareMatrix smA( n, n ), smB( n, n ), smC;    smA.SetElement( 1, 10 );    smA.PrintElement();    smB.SetElement( 1, 10 );    smB.PrintElement();    SquareMatrixMultiply( smA, smB, smC );    smC.PrintElement();    printf(&quot;init square matrix finished\n&quot;);    return 0;}</code></pre><p>算法复杂度为O(n^3)，而Stranssen算法通过分治法将大矩阵切分为小矩阵进行计算，算法复杂度可以降低为O(n^2.81)，但是尝试写下代码，发现切割子矩阵时有点复杂，普通的切分会创建子矩阵并复制值，而用下标进行计算又比较复杂，下次有空再尝试写吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A、B两个矩阵均是nxn的矩阵，则两个矩阵的乘法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/nmatrix1.png&quot; alt=&quot;nmatrix1&quot;&gt;&lt;/p&gt;
&lt;p&gt;一般的矩阵乘法代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://lkness/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>erlang编写rebar3插件</title>
    <link href="http://lkness/2018/06/19/014rebar3-plugin/index/"/>
    <id>http://lkness/2018/06/19/014rebar3-plugin/index/</id>
    <published>2018-06-19T12:11:35.000Z</published>
    <updated>2018-06-19T12:15:54.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-生成插件工程"><a href="#1-生成插件工程" class="headerlink" title="1.生成插件工程"></a>1.生成插件工程</h1><p>假设插件名为testp，执行rebar3 new plugins testp，即生成了插件工程项目，查看目录结构如图：</p><p><img src="/img/rebar3plugin1.jpeg" alt="rebar3plugin1"></p><p>testp.erl文件调用初始化的代码，而插件最重要的代码在testp_prv.erl的文件，文件里提供了三个接口，分别为<code>init/1</code>,<code>do/1</code>,<code>format_error/1</code>，init做插件初始化的工作，初始化命名空间/初始化命令，然后将命令加入到rebar3，贴一份配置：</p><pre><code>init(State) -&gt;        Provider = providers:create([                {name, compile},            % The &apos;user friendly&apos; name of the task                {module, ?MODULE},            % The module implementation of the task                {namespace, testp},                {bare, true},                 % The task can be run by the user, always true                {deps, ?DEPS},                % The list of dependencies                {example, &quot;rebar3 testp compile&quot;}, % How to use the plugin                {opts, []},                   % list of options understood by the plugin                {short_desc, &quot;rebar3 testp compiler&quot;},                {desc, &quot;rebar3 testp compiler&quot;}        ]),        {ok, rebar_state:add_provider(State, Provider)}.</code></pre><p>这份配置就是为rebar3添加一个rebar3 testp compile命令，如果只输入<code>rebar3 testp</code>，会提示<code>rebar3 testp compiler</code>。<br>第二个方法do就是主要的业务逻辑了，执行了<code>rebar3 testp compiler</code>命令就会调用里面的do方法。<br>如果想添加多个命令，可以在testp.erl里多写一个命令的init调用，然后再添加一个命令类似的prv文件，写不同的do业务逻辑，就可以上传git，将git地址配置在rebar.config的plugins里了，rebar3 compile编译就自动拉取插件代码。<br>插件还可以配置钩子(provider_hook)使用，例如添加编译前调用<br><code>{provider_hooks,[{pre[{compile, {testp, compile}}]}]}</code>，编译后调用将pre改为post即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-生成插件工程&quot;&gt;&lt;a href=&quot;#1-生成插件工程&quot; class=&quot;headerlink&quot; title=&quot;1.生成插件工程&quot;&gt;&lt;/a&gt;1.生成插件工程&lt;/h1&gt;&lt;p&gt;假设插件名为testp，执行rebar3 new plugins testp，即生成了插件工
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Erlang" scheme="http://lkness/tags/Erlang/"/>
    
  </entry>
  
  <entry>
    <title>erlang rebar3配置文件</title>
    <link href="http://lkness/2018/06/19/013rebar3-conf/index/"/>
    <id>http://lkness/2018/06/19/013rebar3-conf/index/</id>
    <published>2018-06-19T11:59:19.000Z</published>
    <updated>2018-06-19T12:11:02.436Z</updated>
    
    <content type="html"><![CDATA[<p>rebar3的简单使用可以参考rebar3的官方文档。以下讲解一些rebar3的配置，初入erlang，理解还不甚深刻。<br>用rebar3进行工程创建，会生成rebar.config文件，贴一些配置的使用方法</p><h1 id="1-编译设置"><a href="#1-编译设置" class="headerlink" title="1.编译设置"></a>1.编译设置</h1><pre><code>%% 编译设置{erl_opts, [{parse_transform, lager_transform}, {parse_transform, ms_transform}, report, warn_export_all, warn_export_vars, warn_obsolete_guard, warn_shadow_vars, warn_unused_function, warn_deprecated_function%% ,warn_missing_spec, warn_unused_import]}.</code></pre><p>{parse_transform, lager_transform}是lager依赖库的编译选项，修改抽象语法树的方式在编译期生成对应的代码，lager源代码里本身没有lager:error，lager:info等等方法</p><h1 id="2-rebar3-shell"><a href="#2-rebar3-shell" class="headerlink" title="2.rebar3 shell"></a>2.rebar3 shell</h1><pre><code>{shell, [{apps, [app_name, sync, recon]}, {config, “config/app_name.config”}]}.</code></pre><p>这个配置支持在项目根目录直接运行rebar3 shell启动一个erl shell来运行我们的app，而其配置可以指定为config目录下的某个配置文件，而不是sys.config，适合本地调试，app_name后面的app名字是需要依赖启动的app</p><h1 id="3-rebar3插件"><a href="#3-rebar3插件" class="headerlink" title="3.rebar3插件"></a>3.rebar3插件</h1><pre><code>{plugins,[rebar3_run, rebar3_auto, {relflow, “1.0.5”}]}.</code></pre><p>配置我们项目需要的plugins，这里的插件可以是我们自己编写的rebar3插件</p><h1 id="4-钩子-provider-hooks"><a href="#4-钩子-provider-hooks" class="headerlink" title="4.钩子 provider_hooks"></a>4.钩子 provider_hooks</h1><pre><code>{provider_hooks,[{pre,[ {compile, {my_plugins, do_something}} ]},{post,[{compile,{my_plugins1, clean}}]}]}.</code></pre><p>例如这份配置，就是在执行rebar3 compile之前(pre)运行以my_plugins命名空间下的do_something命令，简单说就是编写了一个rebar3的插件叫my_plugins，提供一个命令叫do_something，即可以在命令行执行rebar3 my_plugins do_something的功能，只是现在配置之后自动调用了命令；post同理就是在compile之后执行那个插件的clean功能，clean功能具体干什么我们不得而知。</p><h1 id="5-环境"><a href="#5-环境" class="headerlink" title="5.环境"></a>5.环境</h1><pre><code>{profiles, [{profile1, [{erl_opts, [no_debug_info]},{relx, [{include_src, false}, {dev_mode, false}, {include_erts, true}, {system_libs, true}]}]}]}</code></pre><p>例如这份配置，指定了一种环境叫profile1，编译选项erl_opts为no_debug_info，打包发布的选项为不包含源码，禁止开发模式(目录不是软连接于default环境)，包含erlang环境等，当然还可以加其它很多选项，为每种环境单独自定义需要的功能，常用default、prod、test等</p><h1 id="6-覆盖"><a href="#6-覆盖" class="headerlink" title="6.覆盖"></a>6.覆盖</h1><pre><code>{overrides, [{add, deps1, [{erl_opts, [no_debug_info]}]}]}</code></pre><p>例如这份配置，就是对名为deps1的依赖的rebar.config再添加一个配置，overrides提供了add和override两种功能，第一种是加配置，第二种也就是用配置的数据去覆盖原来依赖中有的数据</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;rebar3的简单使用可以参考rebar3的官方文档。以下讲解一些rebar3的配置，初入erlang，理解还不甚深刻。&lt;br&gt;用rebar3进行工程创建，会生成rebar.config文件，贴一些配置的使用方法&lt;/p&gt;
&lt;h1 id=&quot;1-编译设置&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Erlang" scheme="http://lkness/tags/Erlang/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu16+ideaIC+rebar3搭建erlang开发环境</title>
    <link href="http://lkness/2018/06/19/012erlang-system-build/index/"/>
    <id>http://lkness/2018/06/19/012erlang-system-build/index/</id>
    <published>2018-06-19T11:42:44.000Z</published>
    <updated>2018-06-19T11:52:53.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-ubuntu16系统"><a href="#1-ubuntu16系统" class="headerlink" title="1.ubuntu16系统"></a>1.ubuntu16系统</h1><h1 id="2-安装各种库"><a href="#2-安装各种库" class="headerlink" title="2.安装各种库"></a>2.安装各种库</h1><pre><code>sudo apt-get install build-essentialsudo apt-get install libncurses5-devsudo apt-get install libssl-devsudo apt-get install m4sudo apt-get install unixodbc unixodbc-devsudo apt-get install freeglut3-dev libwxgtk2.8-devsudo apt-get install xsltprocsudo apt-get install fopsudo apt-get install tk8.5</code></pre><h1 id="3-安装erlang源码"><a href="#3-安装erlang源码" class="headerlink" title="3.安装erlang源码"></a>3.安装erlang源码</h1><p>deb安装包：esl-erlang_19.1.3-1-ubuntu-xenial_amd64.deb</p><p><code>dpkg -i esl-erlang_19.1.3-1-ubuntu-xenial_amd64.deb</code></p><h1 id="4-安装ideaIC工具"><a href="#4-安装ideaIC工具" class="headerlink" title="4.安装ideaIC工具"></a>4.安装ideaIC工具</h1><p>百度搜索安装ideaIC，我安装的ideaIC3.4版本，<a href="http://www.jetbrains.com/idea/" target="_blank" rel="noopener">地址</a></p><h1 id="5-下载rebar3"><a href="#5-下载rebar3" class="headerlink" title="5.下载rebar3"></a>5.下载rebar3</h1><p>rebar3<a href="http://www.rebar3.org/" target="_blank" rel="noopener">地址</a></p><h1 id="6-ideaIC安装erlang插件"><a href="#6-ideaIC安装erlang插件" class="headerlink" title="6.ideaIC安装erlang插件"></a>6.ideaIC安装erlang插件</h1><p>打开ideaIC，进入configure菜单进入settings进行设置：settings -&gt; Plugins -&gt; Browse repositories，然后搜索erlang，就可以安装erlang插件了</p><h1 id="7-配置"><a href="#7-配置" class="headerlink" title="7.配置"></a>7.配置</h1><p>安装完后再次进入settings界面：settings -&gt; Build,Execution,Deployment -&gt; Compiler -&gt; Erlang Compiler，将”Compiler project with rebar”和”Add debug info”都打勾。</p><p>接着：settings -&gt; Other Settings -&gt; Erlang External Tools，将”rebar”的路径设置为下载的rebar3可执行路径的目录。<br>配置完成。</p><h1 id="8-创建、打开新工程等"><a href="#8-创建、打开新工程等" class="headerlink" title="8.创建、打开新工程等"></a>8.创建、打开新工程等</h1><p>略</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-ubuntu16系统&quot;&gt;&lt;a href=&quot;#1-ubuntu16系统&quot; class=&quot;headerlink&quot; title=&quot;1.ubuntu16系统&quot;&gt;&lt;/a&gt;1.ubuntu16系统&lt;/h1&gt;&lt;h1 id=&quot;2-安装各种库&quot;&gt;&lt;a href=&quot;#2-安装各种
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Erlang" scheme="http://lkness/tags/Erlang/"/>
    
  </entry>
  
  <entry>
    <title>分治之最大子数组-《算法导论》学习笔记四</title>
    <link href="http://lkness/2018/06/19/011max-sub-arr/index/"/>
    <id>http://lkness/2018/06/19/011max-sub-arr/index/</id>
    <published>2018-06-19T11:35:51.000Z</published>
    <updated>2018-06-19T11:41:36.432Z</updated>
    
    <content type="html"><![CDATA[<p>《算法导论》第4章4.1使用分治策略求最大子数组（数组包含负数，不然整个数组即使最大子数组，求解没意义）。</p><p>思路：数组头为low，尾为high，mid=(low+high)/2，这样将数组分为了两段。首先肯定存在这个最大子数组。那么子数组的位置要么处于mid左边，要么处于mid右边，要么包含mid。假设最大子数组出现在mid左边，对mid左边子数组再进行(low+high)/2切分，那么最大子数组可能在切分出的子数组中的位置又存在三种情况中的一种，这样递归地切分下去，最终切分到整个数组都变为1-2个元素的子数组，这时候的情况就像一颗二叉树，例如数组[53,-4,-73,-16,88,91,-50,-15,-15,52,-19]，切分之后的二叉树：</p><p><img src="/img/max_sub_arr.jpeg" alt="maxsubarr"></p><p>然后用后续遍历二叉树的方式计算、查找最大子数组。如图，节点8的子数组有53、-4、53,-4，则找出来最大子数组为[53]，后序遍历的方式遍历完左子树，返回根，到右子树，有一个节点9，则最大子数组为9，对于节点4的左右子树的最大子数组都找到，再对节点8、4、9合并的数组找位于mid的最大子数组(此时low为0，mid为1，high为2，从mid出发往左走找最大子数组，再从mid+1出发往右走找最大子数组，再将找到的两个数组合并起来，为经过mid的最大子数组)，找到为[53,-4,-73]，将[53]、[-73]，[53,-4,-73]比较，得出根节点为4的树最大数组为[53]，则再返回根节点2，再后续到节点5，对5再求最大子数组为[88,91]，再对节点2求经过mid的最大子数组为[53,-4,-73,-16,88,91]，和为139，与[53]、[88,91]比较，选[88,91]；接着返回根节点1，对右子树节点2求最大子数组，为[52]，再对节点1组成的数组求经过mid的最大子数组，为[88,91,-50,-15,-15,52]，和为151，与[88,91]、[52]比较，选[88,91]。</p><pre><code>c代码：#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int crossLow = 0, crossHigh = 0, crossSum = 0;int finalLeftIndex = -1;int finalRightIndex = -1;int finalSubArraySum = 0;//求经过mid的最长子数组，范围low-highvoid find_max_crossing_subarray( int *arr,    int low, int mid, int high ){    if ( low == mid &amp;&amp; mid == high ) {        crossLow = low;        crossHigh = high;        crossSum = arr[mid];        return ;    }    int lMax = -10000000, rMax = -10000000;    int lTmpSum = 0, rTmpSum = 0;    int i = 0;    for ( i = mid; i &gt;= low; i-- ) {        lTmpSum += arr[i];        if ( lTmpSum &gt; lMax ) {            lMax = lTmpSum;            crossLow = i;        }    }    for ( i = mid + 1; i &lt;= high; i++ ) {        rTmpSum += arr[i];        if ( rTmpSum &gt; rMax ) {            rMax = rTmpSum;            crossHigh = i;        }    }    crossSum = lMax + rMax;}//分治，将数组切分子规模的待求数组void find_maximum_subarray( int *arr,    int low, int high ){    if ( high &lt;= low + 1 ) {        find_max_crossing_subarray( arr, low, low, high );        if ( arr[low] &gt;= arr[high] &amp;&amp; arr[low] &gt;= crossSum ) {            finalLeftIndex = low;            finalRightIndex = low;            finalSubArraySum = arr[low];        }        else if ( arr[high] &gt;= arr[low] &amp;&amp; arr[high] &gt;= crossSum ) {            finalLeftIndex = high;            finalRightIndex = high;            finalSubArraySum = arr[high];        }        else {            finalLeftIndex = low;            finalRightIndex = high;            finalSubArraySum = crossSum;        }    }    else {        int lLow = 0, lHigh = 0, lSum = 0;        int rLow = 0, rHigh = 0, rSum = 0;        //其实这里的递归就像二叉树的后续遍历，直到遍历完左子树，再开始右子树，        //这样的好处假如数组有上亿的元素，不会造成栈空间不足，        //解决了一个左子树就返回了递归栈，再进行右子树的展开工作        int mid = ( low + high ) / 2;        find_maximum_subarray( arr, low, mid );        lLow = finalLeftIndex;        lHigh = finalRightIndex;        lSum = finalSubArraySum;        find_maximum_subarray( arr, mid + 1, high );        rLow = finalLeftIndex;        rHigh = finalRightIndex;        rSum = finalSubArraySum;        find_max_crossing_subarray( arr, low, mid, high );        // printf(&quot;%d %d %d/%d %d %d/%d %d %d\n&quot;,        //     lLow, lHigh, lSum,        //     rLow, rHigh, rSum,        //     crossLow, crossHigh, crossSum);        if ( lSum &gt;= rSum &amp;&amp; lSum &gt;= crossSum ) {            finalLeftIndex = lLow;            finalRightIndex = lHigh;            finalSubArraySum = lSum;        }        else if ( rSum &gt;= lSum &amp;&amp; rSum &gt;= crossSum ) {            finalLeftIndex = rLow;            finalRightIndex = rHigh;            finalSubArraySum = rSum;        }        else {            finalLeftIndex = crossLow;            finalRightIndex = crossHigh;            finalSubArraySum = crossSum;        }        // printf(&quot;------%d %d %d\n&quot;, finalLeftIndex, finalRightIndex, finalSubArraySum);    }}//暴力破解法求最长子数组，不过这里用来测试我写的分治求法结果是否正确int check_result( int *arr, int len, int lIndex, int rIndex, int Sum ){    int maxSum = -100000000;    int lIndex1;    int rIndex1;    int i = 0, j = 0;    for ( i = 0; i &lt; len; i++ ) {        int tmpSum = 0;        for ( j = i; j &lt; len; j++ ) {            tmpSum += arr[j];            if ( tmpSum &gt; maxSum ) {                maxSum = tmpSum;                lIndex1 = i;                rIndex1 = j;            }        }    }    if ( Sum == maxSum ) {        if ( lIndex == lIndex1 &amp;&amp; rIndex == rIndex1 ) {            return 0;        }        printf(&quot;equal!!\n&quot;);        printf(&quot;exhaustivly_find_result:lIndex-&gt;%d,rIndex-&gt;%d,Sum-&gt;%d\n&quot;,            lIndex1, rIndex1, maxSum);        printf(&quot;divide_and_conquer_result:lIndex-&gt;%d,rIndex-&gt;%d,Sum-&gt;%d\n&quot;,            lIndex, rIndex, Sum);        return 1;    }    // else {    //     printf(&quot;not equal!!!!!!!!!&quot;);    // }    return -1;}void mainLoop( int *arr, int len ){    find_maximum_subarray( arr, 0, len - 1 );    printf(&quot;----------------------------------------------------\n&quot;);    printf(&quot;lIndex:%d,rIndex:%d,subArrSum:%d\n&quot;,        finalLeftIndex, finalRightIndex, finalSubArraySum);    printf(&quot;----------------------------------------------------\n&quot;);}void stepLoop( int *arr, int len ){    time_t tt0 = time( NULL );    printf(&quot;before:%s&quot;, ctime(&amp;tt0));    mainLoop( arr, len );    time_t tt1 = time( NULL );    printf(&quot;after:%s&quot;, ctime(&amp;tt1));    printf(&quot;cost %d(sec),%d(min)\n&quot;,        (int)(tt1 - tt0), (int)((tt1 - tt0) / 60));}//初始化随机数组void initArr( int *arr, int lowV,    int upV, int len ){    int i = 0;    int size = upV - lowV;    for ( ; i &lt; len; i++ )    {        arr[i] = rand() % size + lowV;    }}//打印数组void printArr( int *arr, int len ){    int i = 0;    for ( ; i &lt; len; i++ )        printf(&quot;%d &quot;, arr[i]);    printf(&quot;\n&quot;);}int main( int argc, char **argv ){    srand( (int)time(NULL) );    if ( argc != 4 )    {        printf(&quot;usage: ./execfile lowV upV len\n&quot;);        return 0;    }    int lowV = atoi( argv[1] );    int upV = atoi( argv[2] );    unsigned int len = atoi( argv[3] );    int *arr = NULL;    arr = ( int *) malloc( len * sizeof(int) );    // int len = 10;    // int arr[10] = {7, 0, -86, 61, -72, 50, -38, -25, -70, -76};    int i = 0;    //随机10000个数组求最大子数组，然后检测结果是否正确    for ( i = 0; i &lt; 10000; i++ ) {        initArr( arr, lowV, upV, len );        printArr( arr, len );        // stepLoop( arr, len );        usleep(1000);        find_maximum_subarray( arr, 0, len - 1 );        int ret = check_result( arr, len,                    finalLeftIndex, finalRightIndex, finalSubArraySum );        if ( ret &lt; 0 ) {            printf(&quot;failed!!\n&quot;);            return 0;        }        printf(&quot;-------------equal:%d\n&quot;, i);    }    free( arr );    arr = NULL;    return 0;}</code></pre><p>以上代码定义了几个全局变量，与《算法导论》的代码有点出入，书上的函数块返回3个值，例如：(left-low,left-high,left-sum) = FIND-MAXIMUM-SUBARRAY(A, low, mid)，这里可能用其它编程语言更好描述算法，erlang/golang/python的函数就可以返回一个元组并接收{LeftLow, LeftHigh, LeftSum} = FIND….()。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《算法导论》第4章4.1使用分治策略求最大子数组（数组包含负数，不然整个数组即使最大子数组，求解没意义）。&lt;/p&gt;
&lt;p&gt;思路：数组头为low，尾为high，mid=(low+high)/2，这样将数组分为了两段。首先肯定存在这个最大子数组。那么子数组的位置要么处于mid左
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://lkness/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
