<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>My Blog</title>
  
  <subtitle>我的小站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lkness/"/>
  <updated>2018-06-22T12:52:38.366Z</updated>
  <id>http://lkness/</id>
  
  <author>
    <name>lkness</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Erlang词法分析器、语法分析器(lexer-leex,yac-yecc)</title>
    <link href="http://lkness/2018/06/22/037erlang-parser/index/"/>
    <id>http://lkness/2018/06/22/037erlang-parser/index/</id>
    <published>2018-06-22T12:36:09.000Z</published>
    <updated>2018-06-22T12:52:38.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>一门编程语言的编译器或者解释器通常功能分解为两步：</p><blockquote><p>1、读取源码文件然后分析它的结构</p><p>2、处理这些结构，例如生成目标程序<br>lexer和yacc就是能完成第一步以便生成程序段的工具。而第一步的任务又能分为两个子任务：<br>1、分割源码文件内容为很多tokens(lexer)</p><p>2、分析出程序的分级结构(yacc)</p></blockquote><h1 id="二、lexer（词法分析工具）"><a href="#二、lexer（词法分析工具）" class="headerlink" title="二、lexer（词法分析工具）"></a>二、lexer（词法分析工具）</h1><p>lexer的源就是一个正则表达式表，其正则规则符合目标程序的代码片段。正则表达式表读取输入流，并将其根据正则规则转换为分割的字符串，然后输出为输出流，再翻译为一个程序。当 Lex 接收到文件或文本形式的输入时，它试图将文本与常规表达式进行匹配。 它一次读入一个输入字符，直到找到一个匹配的模式。 如果能够找到一个匹配的模式，Lex 就执行相关的动作（可能包括返回一个标记）。 另一方面，如果没有可以匹配的常规表达式，将会停止进一步的处理，Lex 将显示一个错误消息。<br>Erlang的lexer工具就是leex模块。</p><h1 id="三、yacc（语法分析工具）"><a href="#三、yacc（语法分析工具）" class="headerlink" title="三、yacc（语法分析工具）"></a>三、yacc（语法分析工具）</h1><p>是一个用来生成编译器的编译器（编译器代码生成器）。输入词法分析器的流，输出目标语言的代码。<br>Erlang的yacc工具就是yecc。</p><h1 id="四、作用"><a href="#四、作用" class="headerlink" title="四、作用"></a>四、作用</h1><p>有了这两个工具，我们可以自定义自己的编程语言，自定义这个语言的语法规则，最终生成相同功能的erlang代码。例如领域特定语言(DSL)，我们可以定义个简单类似makefile的mymakefile语法规则，然后生成erlang代码来真正执行功能。</p><h1 id="五、初识"><a href="#五、初识" class="headerlink" title="五、初识"></a>五、初识</h1><p>这次研究leex和yecc也是在研究erlang protocolbuf时候，发现通用的做法就是书写一个协议字段描述文件，然后来生成erlang文件，例如一条TestRequest协议，定义其协议号10000，编解码文件为test_proto.erl，那么描述关系就是10000,TestRequest,test_proto，然后我们代码中传包解包时，都在协议头带上一个16位的协议号，通过协议号路由到真正的编解码文件也就是test_proto.erl。而看了很多实现，都是用riak官方某个rebar插件，来将这种关系描述文件生成erlang文件。</p><p>这个功能很简单，不过想是不是能用leex、yecc完成，最近正好也在研究，于是就产生了试一试的想法。</p><h1 id="六、定义leex的-xrl文件"><a href="#六、定义leex的-xrl文件" class="headerlink" title="六、定义leex的.xrl文件"></a>六、定义leex的.xrl文件</h1><p>leex需要.xrl文件来描述自定义源文件的正则匹配规则，例如上面的协议描述关系，我们可以用[0-9]+来匹配出开始的协议号，用[,]<a href="[0-9a-zA-Z]*_?">a-zA-Z</a>*[,]匹配出协议名。</p><p>leex文件需要三个部分:Definitions Rules Erlangcode，Definitions表示正则匹配的变量，Rules表示匹配的规则和匹配后的输出，Erlangcode则是作为辅助的erlang函数。</p><p>我们可以按照第五步来编写我们的.xrl文件（假设叫test_lexer.xrl）：</p><pre><code>Definitions.TypeID = [0-9]+MsgName = [,][a-zA-Z]([0-9a-zA-Z]*_?)*[,]MsgModule = [a-zA-Z]([0-9a-zA-Z]*_?)*(\n)?NoneLine = [\n]Rules.{TypeID} : {token, {msg_number, TokenLine, list_to_integer(TokenChars)}}.{MsgName} : {token, {msg_name, TokenLine, drop_tokens(TokenChars)}}.{MsgModule} : {token, {msg_module, TokenLine, drop_tokens(TokenChars)}}.{NoneLine} : skip_token.Erlang code.drop_tokens(TokenChars) -&gt;    [Chars] = string:tokens(TokenChars, &quot;,&quot;),    [Chars1] = string:tokens(Chars, &quot;\s&quot;),    [Chars2] = string:tokens(Chars1, &quot;.&quot;),    [Chars3] = string:tokens(Chars2, &quot;\n&quot;),    Chars3.</code></pre><p>上面的代码还是容易看懂的。</p><p>使用方法则是先编写一个协议描述的文件test_pb_desc.csv，随便输入个关系：</p><pre><code>10000,fdsfds_232,fdsf_REWr10001,fwefsd,terterr</code></pre><p>然后通过leex编译出我们的词法分析器：</p><pre><code>leex:file(&quot;test_lexer.xrl&quot;).</code></pre><p>不出意外，当前目录就会多一个test_lexer.erl，然后来分析我们的描述文件：</p><pre><code>{ok, Lines} = file:read_file(&quot;test_pb_desc.csv&quot;),{_, Tokens, _} = test_lexer:string(binary_to_list(Lines)),</code></pre><p>这里得到的Tokens就是我们的词法分析结果，可以输入到下一步的语法分析器里生成erlang代码。</p><h1 id="七、定义yecc的-yrl文件"><a href="#七、定义yecc的-yrl文件" class="headerlink" title="七、定义yecc的.yrl文件"></a>七、定义yecc的.yrl文件</h1><p>yecc需要.yrl文件来描述词法分析的分析方法以及分析的产出。</p><p>yecc文件需要四个部分：Nonterminals Terminals Rootsymbol Erlangcode，Nonterminals表示每次输入的流，Terminals表示输入流里面的tokens关键字，Rootsymbol表示输入的根（源），Erlangcode照例是辅助的erlang函数，<br>我们可以按照第六步的生成来编写yrl文件（例如叫test_parser.yrl）：</p><pre><code>Nonterminalscombines combine.Terminals msg_number msg_name msg_module.Rootsymbol combines.combines -&gt; combine : &apos;$1&apos;.combines -&gt; combine combines : &apos;$1&apos; ++ &apos;$2&apos;.combine -&gt; msg_number msg_name msg_module :    [{{save('$1'), save('$2')}, {save('$2'), save('$1')}, {save('$1'), save('$3')}}].Erlang code.save({msg_number, _, Value}) -&gt; Value;save({msg_name, _, Value}) -&gt; list_to_atom(Value);save({msg_module, _, Value}) -&gt; list_to_atom(Value).</code></pre><p>这里的combines语法有点像[H | Rest]语法，第一个combines -&gt; combine : ‘$1’表示整个输入的词法分析流列表只剩一个元素的做法，combines -&gt; combine combines : … 表示匹配出单个元素combine 以及剩下的combines，而combine又寻找到单个规则combine -&gt; msg_number msg_name ….，这样递归地处理输入源。</p><p>使用方法是：</p><pre><code>yecc:file(&quot;test_parser.yrl&quot;).</code></pre><p>然后编译生成的test_parser.erl文件，再调用test_parser:parse(Tokens).就生成erlang的目标代码了，这里我只生成了一个列表。</p><h1 id="八、完整代码"><a href="#八、完整代码" class="headerlink" title="八、完整代码"></a>八、完整代码</h1><p>我将完整代码用来编写了一个rebar3插件，用户定义协议描述文件xxx，然后里面的内容是协议描述关系：数字,协议名,协议编解码文件 这样的内容，插件就能输出成一个erlang文件。</p><p>完整代码参照我的git repo：<a href="https://github.com/xlkness/rebar3_pb_msgdesc" target="_blank" rel="noopener">rebar3_pb_msgdesc</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h1&gt;&lt;p&gt;一门编程语言的编译器或者解释器通常功能分解为两步：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、读取源码文件然后分析它的结构
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Erlang" scheme="http://lkness/tags/Erlang/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Abstract Syntax Tree和汇编字节码</title>
    <link href="http://lkness/2018/06/22/036erlang-ast/index/"/>
    <id>http://lkness/2018/06/22/036erlang-ast/index/</id>
    <published>2018-06-22T12:35:59.000Z</published>
    <updated>2018-06-22T12:45:00.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、抽象语法树简介"><a href="#一、抽象语法树简介" class="headerlink" title="一、抽象语法树简介"></a>一、抽象语法树简介</h1><p>抽象语法树(Abstract Syntax Tree)是源代码的抽象语法结构的树状表示。</p><p>抽象语法树是解析器(parser)的产物，解析器广义来说输入一般是程序的源码，输出一般是语法树（syntax tree，也叫parse tree等）或抽象语法树。进一步剥开来，广义的解析器里一般会有扫描器（scanner，也叫tokenizer或者lexical analyzer，词法分析器），以及狭义的解析器（parser，也叫syntax analyzer，语法分析器）。扫描器的输入一般是文本，经过词法分析，输出是将文本切割为单词的流。狭义的解析器输入是单词的流，经过语法分析，输出是语法树或者精简过的AST。</p><p>例如：将i = a + b * c作为源代码输入到解析器里，则广义上的解析器的工作流程如下图：</p><p><img src="/img/erlang_ast.png" alt="erlang_ast1"></p><h1 id="二、用途"><a href="#二、用途" class="headerlink" title="二、用途"></a>二、用途</h1><pre><code>erlang beam是寄存器虚拟机，因此erlang的源码会被erlang解析器的词法分析变为AST，然后经过树形遍历解析器给转换为汇编字节码。</code></pre><h1 id="三、抽象语法树初识"><a href="#三、抽象语法树初识" class="headerlink" title="三、抽象语法树初识"></a>三、抽象语法树初识</h1><h2 id="1、创建一个test1-erl的文件，输入以下代码："><a href="#1、创建一个test1-erl的文件，输入以下代码：" class="headerlink" title="1、创建一个test1.erl的文件，输入以下代码："></a>1、创建一个test1.erl的文件，输入以下代码：</h2><pre><code>-module(test1).-export([start/0]).-compile({parse_transform, test_parser}).start() -&gt;    &quot;hello world&quot;.</code></pre><h2 id="2、创建一个test-parser-erl的文件，输入以下代码："><a href="#2、创建一个test-parser-erl的文件，输入以下代码：" class="headerlink" title="2、创建一个test_parser.erl的文件，输入以下代码："></a>2、创建一个test_parser.erl的文件，输入以下代码：</h2><pre><code>-module(test_parser).-export([parse_transform/2]).parse_transform(AST, _Options) -&gt;    io:format(&quot;old:~w~n~n&quot;, [AST]),    Acc = parse_ast(AST, []),    io:format(&quot;new:~w~n~n&quot;, [Acc]),    Acc.parse_ast([{attribute, _, _, _} = H | R], Acc) -&gt;    parse_ast(R, [H | Acc]);parse_ast([{function, _Line, _Fun, _Arity, _Args} = H | R], Acc) -&gt;    parse_ast(R, [parse_fun(H) | Acc]);parse_ast([H | R], Acc) -&gt;    parse_ast(R, [H | Acc]);parse_ast([], Acc) -&gt;    lists:reverse(Acc).parse_fun({function, Line, Fun, Arity, Clause}) -&gt;    {function, Line, Fun, Arity, parse_clause(Clause, [])}.parse_clause([{clause, Line, P, Guard, Return}], Acc) -&gt;    [{clause, Line, P, Guard, parse_return(Return, [])} | Acc].parse_return([{string, Line, Value} | R], Acc) -&gt;    parse_return(R, [{bin, Line, [{bin_element, Line, {string, Line, Value},default,default}]} | Acc]);parse_return([], Acc) -&gt;    lists:reverse(Acc).</code></pre><h2 id="3、编译"><a href="#3、编译" class="headerlink" title="3、编译"></a>3、编译</h2><pre><code>1&gt; c(test_parser).{ok,test_parser}2&gt; c(test1).old:[{attribute,1,file,{[116,101,115,116,49,46,101,114,108],1}},{attribute,1,module,test1},{attribute,3,export,[{start,0}]},{function,7,start,0,[{clause,7,[],[],[{string,8,[104,101,108,108,111,32,119,111,114,108,100]}]}]},{eof,9}]new:[{attribute,1,file,{[116,101,115,116,49,46,101,114,108],1}},{attribute,1,module,test1},{attribute,3,export,[{start,0}]},{function,7,start,0,[{clause,7,[],[],[{bin,8,[{bin_element,8,{string,8,[104,101,108,108,111,32,119,111,114,108,100]},default,default}]}]}]},{eof,9}]{ok,test1}</code></pre><p>先不管io:format的打印，我们直接执行test1:start()，</p><pre><code>3&gt; test1:start().&lt;&lt;&quot;hello world&quot;&gt;&gt;</code></pre><p>发现终端输出的是二进制！而我们源码明明写的是个字符串！！破编译器对我们的代码干了什么！！</p><p>别惊慌，这时候我们就可以来看看我们打印的抽象语法树了。</p><p>先看old，attribute都是源码文件的属性，例如file、export、import、module名等，可以略过，以及eof表示源码文件的结尾，也可以忽略。直接定位到function元组，{function, Line, Name, Arity, Clauses}表示一个函数的源码行、函数名、形参数、模式匹配列表，再定位到模式匹配列表clause，其表示了一个函数的多个模式匹配和返回值，当前start函数就一个匹配，因此clause只有一个tuple元素，返回值就是一个{string, Line, “hello world”}，<br>那么我们是不是修改这个{string, Line, “hello world”}为一个二进制字符串，就能达到我们演示的效果呢？是的！</p><p>这就是test1.erl中-compile({parse_transform, test_parser}).的作用，erlang的解析器会在词法分析完成后，调用我们自己指定的函数对ast进行二次更改，于是test_parser.erl里面就将start函数的返回值更改为了一个二进制。然后返回一个新的AST，再经树形解析编译为erlang汇编字节码文件，供erlang vm调用。</p><h1 id="四、应用"><a href="#四、应用" class="headerlink" title="四、应用"></a>四、应用</h1><p>lager日志库 <a href="https://github.com/erlang-lager/lager" target="_blank" rel="noopener">https://github.com/erlang-lager/lager</a></p><p>以前一直疑惑使用lager日志库为什么要在编译选项上加一个{parse_transform, lager_transform}，现在也懂了，</p><p>就是编译我们项目每一个源文件时，都将最终的抽象语法树再次添加一些特性代码。</p><p>这里我们可以打印一下，现在我在一个叫erlserver_app.erl的文件里加入lager日志打印代码：</p><pre><code>-module(erlserver_app).-behaviour(application).-export([start/2, stop/1]).-compile([{parse_transform, lager_transform}]).start(_StartType, _StartArgs) -&gt;    lager:warning(&quot;12345678987654321~w~n&quot;, [&quot;abcdedeba&quot;]),    erlserver_sup:start_link().%%--------------------------------------------------------------------stop(_State) -&gt;    ok.</code></pre><p>然后在lager_transform里继续像上面那样打印，</p><p>最终编译输出：</p><pre><code>===&gt; old:[{attribute,1,file,{[47,104,111,109,101,47,108,105,107,117,110,47,115,116,117,100,121,47,101,114,108,97,110,103,47,101,114,108,115,101,114,118,101,114,47,95,98,117,105,108,100,47,100,101,102,97,117,108,116,47,108,105,98,47,101,114,108,115,101,114,118,101,114,47,115,114,99,47,101,114,108,115,101,114,118,101,114,95,97,112,112,46,101,114,108],1}},{attribute,6,module,erlserver_app},{attribute,8,behaviour,application},{attribute,11,export,[{start,2},{stop,1}]},{attribute,13,compile,[]},{function,19,start,2,[{clause,19,[{var,19,&apos;_StartType&apos;},{var,19,&apos;_StartArgs&apos;}],[],[{call,20,{remote,20,{atom,20,lager},{atom,20,warning}},[{string,20,[49,50,51,52,53,54,55,56,57,56,55,54,53,52,51,50,49,126,119,126,110]},{cons,20,{string,20,[97,98,99,100,101,100,101,98,97]},{nil,20}}]},{call,21,{remote,21,{atom,21,erlserver_sup},{atom,21,start_link}},[]}]}]},{function,24,stop,1,[{clause,24,[{var,24,&apos;_State&apos;}],[],[{atom,25,ok}]}]},{eof,30}]===&gt; new:[{attribute,1,file,{[47,104,111,109,101,47,108,105,107,117,110,47,115,116,117,100,121,47,101,114,108,97,110,103,47,101,114,108,115,101,114,118,101,114,47,95,98,117,105,108,100,47,100,101,102,97,117,108,116,47,108,105,98,47,101,114,108,115,101,114,118,101,114,47,115,114,99,47,101,114,108,115,101,114,118,101,114,95,97,112,112,46,101,114,108],1}},{attribute,6,module,erlserver_app},{attribute,6,lager_records,[]},{attribute,8,behaviour,application},{attribute,11,export,[{start,2},{stop,1}]},{attribute,13,compile,[]},{function,19,start,2,[{clause,19,[{var,19,&apos;_StartType&apos;},{var,19,&apos;_StartArgs&apos;}],[],[{&apos;case&apos;,20,{tuple,20,[{call,20,{atom,20,whereis},[{atom,20,lager_event}]},{call,20,{atom,20,whereis},[{atom,20,lager_event}]},{call,20,{remote,20,{atom,20,lager_config},{atom,20,get}},[{tuple,20,[{atom,20,lager_event},{atom,20,loglevel}]},{tuple,20,[{integer,20,0},{nil,20}]}]}]},[{clause,20,[{tuple,20,[{atom,20,undefined},{atom,20,undefined},{var,20,&apos;_&apos;}]}],[],[{call,20,{&apos;fun&apos;,20,{clauses,[{clause,20,[],[],[{tuple,20,[{atom,20,error},{atom,20,lager_not_running}]}]}]}},[]}]},{clause,20,[{tuple,20,[{atom,20,undefined},{var,20,&apos;_&apos;},{var,20,&apos;_&apos;}]}],[],[{call,20,{&apos;fun&apos;,20,{clauses,[{clause,20,[],[],[{tuple,20,[{atom,20,error},{tuple,20,[{atom,20,sink_not_configured},{atom,20,lager_event}]}]}]}]}},[]}]},{clause,20,[{tuple,20,[{var,20,&apos;__Piderlserver_app20&apos;},{var,20,&apos;_&apos;},{tuple,20,[{var,20,&apos;__Levelerlserver_app20&apos;},{var,20,&apos;__Traceserlserver_app20&apos;}]}]}],[[{op,20,&apos;orelse&apos;,{op,20,&apos;/=&apos;,{op,20,&apos;band&apos;,{var,20,&apos;__Levelerlserver_app20&apos;},{integer,20,16}},{integer,20,0}},{op,20,&apos;/=&apos;,{var,20,&apos;__Traceserlserver_app20&apos;},{nil,20}}}]],[{call,20,{remote,20,{atom,20,lager},{atom,20,do_log}},[{atom,20,warning},{cons,20,{tuple,20,[{atom,20,application},{atom,20,erlserver}]},{cons,20,{tuple,20,[{atom,20,module},{atom,20,erlserver_app}]},{cons,20,{tuple,20,[{atom,20,function},{atom,20,start}]},{cons,20,{tuple,20,[{atom,20,line},{integer,20,20}]},{cons,20,{tuple,20,[{atom,20,pid},{call,20,{atom,20,pid_to_list},[{call,20,{atom,20,self},[]}]}]},{cons,20,{tuple,20,[{atom,20,node},{call,20,{atom,20,node},[]}]},{call,20,{remote,20,{atom,20,lager},{atom,20,md}},[]}}}}}}},{string,20,[49,50,51,52,53,54,55,56,57,56,55,54,53,52,51,50,49,126,119,126,110]},{cons,20,{string,20,[97,98,99,100,101,100,101,98,97]},{nil,20}},{integer,20,4096},{integer,20,16},{var,20,&apos;__Levelerlserver_app20&apos;},{var,20,&apos;__Traceserlserver_app20&apos;},{atom,20,lager_event},{var,20,&apos;__Piderlserver_app20&apos;}]}]},{clause,20,[{var,20,&apos;_&apos;}],[],[{atom,20,ok}]}]},{call,21,{remote,21,{atom,21,erlserver_sup},{atom,21,start_link}},[]}]}]},{function,24,stop,1,[{clause,24,[{var,24,&apos;_State&apos;}],[],[{atom,25,ok}]}]},{eof,30}]</code></pre><p>看来添加的东西挺多，没事，慢慢看，我们根据官方文档The Abstract Format一个一个对比看，</p><p>最终将添加的代码还原出来：</p><pre><code>case {whereis(lager_event), whereis(lager_event), lager_config:get({lager_event, loglevel}, {0, []})} of    {undefined, undefined, _} -&gt;        {error, lager_not_running};    {undefined, _, _} -&gt;        {error, sink_not_configured, lager_event};    {__Piderlserver_app20, _, {__Levelerlserver_app20, __Traceserlserver_app20}} when __Levelerlserver_app20 band 16 /= 0 orelse __Traceserlserver_app20 /= nil -&gt;        lager:do_log(warning, [{application, erlserver}, {atom, erlserver_app}, {function, start}, {line, 20}, {pid, pid_to_list(self())}, {node, node()}, lager:md()],            [49,50,51,52,53,54,55,56,57,56,55,54,53,52,51,50,49,126,119,126,110], [[97,98,99,100,101,100,101,98,97], []], 4096, 16, __Levelerlserver_app20,                __Traceserlserver_app20, lager_event, __Piderlserver_app20);    _ -&gt;        okend</code></pre><p>小小一句lager:warning()原来有这么多弯弯绕啊！</p><h1 id="五、erlang汇编字节码"><a href="#五、erlang汇编字节码" class="headerlink" title="五、erlang汇编字节码"></a>五、erlang汇编字节码</h1><p>一直说erlang汇编字节码，但是具体是个什么东西，还没有认识。</p><p>下面新建一个文件test.erl，输入以下内容：</p><pre><code>-module(test).-export([start/2]).start(A, B) -&gt;        abs(A) + abs(B).</code></pre><h2 id="1、编译-S汇编码"><a href="#1、编译-S汇编码" class="headerlink" title="1、编译.S汇编码"></a>1、编译.S汇编码</h2><pre><code>erlc -S test.erl</code></pre><h2 id="2、编译-dis汇编码"><a href="#2、编译-dis汇编码" class="headerlink" title="2、编译.dis汇编码"></a>2、编译.dis汇编码</h2><pre><code>erlc(test).erts_debug:df(test).</code></pre><p>然后打开得到的test.S文件：</p><pre><code>{module, test}.  %% version = 0{module, test}.  %% version = 0{exports, [{module_info,0},{module_info,1},{start,2}]}.{attributes, []}.{labels, 7}.{function, start, 2, 2}.  {label,1}.    {line,[{location,&quot;test.erl&quot;,4}]}.    {func_info,{atom,test},{atom,start},2}.  {label,2}.    {line,[{location,&quot;test.erl&quot;,5}]}.    {gc_bif,abs,{f,0},2,[{x,0}],{x,0}}.    {line,[{location,&quot;test.erl&quot;,5}]}.    {gc_bif,abs,{f,0},2,[{x,1}],{x,1}}.    {line,[{location,&quot;test.erl&quot;,5}]}.    {gc_bif,&apos;+&apos;,{f,0},2,[{x,0},{x,1}],{x,0}}.    return.{function, module_info, 0, 4}.  {label,3}.    {line,[]}.    {func_info,{atom,test},{atom,module_info},0}.  {label,4}.    {move,{atom,test},{x,0}}.    {line,[]}.    {call_ext_only,1,{extfunc,erlang,get_module_info,1}}.{function, module_info, 1, 6}.  {label,5}.    {line,[]}.    {func_info,{atom,test},{atom,module_info},1}.  {label,6}.    {move,{x,0},{x,1}}.    {move,{atom,test},{x,0}}.    {line,[]}.    {call_ext_only,2,{extfunc,erlang,get_module_info,2}}.</code></pre><p>每一个function元组标明了模块中的函数，我们直接定位到function start模块，每个label表示pc指针的执行顺序，跳过label1，我们直接看label2，有许多寄存器x0,x1,…xn y0,y1,…yn。x寄存器是用来存储函数入参的，特殊的x0寄存器，函数第一个入参是存放在里面，并且也用来作为函数返回值，而y寄存器是栈上分配的临时寄存器，</p><p>有了以上知识，我们直接看汇编码：</p><p>（忽略某些无用行）</p><pre><code>{gc_bif,abs,{f,0},2,[{x,0}],{x,0}}. //用x0去调用bif函数abs，存储结果到x0寄存器，{gc_bif,abs,{f,0},2,[{x,1}],{x,1}}. //用x1去调用bif函数abs，存储结果到x1寄存器，{gc_bif,&apos;+&apos;,{f,0},2,[{x,0},{x,1}],{x,0}}. //执行bif函数+， x0+x1，结果放入x0寄存器return. //返回，直接返回x0的值</code></pre><p>这就是.S汇编字节码，它具有一定可读性，方便人和机器阅读</p><p>再打开.dis汇编码文件：</p><pre><code>00007FDAE5183770: i_func_info_IaaI 0 test start 200007FDAE5183798: i_gc_bif1_jIsId j(0000000000000000) abs/1 x(0) 2 x(0)00007FDAE51837C8: i_gc_bif1_jIsId j(0000000000000000) abs/1 x(1) 2 x(1)00007FDAE51837F8: i_plus_jIxxd j(0000000000000000) 2 x(0) x(1) x(0)00007FDAE5183828: return00007FDAE5183830: i_func_info_IaaI 0 test module_info 000007FDAE5183858: move_cr test r(0)00007FDAE5183868: allocate_tt 0 100007FDAE5183878: call_bif_e erlang:get_module_info/100007FDAE5183888: deallocate_return_Q 000007FDAE5183898: i_func_info_IaaI 0 test module_info 100007FDAE51838C0: move_rx r(0) x(1)00007FDAE51838D0: move_cr test r(0)00007FDAE51838E0: allocate_tt 0 200007FDAE51838F0: call_bif_e erlang:get_module_info/200007FDAE5183900: deallocate_return_Q 0</code></pre><p>其实大体上差不多，不过多了真是调用的函数和执行地址，但是erlang的汇编操作码太多，因此这个文件可读性很差，如果想搞懂具体指令作用可以去查阅相关文档。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、抽象语法树简介&quot;&gt;&lt;a href=&quot;#一、抽象语法树简介&quot; class=&quot;headerlink&quot; title=&quot;一、抽象语法树简介&quot;&gt;&lt;/a&gt;一、抽象语法树简介&lt;/h1&gt;&lt;p&gt;抽象语法树(Abstract Syntax Tree)是源代码的抽象语法结构的树状表
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Erlang" scheme="http://lkness/tags/Erlang/"/>
    
  </entry>
  
  <entry>
    <title>【从零开始构建erlang服务器】-04协议层</title>
    <link href="http://lkness/2018/06/22/035build-erlang-server04/index/"/>
    <id>http://lkness/2018/06/22/035build-erlang-server04/index/</id>
    <published>2018-06-22T12:06:51.000Z</published>
    <updated>2018-06-22T12:45:30.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>协议的作用很重要，通信协议可以理解为两个节点之间为了协同工作实现信息交换，协商一定的规则和约定，例如规定字节序，各个字段类型，使用什么压缩算法或加密算法等。常 见的有tcp，udo，http，sip等常见协议。协议有流程规范和编码规范。流程如呼叫流程等信令流程，编码规范规定所有信令和数据如何打包/解包。编码规范就是我们通常所说的编解码，序列化。不光是用在通信工作上，在存储工作上我们也经常用到。如我们经常想把内存中对象存放到磁盘上，就需要对对象进行数据序列化工作。</p><p>本文主要使用google protocol buffer协议。协议就不多介绍了，网上搜索有很多讲解。</p><h1 id="二、编写proto文件"><a href="#二、编写proto文件" class="headerlink" title="二、编写proto文件"></a>二、编写proto文件</h1><p>协议规定了两方交流的方式，因此要有统一的双方都认识的东西来规定协议，例如json、xml，对于protocolbuf，就要定义proto文件了。</p><p>协议一般都跟服务器逻辑相关，因此我们先明确服务器要提供什么功能，再来编写协议。</p><p>这里我们可以做一个五子棋游戏服务器，那么游戏提供以下功能：</p><p>（先不做登陆功能，假设只要是客户端跟我们服务器完成三次握手就能进入游戏）</p><p>1、大厅，每隔3s刷新显示所有房间人数和玩家准备状态（先不提供按等级划分的大厅例如菜鸟场、新手场、中级场等）;<br>2、大厅提供直选房间加入方式，也提供匹配方式加入房间（优先匹配有一个人落座的房间）；<br>3、房间，最多坐两个人，多余的人会进入观战席，座位上的玩家可以准备，可以取消准备，玩家从进入房间开始计时，计时到了还没准备就踢出房间，不管中途多少次准备、未准备，一旦双方准备，则游戏开始，随机分配先手方；<br>4、对战，无禁手，无交换，无放弃落子（往简单做），双方各有2分钟总的思考时间，用完则其每一步均只有10s思考时间；<br>5、对战中异常检测，3s一次心跳，如果客户端下线或者退出房间，则另一方赢；<br>6、房间预先创建20个，如果只剩5个空房间，则多创建5个保留；<br>7、点选加入房间如果人满，返回人满错误提示玩家重新选房间</p><p>根据需求我们可以制定协议了。</p><p>创建协议文件gobang.proto，复制以下内容到协议（协议只是随便定义了下，没精力了，后续写代码再优化吧）：</p><pre><code>enum ChessPieceColor {    BALCK = 1;    RED = 2;}// 心跳message HeartBeatReq {}message HeartBeatResp {}// 获取大厅房间人数，客户端可以自己间隔获取message GetRoomsInfoReq {}message GetRoomsInfoResp {    repeated roomInfoType rooms = 1;}// 加入房间message JoinRoomReq {    required uint32 join_type = 1;      // 1:随机匹配 2:选房加入    required string nick_name = 2;      // 未做注册、登陆，直接给昵称    required uint32 sex = 3;            // 性别    optional uint32 room_id = 4;        // 选房加入时的房间号}message JoinRoomResp {    required bool audience = 1;         // 是否观众席位（加入瞬间座位满了）    required roomInfoType room = 2;     // 加入的房间信息    optional uint32 remain_sec = 3;     // 不准备的剩余秒数，到时即踢}// 准备message PrepareReq {    required uint32 type = 1;           // 1:准备 2:取消准备}message PrepareResp {    required uint32 remain_sec = 1;     // 不准备的剩余秒数，到时即踢}// 游戏开始-服务器主动推送给客户端message StartGamePush {    required ChessPieceColor color = 1; // 我方颜色，黑棋先（如果是围观群众，不读这个字段）    required uint32 remain_sec = 2;     // 思考的剩余时长，如果超时了，每一次落子只有per_round_remain_sec    required uint32 per_round_remain_sec = 3;   // 思考的总时间花费完了，之后每一步只有这么长的时间思考，超过即输    repeated startDetailType detail = 4;    message startDetailType {       // 推送给围观群众的        required ChessPieceColor color = 1;        required userInfoType user = 2;    }}// 游戏进行message PlayGameReq {    required uint32 x_pos = 1;    required uint32 y_pos = 2;}message PlayGameResp {    required uint32 err_code = 1;    required uint32 remain_sec = 2;}// 服务器推送其他玩家落子message PlayBroadcastPush {    required ChessPieceColor color = 1;         // 棋子颜色    required uint32 x_pos = 2;    required uint32 y_pos = 3;}// 游戏结束message EndGamePush {    required userInfoType winner = 1;           // 赢家}// 玩家加入房间、退出房间推送message UserInOutPush {    required uint32 type = 1;                   // 1.进入座位、2.进入观众席、3.退出座位、4.退出观众席    optional seatInfoType seat = 2;             // 座位变动才有    optional userInfoType user = 3;                 // 观众席变动才有}// 座位玩家加入观众席message JoinAudienceReq {}message JoinAudienceResp {    required uint32 err_code = 1;}// 观众席加入座位message JoinSeatReq {}message JoinSeatResp {    required uint32 err_code = 1;}/*内部声明*/// 房间信息message roomInfoType {    required uint32 room_id = 1;        // 房间id    repeated seatInfoType seats = 2;    // 座位信息    repeated userInfoType audiences = 3;// 围观群众}// 座位信息message seatInfoType {    required uint32 index = 1;          // 座位编号    optional userInfoType user = 2;     // 座位用户信息，空座位没有用户}// 用户信息message userInfoType {    required uint64 user_id = 1;        // 用户id    required string nick_name = 2;      // 昵称}</code></pre><h1 id="三、编译协议文件"><a href="#三、编译协议文件" class="headerlink" title="三、编译协议文件"></a>三、编译协议文件</h1><h2 id="1、添加协议描述文件"><a href="#1、添加协议描述文件" class="headerlink" title="1、添加协议描述文件"></a>1、添加协议描述文件</h2><p>目前我看到的erlang protocolbuf通信，都是将proto结构体编码成二进制，然后再在二进制头上补一个16位的协议号，这个协议号是前端和后端自定义的，也可以说是公司层面的协议号，例如这个项目组使用100-999，那个项目组使用1000-1999这样子。那么协议流发出去就是一个&lt;&lt;MsgID:16, Bin/binary&gt;&gt;这样一个二进制流，然后接收端再提取前16位的协议号。通过协议号找到真正的协议名，然后路由到真正的协议编解码文件进行处理，例如有多个.proto文件，经过pb工具生成编解码工具文件就有多个，如何路由到哪个编解码文件，就需要手工写一个描述关系。</p><p>将自定义的协议描述文件生成对应的erlang文件的工具我看到的很多都是用riak官方的一个rebar插件，这里我自己在学习lexer/yecc编译工具的时候写了一个rebar3插件rebar3_pb_msgdesc，功能一样。我就使用自己的插件来生成了，具体用法参考插件的readme文件。</p><p>针对第二步的协议内容，我们编写一个erlserver_pb_desc.csv文件，格式 协议号，协议名，协议文件 输入以下内容：</p><pre><code>1,HeartBeatReq,erlserver_gobang_pb2,HeartBeatResp,erlserver_gobang_pb100,GetRoomsInfoReq,erlserver_gobang_pb101,GetRoomsInfoResp,erlserver_gobang_pb102,JoinRoomReq,erlserver_gobang_pb103,JoinRoomResp,erlserver_gobang_pb104,PrepareReq,erlserver_gobang_pb105,PrepareResp,erlserver_gobang_pb106,StartGamePush,erlserver_gobang_pb107,PlayGameReq,erlserver_gobang_pb108,PlayGameResp,erlserver_gobang_pb109,PlayBroadcastPush,erlserver_gobang_pb110,EndGamePush,erlserver_gobang_pb111,UserInOutPush,erlserver_gobang_pb112,JoinAudienceReq,erlserver_gobang_pb113,JoinAudienceResp,erlserver_gobang_pb114,JoinSeatReq,erlserver_gobang_pb115,JoinSeatResp,erlserver_gobang_pb</code></pre><p>然后按照我的插件readme配置，执行rebar3 compile就能生成文件了，注意配置生成的描述文件可以放在src/proto/目录。</p><h2 id="2、生成协议编解码文件"><a href="#2、生成协议编解码文件" class="headerlink" title="2、生成协议编解码文件"></a>2、生成协议编解码文件</h2><p>生成协议编解码文件现在都推荐gpb库了，而rebar3插件rebar3_gpb_plugin就可以自动使用gpb作为插件并生成协议编解码文件，按照插件readme的配置，我们将编解码文件生成到src/proto/目录，配置好了rebar3钩子(hook)，直接执行compile就能生成协议编解码文件。<br>（如还是很模糊，可直接参考这个项目<a href="https://github.com/xlkness/erlserver" target="_blank" rel="noopener">github repo</a>）</p><h1 id="四、测试协议收发"><a href="#四、测试协议收发" class="headerlink" title="四、测试协议收发"></a>四、测试协议收发</h1><p>在项目根目录创建一个test目录，然后添加一个proto_tst.erl文件，输入以下内容：</p><pre><code>%%%-------------------------------------------------------------------%%% @author lkness%%% @copyright (C) 2018, &lt;COMPANY&gt;%%% @doc%%%%%% @end%%% Created : 14. Apr 2018 6:27 PM%%%--------------------------------------------------------------------module(proto_tst).%% API-export([    start/0]).start() -&gt;    {ok, Fd} = gen_tcp:connect({127,0,0,1}, 8888, [binary, {packet, raw}, {active, once}]),    GetRoomsInfoReq = #{},    MsgName = erlserver_pb_desc:msg_type(100),    B = erlserver_gobang_pb:encode_msg(GetRoomsInfoReq, MsgName),    SendMsg = &lt;&lt;100:16, B/binary&gt;&gt;,    gen_tcp:send(Fd, SendMsg),    receive        {tcp, _Socket, Packet} -&gt;            &lt;&lt;Cmd:16, Bin/binary&gt;&gt; = Packet,            RecvMsgName = erlserver_pb_desc:msg_type(Cmd),            Msg = erlserver_gobang_pb:decode_msg(Bin, RecvMsgName),            io:format(&quot;sender recv msg:~w/~p~n&quot;, [Cmd, Msg])    after 5000 -&gt;        io:format(&quot;error, not receive from server~n&quot;)    end,    ok.</code></pre><p>然后在我们的user处理模块里，接收socket消息里面添加响应逻辑：</p><pre><code>handle_info({tcp, Socket, &lt;&lt;Cmd:16, Binary/binary&gt;&gt; = Data}, State=#state{socket=Socket, transport=Transport})when byte_size(Data) &gt; 1 -&gt;Transport:setopts(Socket, [{active, once}]),{ok, PeerName} = inet:peername(Socket),MsgName = erlserver_pb_desc:msg_type(Cmd),Msg = erlserver_gobang_pb:decode_msg(Binary, MsgName),lager:info(&quot;receive from client[~w], msg:~p/~p~n&quot;, [PeerName, Cmd, Msg]),SendMsg = #{rooms =&gt; [#{room_id =&gt; 123, seats =&gt; [], audiences =&gt; []}]},SendBin = erlserver_gobang_pb:encode_msg(SendMsg, erlserver_pb_desc:msg_type(101)),Transport:send(Socket, &lt;&lt;101:16, SendBin/binary&gt;&gt;),{noreply, State, ?TIMEOUT};</code></pre><p>可以看到，就是个简单的收发交互，主要是查看协议是否正常编解码和协议描述文件是否正常生成和对应。</p><p>一切就绪，我们可以在测试环境运行rebar shell（因为我们的测试文件放在test目录，default环境启动的话默认不加载test目录），</p><pre><code>rebar3 shell(erlserver@127.0.0.1)6&gt; test_pb:start().sender recv msg:101/#{rooms =&gt;                          [#{audiences =&gt; [],room_id =&gt; 123,seats =&gt; []}]}2018-04-16/20:42:22.774[info][erlserver_user:handle_info:55]|receive from client[{{127,0,0,1},36069}], msg:100/#{}ok</code></pre><p>好，不出意外，就打印了收发消息，我们也看到了收到的字节流正常解码为了协议字段信息。</p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>本节根据具体需求定义了协议文件，然后能将协议文件生成编解码工具，最后还测试了协议收发。</p><p>后面就可以开始编写我们的五子棋游戏了（本来想做个聊天室服务器，感觉太烂大街了，并且im都用ejjabered，自己随手写太low了）。</p><p>（项目<a href="https://github.com/xlkness/erlserver" target="_blank" rel="noopener">repo</a>。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h1&gt;&lt;p&gt;协议的作用很重要，通信协议可以理解为两个节点之间为了协同工作实现信息交换，协商一定的规则和约定，例如规定字节序，各个字段类型
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Erlang" scheme="http://lkness/tags/Erlang/"/>
    
  </entry>
  
  <entry>
    <title>【从零开始构建erlang服务器】-03用户层和日志</title>
    <link href="http://lkness/2018/06/22/034build-erlang-server03/index/"/>
    <id>http://lkness/2018/06/22/034build-erlang-server03/index/</id>
    <published>2018-06-22T12:06:44.000Z</published>
    <updated>2018-06-22T12:46:11.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><pre><code>上一篇讲了创建服务器项目以及添加ranch网络库，本篇利用网络库创建client socket消息处理的用户层代码以及服务器开发调试运维的日志集成。</code></pre><h1 id="二、编写用户层代码"><a href="#二、编写用户层代码" class="headerlink" title="二、编写用户层代码"></a>二、编写用户层代码</h1><pre><code>前面知道网络层处理客户端连接，以及可以将客户端socket文件描述符授权给其它worker进程来一对一为客户端服务（得益于erlang actor模型的轻进程，可以做到一个连接一个进程），而网络库我们使用的ranch，因此可以参照ranch的example程序编写一个处理socket消息的进程，也就是为用户一对一服务器的用户层代码。</code></pre><p>仿照ranch例子创建一个erlserver_user.erl文件</p><p>添加如下代码：</p><pre><code>-module(erlserver_user).-behaviour(gen_server).-behaviour(ranch_protocol).%% API.-export([start_link/4]).%% gen_server.-export([init/1]).-export([handle_call/3]).-export([handle_cast/2]).-export([handle_info/2]).-export([terminate/2]).-export([code_change/3]).-define(TIMEOUT, 5000).-record(state, {socket, transport}).%% API.start_link(Ref, Socket, Transport, Opts) -&gt;    {ok, proc_lib:spawn_link(?MODULE, init, [{Ref, Socket, Transport, Opts}])}.init({Ref, Socket, Transport, _Opts = []}) -&gt;    ok = ranch:accept_ack(Ref),    ok = Transport:setopts(Socket, [{active, once}]),    gen_server:enter_loop(?MODULE, [],                          #state{socket=Socket, transport=Transport},                          ?TIMEOUT).handle_info({tcp, Socket, Data}, State=#state{    socket=Socket, transport=Transport})    when byte_size(Data) &gt; 1 -&gt;    Transport:setopts(Socket, [{active, once}]),    {ok, PeerName} = inet:peername(Socket),    io:format(&quot;receive from client[~w], msg:~p~n&quot;, [PeerName, Data]),    {noreply, State, ?TIMEOUT};handle_info({tcp_closed, _Socket}, State) -&gt;    {stop, normal, State};handle_info({tcp_error, _, Reason}, State) -&gt;    {stop, Reason, State};handle_info(timeout, State) -&gt;    {stop, normal, State};handle_info(_Info, State) -&gt;    {stop, normal, State}.handle_call(_Request, _From, State) -&gt;    {reply, ok, State}.handle_cast(_Msg, State) -&gt;    {noreply, State}.terminate(_Reason, _State) -&gt;    ok.code_change(_OldVsn, State, _Extra) -&gt;    {ok, State}.</code></pre><p>阅读过ranch源码，就知道ranch_acceptor在监听一个客户端连接后，就会调用我们指定的模块的start_link/4方法，当然，我们可以直接在start_link中启动一个gen_server，不过ranch的这个例子因为要有一个ranch:accept_ack操作，所以会阻塞在init，因此没有用gen_server，用了prob_lib:spawn_link，立即返回一个可用的pid给ranch库，然后在慢慢初始化，初始化完成后用gen_server:enter_loop将这个进程转变为一个gen_server进程。</p><h1 id="三、启动ranch监听功能"><a href="#三、启动ranch监听功能" class="headerlink" title="三、启动ranch监听功能"></a>三、启动ranch监听功能</h1><p>上一篇只在app.src启动了ranch，这只是表示应用启动起来，要使ranch开始监听某个端口，还需要显示调用ranch:start_listener/5，这里我们要监听本机8888端口，并且使用我们在第二步写好的客户端socket套接字消息处理进程，其它tcp参数都使用默认，则我们在erlserver_app.erl启动中添加以下代码：</p><pre><code>{ok, _} = ranch:start_listener(erlserver,                                  ranch_tcp, [{port, 8888}], erlserver_user, []),</code></pre><p>rebar3 shell启动我们的应用测试一下是否可用，另开一台机器进入erlang shell，输入{ok, Fd} = gen_tcp:connect({xxx,xxx,xxx,xxx}, 8888, [binary, {active, false}, {packet, raw}]), gen_tcp:send(Fd, “for test”).  看到输出，就说明现在可以创建一个并发服务器了，并且每个客户端连接都对应一个erlserver_user进程单独处理。</p><h1 id="四、添加lager日志库"><a href="#四、添加lager日志库" class="headerlink" title="四、添加lager日志库"></a>四、添加lager日志库</h1><p>在第二步的代码中，我们用了io:format来打印收到的客户端信息，这样做其实是不好的，终端打印的消息无法输出到文件记录下来，并且io打印的消息都是原始消息，不方便调试，要同时输出模块、行号等信息，每一次的io打印还都要加上这些信息，总之，对于服务器来说，没有一个专门的日志记录都是不好的。</p><h2 id="1、rebar-config添加依赖："><a href="#1、rebar-config添加依赖：" class="headerlink" title="1、rebar.config添加依赖："></a>1、rebar.config添加依赖：</h2><pre><code>{lager, {git, &quot;https://github.com/erlang-lager/lager&quot;, {branch, &quot;master&quot;}}}</code></pre><h2 id="2、erlserver-app-src启动lager"><a href="#2、erlserver-app-src启动lager" class="headerlink" title="2、erlserver.app.src启动lager"></a>2、erlserver.app.src启动lager</h2><p>（lager的顺序尽量放在除erlang runtime库之前，例如放在ranch之前，这样我们就可以在其它应用启动中也能使用lager输出应用启动的信息了）。</p><h2 id="3、添加lager配置"><a href="#3、添加lager配置" class="headerlink" title="3、添加lager配置"></a>3、添加lager配置</h2><p>这里前期为了调试方便，我们直接利用rebar3 shell加载一个本地调试配置文件<br>        在项目根目录创建一个config文件夹，并在里面创建一个erlserver.config配置文件，输入以下内容</p><pre><code>[    {lager, [        {log_root, &quot;./log&quot;},        {handlers, [            {lager_console_backend,             [{level, info}, {formatter, lager_default_formatter},              {formatter_config, [date, &quot;/&quot;, time, &quot;[&quot;, severity, &quot;][&quot;, module, &quot;:&quot;, function, &quot;:&quot;, line,&quot;]&quot;, &quot;|&quot;, message, &quot;\n&quot;]}]},            {lager_file_backend,             [{file, &quot;error.log&quot;}, {level, error}, {formatter, lager_default_formatter},              {formatter_config, [date, &quot;/&quot;, time, &quot;[&quot;, module, &quot;:&quot;, function, &quot;:&quot;, line,&quot;]&quot;, &quot;|&quot;, message, &quot;\n&quot;]}]},            {lager_file_backend,             [{file, &quot;console.log&quot;}, {level, info}, {formatter, lager_default_formatter},              {formatter_config, [date, &quot;/&quot;, time, &quot;[&quot;, module, &quot;:&quot;, function, &quot;:&quot;, line,&quot;]&quot;, &quot;|&quot;, message, &quot;\n&quot;]}]}        ]}    ]}].</code></pre><p>这就是一个lager的简单配置，日志都输出到log目录，并且info对应console.log文件（目前都是本地调试，并不是发布的配置）。</p><h1 id="4、配置rebar3-shell读取config文件以及添加lager的parse-transform"><a href="#4、配置rebar3-shell读取config文件以及添加lager的parse-transform" class="headerlink" title="4、配置rebar3 shell读取config文件以及添加lager的parse_transform"></a>4、配置rebar3 shell读取config文件以及添加lager的parse_transform</h1><p>修改rebar.config的shell配置</p><pre><code>{shell, [    {apps, [erlserver, sync]},    {config, &quot;config/erlserver.config&quot;}]}.</code></pre><p>修改rebar.config的erl_opts配置（这里使用到的知识点可以参考我的另一篇erlang抽象语法树博客）</p><pre><code>{erl_opts, [    debug_info,    {parse_transform, lager_transform}]}.</code></pre><h1 id="五、使用日志库"><a href="#五、使用日志库" class="headerlink" title="五、使用日志库"></a>五、使用日志库</h1><p>修改第二步的erlserver_user的io:format打印为lager:info(“xxxxx”),再来尝试客户端连接并且传输信息。</p><h1 id="六、后续"><a href="#六、后续" class="headerlink" title="六、后续"></a>六、后续</h1><p>客户端消息处理层（用户层）以及日志都写好了，后续开始制定协议层了。</p><p>（project-<a href="https://github.com/xlkness/erlserver.git）" target="_blank" rel="noopener">https://github.com/xlkness/erlserver.git）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;上一篇讲了创建服务器项目以及添加ranch网络库，本篇利用网络库创建client socket消息处理的用户
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Erlang" scheme="http://lkness/tags/Erlang/"/>
    
  </entry>
  
  <entry>
    <title>【从零开始构建erlang服务器】-02构建应用</title>
    <link href="http://lkness/2018/06/22/033build-erlang-server02/index/"/>
    <id>http://lkness/2018/06/22/033build-erlang-server02/index/</id>
    <published>2018-06-22T12:06:28.000Z</published>
    <updated>2018-06-22T12:47:03.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>开始一个erlang服务器应用的构建。<br>项目管理工具使用rebar3。配置方式参考我另一篇ubuntu16+ideaIC+rebar3搭建erlang开发环境</p><h1 id="二、新建应用"><a href="#二、新建应用" class="headerlink" title="二、新建应用"></a>二、新建应用</h1><p>服务器应用名：erlserver，终端执行：</p><pre><code>rebar3 new app erlserver===&gt; Writing erlserver/src/erlserver_app.erl===&gt; Writing erlserver/src/erlserver_sup.erl===&gt; Writing erlserver/src/erlserver.app.src===&gt; Writing erlserver/rebar.config===&gt; Writing erlserver/.gitignore===&gt; Writing erlserver/LICENSE===&gt; Writing erlserver/README.md</code></pre><p>此时在当前目录就生成了erlserver项目文件夹。</p><h1 id="三、添加本地调试配置"><a href="#三、添加本地调试配置" class="headerlink" title="三、添加本地调试配置"></a>三、添加本地调试配置</h1><pre><code>{deps, [    sync]}.{shell, [    {apps, [erlserver, sync]}]}.{dist_node, [    {setcookie, &apos;only4test&apos;},    {name, &apos;erlserver@127.0.0.1&apos;}]}.</code></pre><p>sync是个erlang shell应用，可以动态更新编译最新erlang项目代码，{shell…是rebar3 shell的配置和启动的应用。</p><h1 id="四、运行应用"><a href="#四、运行应用" class="headerlink" title="四、运行应用"></a>四、运行应用</h1><p>shell执行：<code>rebar3 shell</code></p><pre><code>===&gt; Compiling erlserverErlang/OTP 20 [erts-9.0] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:0] [hipe] [kernel-poll:false]Eshell V9.0  (abort with ^G)(erlserver@127.0.0.1)1&gt; ===&gt; The rebar3 shell is a development tool; to deploy applications in production, consider using releases (http://www.rebar3.org/docs/releases)Starting Sync (Automatic Code Compiler / Reloader)Scanning source files...===&gt; Booted erlserver===&gt; Booted syntax_tools===&gt; Booted compiler===&gt; Booted sync</code></pre><p>以上结果可以看到，执行了rebar3 shell之后，会先编译整个项目，然后运行erlserver应用节点，这时候我们就进入了一个erlang shell，并且已经启动了erlserver,sync应用。</p><h1 id="五、集成网络库"><a href="#五、集成网络库" class="headerlink" title="五、集成网络库"></a>五、集成网络库</h1><p>这里我们使用开源的erlang tcp网络库ranch</p><h2 id="1、添加依赖"><a href="#1、添加依赖" class="headerlink" title="1、添加依赖"></a>1、添加依赖</h2><p> 在rebar.config的deps里添加一个ranch依赖：</p><pre><code>{deps, [    sync,    {ranch, {git, &quot;https://github.com/ninenines/ranch&quot;, {branch, &quot;master&quot;}}}]}.</code></pre><p>经过这步就将ranch下载下来，但是依然没有将其运行起来。</p><p>在erlserver.app.src的依赖应用里面添加ranch：</p><pre><code>{applications,   [kernel,    stdlib,    ranch   ]},</code></pre><p>五、测试网络库</p><p>经过以上步骤，ranch就集成进项目了，使用rebar3 shell运行节点，可以看到ranch应用已经启动。测试ranch能否正常启动和监听端口（照着ranch的example可以创建简单的echo服务器试试）</p><p>六、后续展望</p><p>服务器项目已经构建，网络库也集成进来了，后面会开始利用ranch创建客户端一对一服务器进程树、以及利用protocol buffer协议做请求与服务、单元测试、common test、应用发布和部署等等。</p><p>（project-<a href="https://github.com/xlkness/erlserver.git）" target="_blank" rel="noopener">https://github.com/xlkness/erlserver.git）</a></p><p>（未完待续。。。）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h1&gt;&lt;p&gt;开始一个erlang服务器应用的构建。&lt;br&gt;项目管理工具使用rebar3。配置方式参考我另一篇ubuntu16+ideaI
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Erlang" scheme="http://lkness/tags/Erlang/"/>
    
  </entry>
  
  <entry>
    <title>【从零开始构建erlang服务器】-01网络库</title>
    <link href="http://lkness/2018/06/20/032build-erlang-server01/index/"/>
    <id>http://lkness/2018/06/20/032build-erlang-server01/index/</id>
    <published>2018-06-20T12:38:16.000Z</published>
    <updated>2018-06-20T12:45:02.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p> 网络库是服务器的基础。有了网络库，服务器就能接收外界消息，提供服务。因此开始就从网络库入手。这里先构建基础的TCP通信网络库。至于UDP、WebSocket这些通信手段暂不说。</p><h1 id="gen-tcp"><a href="#gen-tcp" class="headerlink" title="gen_tcp"></a>gen_tcp</h1><p> erlang的底层是c语言封装的，因此其socket通信在beam层也是经过封装的，更易使用。告别跟系统绑定的select/poll/epoll/iocp/kqueue的复杂操作，我们只需要根据gen_tcp的官方文档，就能构建简单好用的tcp服务器。</p><h1 id="惊群效应"><a href="#惊群效应" class="headerlink" title="惊群效应"></a>惊群效应</h1><p> 惊群效应就是多进程或多线程同时阻塞等待相同事件时，假如事件不阻塞而是返回结果了，那么所有阻塞的进程或线程就会唤醒，但是却只有一个进程或线程能获得这个时间的“控制权”，对该事件进行处理，而其它竞争失败的就只能重新休眠。这样多个进程或线程同时唤醒但大部分都做无用功，cpu上下文白切换。</p><p>比较典型的就是accept函数。</p><p>例如linux的socket监听套接字创建流程是：</p><ol><li>int socket(int domain, int type, int protocol) //指定协议版本(IPv4/IPv6)，指定通信类型(TCP/UDP/RAW)</li><li>int bind(int socket, const struct sockaddr *address, socket_t address_len) // 将socket套接字绑定到一个网卡</li><li>int listen(int socket, int backlog) // 将socket套接字转变为连接套接字</li><li><p>int accept(int socket, struct sockaddr <em>, socklen_t </em>) // 监听一个客户端的连接</p><p>第1、2步没什么好说，第3步的listen，需要指定一个backlog参数，何谓backlog？linux内核对于tcp三次握手，维护了两个队列，一个用于客户端请求握手的队列，一个用于完成了握手的队列。客户端完成了握手，就从第一个队列转移到第二个队列如果accept接受了请求，就将握手的客户端从第二个队列删除，那么backlog就指定第二个队列的长度。可见，如果客户端connect并发太多间隔太短，而accept的接受速度如果太慢，backlog到了最大长度，就会对新到来的客户端响应RST分节，可见的抓包握手消息就是（三次握手在第一步“你好在吗”就返回错误了）：</p><p>client-&gt;server : SYN</p><p>server-&gt;client : RST</p></li></ol><p><strong>个人猜测，未去证实：</strong></p><p>因此可以增大backlog的数量，也可以多几个acceptor来做监听。才有了用多进程、多线程来做accept操作。不过linux2.6内核以后，就改善了accept的惊群问题，多个acceptor。</p><h1 id="gen-tcp-accept-2"><a href="#gen-tcp-accept-2" class="headerlink" title="gen_tcp:accept/2"></a>gen_tcp:accept/2</h1><p>gen_tcp的核心函数我觉得就是accept，正如官方文档上写的：</p><blockquote><p>The accept call does not have to be issued from the socket owner process. Using version 5.5.3 and higher of the emulator, multiple simultaneous accept calls can be issued from different processes, which allows for a pool of acceptor processes handling incoming connections.</p></blockquote><p>文档明确说了可以用多个acceptor来针对同一个监听套接字做客户端监听。</p><p>（底层也只有一个OS线程做accept，可能给多个做accept的erlang轻进程做竞争，accept返回即选择一个轻进程分发clientfd，参见<a href="https://github.com/alibaba/erlang_multi_pollset" target="_blank" rel="noopener">https://github.com/alibaba/erlang_multi_pollset</a>)</p><h1 id="简单tcp服务器代码"><a href="#简单tcp服务器代码" class="headerlink" title="简单tcp服务器代码"></a>简单tcp服务器代码</h1><p>官方文档的一个简单实现：</p><pre><code>start(Num,LPort) -&gt;    case gen_tcp:listen(LPort,[{active, false},{packet,2}]) of        {ok, ListenSock} -&gt;            start_servers(Num,ListenSock),            {ok, Port} = inet:port(ListenSock),            Port;        {error,Reason} -&gt;            {error,Reason}    end.start_servers(0,_) -&gt;    ok;start_servers(Num,LS) -&gt;    spawn(?MODULE,server,[LS]),    start_servers(Num-1,LS).server(LS) -&gt;    case gen_tcp:accept(LS) of        {ok,S} -&gt;            loop(S),            server(LS);        Other -&gt;            io:format(&quot;accept returned ~w - goodbye!~n&quot;,[Other]),            ok    end.loop(S) -&gt;    inet:setopts(S,[{active,once}]),    receive        {tcp,S,Data} -&gt;            Answer = process(Data), % Not implemented in this example            gen_tcp:send(S,Answer),            loop(S);        {tcp_closed,S} -&gt;            io:format(&quot;Socket ~w closed [~w]~n&quot;,[S,self()]),            ok    end.</code></pre><p> 这个代码就是启动Num数量个acceptors来做客户端连接监听，但是这个代码效率不高，这里的acceptor即做accept工作，又做客户端任务处理的逻辑，既是acceptors pool，也是worker pool，如果客户端请求的服务器任务处理时间太长的话，当前处理进程的accept工作也一起阻塞在那里。</p><h1 id="优化accept"><a href="#优化accept" class="headerlink" title="优化accept"></a>优化accept</h1><p> 这里要提到erlang socket套接字的归属权，初始时只有做accept的进程有权处理返回的socket消息，因此我们上面第四步才能直接在loop函数里receive {tcp, S, Data}处理，但也因此带来了阻塞acceptor的风险。</p><p>如果可以转让归属权，是不是我们就能解放acceptor的工作，它只需要做单一的accept工作，一旦有客户端连接，返回了客户端套接字，我们就将归属权转让给其它进程去处理今后所有客户端的请求服务器？</p><p>是的。这个函数就是gen_tcp:controlling_process/2。有了这个函数，我们就可以解放acceptor的工作。将socketFd交给其它worker进程去处理。</p><h1 id="tcp调参"><a href="#tcp调参" class="headerlink" title="tcp调参"></a>tcp调参</h1><p>经过上面步骤，初步的监听框架有了，并且可以启动很多acceptors来做accept工作，beam以上的accept性能似乎已经没有问题了（只有beam虚拟机用单个OS thread做connect事件监听可能会影响速度，不过我们只需要做好我们代码能做到的就可以了，multi-pollset会在20.3之后某个版本发布）。</p><p>余下的工作就是tcp调参了。</p><p>众所周知，tcp是个全双工可靠通信，为了实现这个特性，tcp底层实现用了很多算法来支撑、优化tcp。</p><p>例如小块数据发送策略-Nagle算法、成块数据流发送策略-滑动窗口、慢启动、超时与重传、发送定时器、keepalive定时器、tcp状态转换等等。</p><p>因此，在os系统调用层就能优化很多操作，而beam又在系统api上面封装了socket操作，也会加一些erlang的tcp特性参数。</p><p>这里大概说一下重要的一些参数，其它的请参考官方文档：</p><p><a href="http://erlang.org/doc/search/?q=meck&amp;x=0&amp;y=0?q=meck&amp;x=0&amp;y=0" target="_blank" rel="noopener">http://erlang.org/doc/search/?q=meck&amp;x=0&amp;y=0?q=meck&amp;x=0&amp;y=0</a></p><h2 id="backlog"><a href="#backlog" class="headerlink" title="backlog"></a>backlog</h2><p>上文有提到，是一个完成三次握手但还没有被应用层accept的客户端请求最大数量</p><h2 id="nodelay"><a href="#nodelay" class="headerlink" title="nodelay"></a>nodelay</h2><p>tcp对待小块数据，是先缓存起来不立即发送（如果小块数据也默认发送，可能会造成广域网消息拥塞），等到数据量多一点再一起发，<br>这个就是tcp的Nagle算法。而要不延迟发送的服务器可以设置为true，例如telnet客户端、ssh客户端等，按一个键盘按键就要发送一个<br>按键字母。</p><h2 id="active"><a href="#active" class="headerlink" title="active"></a>active</h2><p>分为三种模式：</p><ul><li>true-非阻塞，tcp消息会以{tcp, Socket, Data}的进程普通消息发到socket套接字归属进程</li><li>false-阻塞，必须显式调用gen_tcp:recv/2来接收消息</li><li>once-半阻塞（官方推荐的方式），这种模式是非阻塞的接收一个消息，但是在收到一个消息后，<pre><code>必须再次调用inet:setopts(Socket, [{active, once}])来重新设置才能再接收到消息（这个的作用是，单纯用true模式太粗暴，如果收速小于发速，beam要盲目接收外界消息  然后转换成进程消息，很容易被大量的数据撑爆进程邮箱，而如果用false模式阻塞接收，  进程必须自己做recv后的逻辑处理，处理完毕又自己做轮询recv，让消息处理变得复杂，  因此有了once模式，即有true模式的消息事件触发方式，又有false模式的消息限速安全性）</code></pre><h2 id="reuseaddr"><a href="#reuseaddr" class="headerlink" title="reuseaddr"></a>reuseaddr</h2>TCP四次挥手过程中，先发起关闭连接的一方会进入TIME_WAIT状态。TIME_WAIT是指四次挥手中主动方最后一次接收到对方的关闭请求后，自己响应了ACK消息后等待2MSL(最大报文生存时间Maximum Segment Lifetime，一个MSL可能是30s 1m 2m)才能关闭本端。原因是：tcp作为全双工的管道，关闭时也要实现全双工，即双方明确知道都关闭了管道。因此在先发起关闭的一方最后一次响应ACK后要等待对方告诉自己它已经收到ACK消息，而不是说这个ACK消息在还没被对方收到就失去了，如果对方没有收到，就要重新发送ACK，这才是可靠关闭的实现。而这个2MSL期间，再想重新启动这个端口的监听模式是错误的。</li></ul><p>举个例， 如果设置不能重用地址， 服务器程序打开了端口8888，这时候遇到一个错误，服务器宕了，监控程序立马检测到服务器宕了，执行重启服务器逻辑，却发现一直重启不了，直到2MSL过了。</p><h1 id="编写网络库"><a href="#编写网络库" class="headerlink" title="编写网络库"></a>编写网络库</h1><p>根据以上总结，我们可以容易编写一个简单网络库，支持大量连接，但一个工业强度网络库的诞生，必然伴随着大量测试的千锤百炼。</p><p>这里我实现了一个简单的网络库，还没有测过客户端异常关闭等等socket套接字管理问题：<br><a href="https://github.com/xlkness/erlnet" target="_blank" rel="noopener">https://github.com/xlkness/erlnet</a></p><p>因此我们编写网络库，只是做一个学习作用，知道网络库的作用，如何并发连接，消息并发接收等等，因为网络库的重要性，有了网络库，才能进行接下来的协议层，才能针对客户端请求消息提供对应的服务，有了服务才会根据服务器进行更深的业务和方案选择。</p><p>真正的使用还是寻找一些开源的网络库，例如ranch：</p><p><a href="https://github.com/ninenines/ranch" target="_blank" rel="noopener">https://github.com/ninenines/ranch</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt; 网络库是服务器的基础。有了网络库，服务器就能接收外界消息，提供服务。因此开始就从网络库入手。这里先构建基础的TCP通信网络库。至于UDP、
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Erlang" scheme="http://lkness/tags/Erlang/"/>
    
  </entry>
  
  <entry>
    <title>paxos-simple</title>
    <link href="http://lkness/2018/06/20/031paxos/index/"/>
    <id>http://lkness/2018/06/20/031paxos/index/</id>
    <published>2018-06-20T12:25:06.000Z</published>
    <updated>2018-06-20T12:37:55.248Z</updated>
    
    <content type="html"><![CDATA[<p>上周给组里分享课程，其中讲到了paxos，觉得没讲好，遂决定看看paxos论文，看的时候有的枯涩的地方就翻译到文本里记录，翻译得越来越多，索性都翻译了吧 …</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>在实现一个容错分布式系统时，人们认为Paxos算法理解起来很困难，大概对于很多读者来说最初的陈述是用的希腊语。事实上，它是分布式算法中最简单也最明显的一种。</p><p>它本质上是一个共识算法-the “synod” algorithm of。下一节叙述了这种共识算法几乎不可避免地遵循我们想让它满足的属性条件。最后一节解释了完整的Paxos算法：通过简单的状态机的共识程序来构建一个分布式系统-这应该是被广为人知的，因为它在分布式系统理论文章中被引用最多的。</p><h1 id="2-一致性算法"><a href="#2-一致性算法" class="headerlink" title="2. 一致性算法"></a>2. 一致性算法</h1><h2 id="2-1-问题"><a href="#2-1-问题" class="headerlink" title="2.1 问题"></a>2.1 问题</h2><p>假设有一些进程可以提议values。一个共识算法可以保证在这些提议的values中只有一个value被选中。如果没有提议任何value，那么也没有任何value被选中。</p><p>如果一个value被选中了，那么这些进程应该能够学习这个被选中value。协商一致的安全性要求如下：</p><ul><li>只能发起提议的value能被选中</li><li>只能有一个值被选中</li><li>并且一个进程只能获取到真正被选中的value</li></ul><p>我们不用尝试指定精确的要求。但是目标是保证一些被提议的value最终会被选中，并且当一个value被选中，那么某个进程最终都能获取到这个value。</p><p>在共识算法中我们使用三个角色由三个种类代理：proposers、acceptors、learners（提议者、接受者、结果学习者）。在一个具体实现中，单个进程可能同时扮演多种代理，，但是从从代理到进程的映射关系我们并不关心。</p><p>假设这些代理能够通过发送消息相互交流。我们使用异步、非拜占庭模型：</p><ul><li>这些代理的执行是任意速度的，也可能发生故障而停止，也可能重启。因为所有的代理都可能在选中一个value后发生故障并且重启，因此这些代理必须持久化一些信息，即使发生故障和重启（也能恢复）</li><li>发送的消息可以是任意长度的、可能重复、可能丢失，但是不能被篡改。</li></ul><h2 id="2-2-选中一个value"><a href="#2-2-选中一个value" class="headerlink" title="2.2 选中一个value"></a>2.2 选中一个value</h2><p>最简单的方法是使用单个acceptor代理来选中一个值。某个proposer发送一个提议给acceptor，acceptor选择它接收到的第一条消息的value。虽然简单，但是这种方法不能满足我们的要求，因为假如acceptor发生故障，就会导致接下来的步骤失败。</p><p>因此，让我们尝试其它的方式来选择一个value。现在用多个acceptor代理来代替单个acceptor。某个proposer给这些acceptor都发送一个提议value。某个acceptor可能会接受这个value。那么这个value当足够数量的acceptor都接受这个value时，就能通过选中这次value了。多大的数量才足够？为了保证仅仅只有一个value被选中，我们让超过半数的acceptor作为这个足够大的数量。因为对于一个acceptor集合，其中任意两个超过半数的子集合至少有一个公共的acceptor。如果一个acceptor只能选中至多一个值，那么这种方法就是可行的。</p><p>在没有故障发生和消息丢失的情况下，我们想要让一个value被选中，哪怕仅仅只有单个proposer发起一次提议value。这就需要满足以下要求：</p><blockquote><p>P1: An acceptormust accept the first proposal that it receives.</p><p>（一个acceptor必须接受它第一个收到的提议的value）</p></blockquote><p>但是这个要求又引起一个问题。多个values可能同时被好几个不同proposers提议，导致了一种情形：每个acceptor都接收到value，但是没有一个value是被超过半数的acceptor所选中。即使只提出了两个提议value，如果每个value各自都被半数acceptor选中，那么任意单个acceptor故障都可能让leaner获取哪一个value被选中变为不可能。</p><p>P1规约以及一个value只有被超过半数acceptor所接受才算被选中这两个条件意味着一个acceptor必须能够接受多个提议。我们给不同的提议指定一个编号来追踪这些提议，因此一个提议就由提议号（proposal number）和value组成。为了防止冲突，我们要求不同的提议用不同的提议号。这个不同的提议号如何实现，依赖具体的实现，当前我们先假设它（已经实现）。如果一个提议的value被超过半数的acceptor所接受，那么这个value就被选中。这种情况下，我们就说这个提议被选中。</p><p>我们可以允许多个提议被选中，但是我们必须保证这些被选中的提议都拥有相同的value。通过归纳提议号，就足以保证：</p><blockquote><p>P2: If a proposal with value v is chosen,then every higher-numbered pro-posal that is chosen has value v.</p><p>（如果一个value为v的提议被选中，那么其后每一个更高提议号的提议value也要是v）</p></blockquote><p>因为提议号都是有序的，条件P2保证了关键的安全性属性：仅仅只有一个value能被选中。</p><p>为了被选中，一个提议必须被至少一个acceptor所接受。因此，我们能通过满足以下条件来满足P2：</p><blockquote><p>P2a: If aproposal with value v is chosen, then every higher-numbered pro-posal accepted by any acceptor has value v.</p><p>（如果一个value为v的提议被选中，那么每个被acceptor所接受的具有更高提议号的提议的value也要是v）</p></blockquote><p>我们依然需要P1来保证有提议能被选中。因为交流是异步的，一个提议可能被一些特殊的acceptor c所选中，但是它们没有接受过其它任何提议。假设一个新的proposer“醒过来（重启或从故障中恢复）”，然后发送了一个带有更高提议号且不同value的提议。P1只要求c接受这个提议，但是却违背了P2a。为了同时满足P1和P2a，需要加强P2a：</p><blockquote><p>P2b: If a proposal with value v ischosen, then every higher-numbered pro-posal issued by any proposer has value v.</p><p>（如果一个value为v的提议被选中，那么所有发送具有更高提议号的proposer的value也是v）</p></blockquote><p>因为一个提议在被acceptor接受之前必须是proposer发出，P2b满足了P2a，也满足了P2。</p><p>为了明白如何满足P2b，让我们思考如何证明它。我们假设有一些提议号为m，value为v的提议已经被选中，然后我们证明以后的任何提议号n（n&gt;m）的提议，其value为v。我们可以归纳法到n来简化证明，在这种假设下，我们就证明所有发起的提议号为m..(n-1)的提议，其value都为v，其中i..j表示提议号范围为i-j。既然提议号为m的提议被选中，那么必然有一个超过半数acceptors的集合C接受了它。与归纳假设结合，假设提议m被选中可以推论出：</p><blockquote><p>Everyacceptor in C has accepted a proposal with number in m ..(n − 1),and every proposal with number in m ..(n − 1) accepted by any acceptor has value v.</p><p>（超半数集合C中的每一个acceptor都接受了一个提议号从m..(n-1)的提议，且每一个提议被接受时，value都为v）</p></blockquote><p>因为任意超半数的acceptor集合S中，至少有一个是C的成员，我们可以得出结论，通过确保以下的条件来保持提议n的value为v：</p><blockquote><p>P2c:For any v and n, if a proposal with value v and number n is issued,then there is a set S consisting of amajority of acceptors such thateither (a) no acceptor in S has acceptedany proposal numbered less than n, or (b) v is the value of the highest-numbered proposal among all proposals numbered less than n acceptedby the acceptors in S.</p><p>（对于任意的提议n和value v，如果一个提议号为n，value为v的提议产生了，那么就存在一个包含了超过半数acceptor的集合S，这个集合中要么没有acceptor批准过任意比n小的提议，要么v就是S中的acceptor选中的提议号小于n的最大编号提议所具有的value）</p></blockquote><p>我们可以因此满足P2c来满足P2b。</p><p>为了满足P2c，一个proposer想产生一个提议n，它就必须获取提议号小于n且已经或将要被超过半数acceptor接受的最大提议的value。获取已经被接受过的提议是很简单的，但是预测将要被接受的结果就很困难。不用预测未来，proposer只要承诺自己不会获得这样的接受情况就可以了。换句话说，proposer请求所有acceptor不要接受任何比（它自己提议号）n小的提议。这就推导出一下算法来生成提议：</p><ul><li><p>一个proposer选择新的提议号n，然后发送请求给所有acceptor，询问它回复如下内容：</p><p>  (a). 承诺不再接受比n小的提议</p><p>  (b). 如果接受了小于n的提议，就返回接受的提议内容</p><p>  我们称这样的请求为带有提议号为n的prepare请求</p></li><li>如果proposer接受到超过半数的acceptor响应，接下来它就能发出value为v的提议n，value v要么是响应的消息中acceptor接受过的最大提议号的value，要么是所有acceptor都还没接受value时proposer自己提议的value。</li></ul><p>一个proposer发送提议消息给一些acceptor集合，请求它们接受。（这个集合不一定就是初始请求后响应了的acceptor集合）让我们称它为accept请求。</p><p>这个描述的是proposer的算法。Acceptor的算法呢？acceptor能接受两种请求：prepare请求和accept请求。一个acceptor能够在不影响安全性的条件下忽略任何请求。所以，我们只需要讨论它可以回复（proposer）请求的情况。它通常都能够响应一个prepare请求。如果acceptor没有承诺不接受某种提议，那么它就能响应这种提议，并接受它。换句话说：</p><blockquote><p>P1a:An acceptor can accept a proposal numbered n if it has not responded to a prepare request having a numbergreater than n.</p><p>（一个acceptor如果没有响应比n大的prepare请求，它就能接受提议n）</p></blockquote><p>可以看到P1a包含P1。</p><p>现在我们已经有了一个完整的并能满足安全性的算法来选中一个value—假设使用的都是唯一的提议编号的情况。最终的算法通过一点点的小优化来实现。</p><p>假设一个acceptor接收到一个prepare请求n，但是它早已响应过了比n大的prepare请求，因此它承诺不会接受任何提议n。acceptor也没有任何理由响应这次prepare请求，因此它不会接受提议n。我们就让acceptor忽略这种prepare请求。同时我们也让acceptor忽略早就被接受过的prepare请求。</p><p>经过这种优化，acceptor仅仅只需要记住它曾接受过的最大编号的提议和它响应过的最大编号的prepare请求。P2c必须被满足哪怕发生了故障，因此acceptor也必须记住这些信息即使发生了故障和重启。注意proposer可以丢弃一个提议然后忘掉所有信息，只要它不会又发送相同编号的提议。</p><p>将proposer和acceptor放在一起，我们可以得到算法操作分下面两阶段：</p><p><strong>阶段1：</strong></p><ul><li>某个proposer选择一个提议号n，然后用提议号n发送一个prepare请求给超过半数的acceptor；</li><li>如果一个acceptor接收到提议号为n的prepare请求，且提议号n比它曾经响应过的提议号更大，那么它就响应proposer，响应内容是：保证不会接受任何比n更小的提议以及它曾经接受过的最大编号提议的value（如果有的话）</li></ul><p><strong>阶段2</strong></p><ul><li>如果proposer接收到超过半数的acceptor对于提议n的响应，那么它就给每个响应了的acceptor发送一个accept请求，提议号还是n，且value要么是那些acceptor响应消息里带有接受过的最大提议号的value，要么那些acceptor都没有接受任何提议，那value就是proposer自己任选；</li><li>如果一个acceptor接收到提议号为n的accept请求，它就会接受这次accept请求（并选中请求带有的value）除非它之前又响应过比n更高的prepare请求。</li></ul><p>一个proposer可以产生多个提议，只要它能满足算法的每个要求。它也可以在协议进行到任何阶段任何时间丢弃提议。（正确性是能保证的，哪怕某个提议请求或者其响应消息可能在很久之后才到达目的地，而这之前这个提议就被丢弃了。）当有其它proposer已经开始用更高的提议号尝试发起投票了，放弃此次提议是个好主意。因此，如果一个acceptor因为它已经接受过更高提议号的提议而忽略当前prepare或accept请求时，它应该通知那个proposer让它放弃这次提议。这是一个并不影响正确性的优化点。</p><h2 id="2-3-获取一个被选中的值"><a href="#2-3-获取一个被选中的值" class="headerlink" title="2.3 获取一个被选中的值"></a>2.3 获取一个被选中的值</h2><p>（learner）为了习得一个被选中的value，一个learner必须找出被大多数批准者接受的那次提议。明显的算法是让每个acceptor无论什么时候选中了一个提议，就给所有learner响应那次提议的信息。这可以让learners尽快知道选中的value，但是这种方法需要每个acceptor给每个learner发送大量的消息。</p><p>非拜占庭模型（non-Byzantine model）错误的假设下，某个learner能够容易地从其它learner那里知道被选中的value。我们可以让acceptor响应批准的投票信息给distinguished learner（主学习者），然后distinguished learner再轮流响应给其它learner。这种方法需要额外一轮操作来让所有learner发现被选中的value。它也是不可靠的，因为distinguished learner可能会发生异常。并且它也需要acceptor的数量加上learner的数量这么多消息响应。</p><p>更普遍的做法是，acceptors可以响应它们的批准信息给部分被选中distinguishedlearners，每一个distinguished learner又能通知所有learner。如果distinguished learners的数量很多，这可以保证更好地可靠性，但也带来了交流复杂性上的消耗。</p><p>由于分布式中消息可能出现丢失，就可能出现一个提议被选中了但是没有learner知道这次投票结果。learners可以询问acceptors哪一个提案被选中了，假设出现了一个acceptor不知道是哪次提案被选中了或者没有提案出现了超过半数的投票。在这种情况下，只有新的一次提案被选中了，learners才能知道哪一个value被选中。如果一个learner需要知道一个value是否被选中，它可以让一个proposer发起一次这个value的提议。</p><h2 id="2-4-过程保证"><a href="#2-4-过程保证" class="headerlink" title="2.4 过程保证"></a>2.4 过程保证</h2><p>我们可以简单构建一种情形：两个proposer不断地用更高的序号发起投票，但是没有一次投票被选中（活锁）。proposer p用提议号n1完成了阶段1(Phase 1)。接着另一个proposer q又用大于n1的提议号n2完成了阶段1(Phase1)。接着p开始进行阶段2(Phase 2)（因为阶段1用n1收到的超过半数响应因此可以进行阶段2），但是发送的accept请求没有收到响应或者收到的都是拒绝消息，因为n1编号小于此时acceptors维护的编号n2。因此，p又用新的编号n3发起投票，并完成阶段1。再来看proposer q，它当前完成了阶段1，然后发起第二阶段消息请求，但是收到了拒绝的响应（因为n2&lt;n3了），它又用n4发起新投票……如此往复。</p><p>为了保证过程（正常进行），必须要选一个distinguished proposer来发起提案。如果这个distinguished proposer能成功地跟超过半数acceptors交流，并且每次都使用比曾经使用的提议编号大的编号，那么它就能成功发起一次提议并被acceptors接受。当distinguished proposer知道自己（发起提议）的编号太低时，通过放弃提议并且重新（用更高的编号）尝试，最终选择一个足够高的编号。</p><h2 id="2-5-实现"><a href="#2-5-实现" class="headerlink" title="2.5 实现"></a>2.5 实现</h2><p>Paxos算法假定一个有多个进程的网络。在它的共识算法中，每个进程同时扮演proposer、acceptor和learner。通过算法选择一个leader来作为distinguished proposer和distinguished learner。Paxos一致性算法正是上面描述的消息和请求都作为普通消息发送的确切实现算法。（响应消息也一样被标记上一致的提议编号来防止混淆。）当异常发生时，稳定的存储用来持久化批准者必须记住的信息。响应proposer之前，acceptor在存储系统中记录它准备要响应的消息。</p><p>最后剩下要做的就是描述如何避免两个提议用了两个相同的提议编号。如果不同的proposer从不相交的数字集合里选择他们的提议编号，那么两个提议绝不会产生相同编号的提议。每个proposer持久化它用过的最高的提案编号，然后在开始Paxos一阶段时就使用一个比用过的最高的提案编号更高的编号。</p><h1 id="3-实现一个状态机"><a href="#3-实现一个状态机" class="headerlink" title="3. 实现一个状态机"></a>3. 实现一个状态机</h1><p>实现一个分布式系统的简单方式是（将分布式系统的节点）当做一批客户端，都产生命令到一个中央服务器。这个中央服务器能被描述为按某种顺序来执行客户端命令的一个确定性状态机。这个状态机有一个当前状态；它执行一步可以看作：输入一个命令-&gt;产生一个输出结果-&gt;切换到新状态。举个例，分布式银行系统的客户端可能是出纳员，系统里的状态机维护的状态信息可能包含所有用户的账户余额。那么一次提款就能描述为：仅当余额比提款额大时，执行“减少账户余额”的状态机命令-&gt;产生一个包含旧余额和新余额的结果。</p><p>仅使用单个中央服务器的实现会面临单点失效问题。因此用一批服务器来代替一个中央服务器，每个服务器都是一个独立的状态机。因为这些状态机是确定性的，如果它们接收并执行的指令序列都是相同的话，那么它们也会产生相同状态和输出结果。一个客户端产生一个状态机命令时就能使用任意一个中央服务器的结果。</p><p>为了保证所有的中央服务器执行相同序列的状态机命令，我们实现了由Paxos共识算法的单独实例组成的序列：序列中第i个投票的值就作为第i个状态机命令。每个服务器都扮演所有角色（proposer、acceptor、learner）。现在，我假定一组中央服务器已经确定，因此所有一致性算法的实例都使用一样的集合。</p><p>正常操作时，在所有这个一致性算法实例中一个节点被选为leader（唯一的一个能产生提议的节点）。客户端发送多条命令给这个leader，leader来决定这些命令该放在实例集合中的位置。如果leader从这众多命令中决定了一个确切的客户端命令应该作为第135条命令，它就会尝试将这条命令作为这个共识算法的第135个实例。这个尝试通常会成功。以下情况可能会失败：leader出现异常情况、或者有一个其它节点服务器也坚信自己是leader并且对于哪条客户端命令作为第135条命令有不同看法。但是这个共识算法保证至多一个命令能被选择为第135条命令。</p><p>这个方法效率的关键是：在这个Paxos共识算法中，value只能到第二阶段(Phase 2)才能被批准。</p><p>回忆一下，proposer的算法在完成阶段1之后，要么proposer已经知道acceptor选中了一个value，要么所有acceptors还没有经历过阶段2并同意过任何值。</p><p>我现在要描述Paxos算法提到的状态机在正常操作中如何实现。稍后，我会讨论异常情况。我思考当前一个leader崩溃了而新leader被选出时会发生什么。（系统初始运行时还没有命令被投票产生，这是一种特殊情形。）</p><p>选出的新的leader也作为这个共识算法所有实例的learner，应该要知道大多数被选择的命令。假设它知道第1-134、138和139个命令，也就是这些实例1-134、138和139选择的value。（稍后我们会看到这种情况如何产生的。）leader接着开始执行第135-137实例的阶段1(Phase 1)以及所有比139大的实例。假设这次的执行结果决定了实例135和140选中的value，但是不影响其它实例。然后leader对实例135和140执行阶段2(Phase 2)，从而为135和140实例选中的客户端命令。</p><p>Leader服务器和其它所有服务器此时可以获取leader能够知道的所有命令，那么现在它们可以执行1-135实例的命令。然而，它们不能执行138-140，尽管138-140处于实例集合中能够知道它们的内容，因为命令136和137还没有选出。Leader可以将接下来的两条客户端命令请求作为命令136和137。但是我们不这样做，我们发起一个特殊的”no-op”命令的提议来作为136和137的内容，这样让状态机状态不改变并且也能填充命令实例集合的空缺。（通过执行共识算法实例136和137的阶段2）一旦这些”no-op”命令被选中，命令138-140就能被执行。</p><p>  现在命令1-140已经选择完毕了。Leader也完成了共识算法中所有大于140的实例的阶段1，并且可以在这些实例的阶段2提议任何value。它将接下来的客户端请求赋值为141，然后提议这个客户端请求作为共识算法实例141在阶段2的value。它又继续提议接下来的客户端请求为142，如此循环往复。</p><p>  Leader能够在还不清楚提议141是否被选中之前就提议命令142。可能提议141命令的所有消息都丢失了，也可能在命令141还没被任何learner知道被选为141命令之前，142命令就被选中。当leader没有接收到期望的关于141实例提议的阶段2响应消息，它就会重新发送这些消息。如果所有顺利进行，它的提议命令将会被选中。然而，它可能一开始就发生故障，使选择的命令序列出现了空缺。通常，假设一个leader能够提前获得α条命令，那也是说，在1-i的命令被选出的情况下，它能提议i+1-i+α的命令。因此空缺可能会有α-1那么大。</p><p>  一个新的leader可以执行无数个共识算法实例的阶段1—即在上面的场景中，135-137以及所有大于139的实例。所有实例使用同一个提议号，leader可以给其它服务器发送单个合理的短消息。在阶段1，一个acceptor如果早已接收过其它proposer的阶段2的消息，那么（对于这条prepare请求）它就不仅仅回复个OK。（这种情况仅仅是场景中的135和140实例。）因此，一个服务器（扮演acceptor的）可以用单个合理的短消息响应所有实例。执行无数个阶段1的实例不会产生任何问题。</p><p>  leader遭遇故障然后选择一个新的leader是小概率事件，因此执行状态机命令的消耗–即，实现共识算法的command/value—就是共识算法阶段2执行的消耗。可以看到Paxos一致性算法的阶段2在任何达成共识的算法中消耗最小的。因此，Paxos算法是最优的。</p><p>  系统正常操作中总是假定有一个leader，除非当前leader发生故障并且正在选择一个新leader。在意外情况中，leader选举可能发生故障。如果没有服务器扮演leader，那么也就没有命令会被提议。如果有多个服务器认为他们是leaders，它们都能对一致性算法的同一实例的提议value，这会导致没有任何value被选中。然而安全性总是保留着—两个不同的服务器永远不会不同意一个value被选为第i个状态机命令。单个leader的选举仅仅是为了保证过程的进行。</p><p>  如果服务器的集合可以改变，那么必须要有方法来确定哪些服务器实现了哪些一致性算法实例。最简单的办法就是让状态机自己来做。当前服务器的集合可以作为状态的一部分，并且可以被一般的状态机命令改变。在执行完第i条状态机命令后，我们通过让这个服务器集合执行一致性算法的i-i+α条实例来指定状态的方式，以允许leader提前获取α个命令。这点就可以完成一个任意复杂的重构算法的简单实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上周给组里分享课程，其中讲到了paxos，觉得没讲好，遂决定看看paxos论文，看的时候有的枯涩的地方就翻译到文本里记录，翻译得越来越多，索性都翻译了吧 …&lt;/p&gt;
&lt;h1 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="译文" scheme="http://lkness/categories/%E8%AF%91%E6%96%87/"/>
    
    
      <category term="分布式" scheme="http://lkness/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>erlang底层c定时器设计-Erlang源码学习二</title>
    <link href="http://lkness/2018/06/20/030erlang-timer/index/"/>
    <id>http://lkness/2018/06/20/030erlang-timer/index/</id>
    <published>2018-06-20T12:09:25.000Z</published>
    <updated>2018-06-20T12:18:22.090Z</updated>
    
    <content type="html"><![CDATA[<p>Erlang底层的定时器实现位于源码的erts/emulator/beam/time.c文件，用时间轮的方式动态添加和删除定时器，结构体名为<code>typedef struct ErtsTimerWheel_ ErtsTimerWheel</code>，每一个定时器的结构体名为<code>typedef struct erl_timer ErtsTWheelTimer</code>，看结构体实现大体上可以知道定时器的设计。</p><h1 id="定时器-ErtsTWheelTimer"><a href="#定时器-ErtsTWheelTimer" class="headerlink" title="定时器 ErtsTWheelTimer"></a>定时器 ErtsTWheelTimer</h1><pre><code>typedef struct erl_timer {    struct erl_timer* next; /* next entry tiw slot or chain */    struct erl_timer* prev; /* prev entry tiw slot or chain */    union {    struct {        void (*timeout)(void*); /* called when timeout */        void (*cancel)(void*);  /* called when cancel (may be NULL) */        void* arg;              /* argument to timeout/cancel procs */    } func;    ErtsThrPrgrLaterOp cleanup;    } u;    ErtsMonotonicTime timeout_pos; /* Timeout in absolute clock ticks */    int slot;} ErtsTWheelTimer;</code></pre><p>每个定时器维护了前后向指针，有定时器到时作为回调的函数、取消定时器所调用的函数（可能做参数销毁用）和函数参数，还有定时器的到时点，以及此定时器位于时间轮的槽。</p><h1 id="时间轮-ErtsTimerWheel"><a href="#时间轮-ErtsTimerWheel" class="headerlink" title="时间轮 ErtsTimerWheel"></a>时间轮 ErtsTimerWheel</h1><pre><code>struct ErtsTimerWheel_ {    ErtsTWheelTimer *w[ERTS_TIW_SIZE];    ErtsMonotonicTime pos;    Uint nto;    struct {    ErtsTWheelTimer *head;    ErtsTWheelTimer *tail;    Uint nto;    } at_once;    int yield_slot;    int yield_slots_left;    int yield_start_pos;    ErtsTWheelTimer sentinel;    int true_next_timeout_time;    ErtsMonotonicTime next_timeout_time;};</code></pre><p>时间轮维护了一个ERTS_TIW_SIZE大小的定时器指针数组，看头文件定义可以得到ERTS_TIW_SIZE在小内存机器上是 1&lt;&lt;13的大小，大内存机器为1&lt;&lt;16=2^16=2^6*1024=65535大小，这里只看大内存机器；接着有一个pos字段，类型为ErtsMonotonicTime，这是一个long long的别名，顾名思义就是erlang的monotonic时间，简单说就是一个精确到纳秒的单调递增时间；接着有一个at_once空间，有头head、尾tail指针，至于数据结构可能为链表，可能为数组实现的栈或队列等；然后的字段光看名字也无法推断了。进入时间轮操作函数。</p><p>#</p><p>time.c的函数只有几个，先罗列简单的:</p><pre><code>ErtsTimerWheel *erts_create_timer_wheel(ErtsSchedulerData *esdp){    ErtsMonotonicTime mtime;    int i;    ErtsTimerWheel *tiw;    tiw = erts_alloc_permanent_cache_aligned(ERTS_ALC_T_TIMER_WHEEL,                         sizeof(ErtsTimerWheel));    for(i = 0; i &lt; ERTS_TIW_SIZE; i++)    tiw-&gt;w[i] = NULL;    mtime = erts_get_monotonic_time(esdp);    tiw-&gt;pos = ERTS_MONOTONIC_TO_CLKTCKS(mtime);    tiw-&gt;nto = 0;    tiw-&gt;at_once.head = NULL;    tiw-&gt;at_once.tail = NULL;    tiw-&gt;at_once.nto = 0;    tiw-&gt;yield_slot = ERTS_TWHEEL_SLOT_INACTIVE;    tiw-&gt;true_next_timeout_time = 0;    tiw-&gt;next_timeout_time = mtime + ERTS_MONOTONIC_DAY;    tiw-&gt;sentinel.next = &amp;tiw-&gt;sentinel;    tiw-&gt;sentinel.prev = &amp;tiw-&gt;sentinel;    tiw-&gt;sentinel.u.func.timeout = NULL;    tiw-&gt;sentinel.u.func.cancel = NULL;    tiw-&gt;sentinel.u.func.arg = NULL;    return tiw;}</code></pre><p>看操作是先分配内存，然后初始化w定时器指针数组为NULL，接着获取一次当前的monotonic时间，将它转换为时间轮滴答后赋给pos字段，monotonic时间是精确到纳秒，宏ERTS_MONOTONIC_TO_CLKTCKS将它除以了1000*1000，从这里我们可以知道时间轮每一次走动是1ms，即时间轮的粒度就是1ms了，接下来的操作就是常规的初始化了，到tiw-&gt;sentinel.next = $tiw-&gt;sentinel语句开始，是将一个sentinel（哨兵）变量变为一个指向自己的循环双向链表。</p><p><strong>结论：</strong></p><p>时间轮的pos字段初始值为创建时间轮时的monotonic时间，但时间轮的精度为ms，故需要将monotonic时间转换为ms（除以1000*1000），pos字段为时间轮的当前指针（想象成钟的分针）。</p><h1 id="插入定时器-insert-timer-into-slot"><a href="#插入定时器-insert-timer-into-slot" class="headerlink" title="插入定时器 insert_timer_into_slot"></a>插入定时器 insert_timer_into_slot</h1><pre><code>static ERTS_INLINE voidinsert_timer_into_slot(ErtsTimerWheel *tiw, int slot, ErtsTWheelTimer *p){    ERTS_TW_ASSERT(slot &gt;= 0);    ERTS_TW_ASSERT(slot &lt; ERTS_TIW_SIZE);    p-&gt;slot = slot;    if (!tiw-&gt;w[slot]) {    tiw-&gt;w[slot] = p;    p-&gt;next = p;    p-&gt;prev = p;    }    else {    ErtsTWheelTimer *next, *prev;    next = tiw-&gt;w[slot];    prev = next-&gt;prev;    p-&gt;next = next;    p-&gt;prev = prev;    prev-&gt;next = p;    next-&gt;prev = p;    }}</code></pre><p>先看插入的第1、2两句，断言slot要介于0-ERTS_TIW_SIZE之间：定时器要插到时间轮的槽上，因此必须介于这个范围。然后开始插入，先判断待插入的槽有没有定时器，如果没有，就直接将w[slot]指针指向这个定时器，并且赋值next、prev指针保证循环双向链表特性；如果槽上已经有了别的定时器，那么看else的操作是将待插入的定时器头插到链表中。</p><p>于是看完这个函数，知道了时间轮的主要逻辑如图：</p><p><img src="/img/erlang_timer1.png" alt="erlang_timer1"></p><p><strong>结论：</strong></p><p>时间轮的槽大小为65535；每个槽是一个定时器指针，指针又维护了一个定时器双向循环链表，跟链式散列表很像；定时器是头插。</p><h1 id="去除定时器-remove-timer"><a href="#去除定时器-remove-timer" class="headerlink" title="去除定时器 remove_timer"></a>去除定时器 remove_timer</h1><pre><code>static ERTS_INLINE voidremove_timer(ErtsTimerWheel *tiw, ErtsTWheelTimer *p){    int slot = p-&gt;slot;    ERTS_TW_ASSERT(slot != ERTS_TWHEEL_SLOT_INACTIVE);    if (slot &gt;= 0) {        /*         * Timer in wheel or in circular         * list of timers currently beeing         * triggered (referred by sentinel).         */        ERTS_TW_ASSERT(slot &lt; ERTS_TIW_SIZE);        if (p-&gt;next == p) {            ERTS_TW_ASSERT(tiw-&gt;w[slot] == p);            tiw-&gt;w[slot] = NULL;        }        else {            if (tiw-&gt;w[slot] == p)            tiw-&gt;w[slot] = p-&gt;next;            p-&gt;prev-&gt;next = p-&gt;next;            p-&gt;next-&gt;prev = p-&gt;prev;        }    }    else {        /* Timer in &quot;at once&quot; queue... */        ERTS_TW_ASSERT(slot == ERTS_TWHEEL_SLOT_AT_ONCE);        if (p-&gt;prev)            p-&gt;prev-&gt;next = p-&gt;next;        else {            ERTS_TW_ASSERT(tiw-&gt;at_once.head == p);            tiw-&gt;at_once.head = p-&gt;next;        }        if (p-&gt;next)            p-&gt;next-&gt;prev = p-&gt;prev;        else {            ERTS_TW_ASSERT(tiw-&gt;at_once.tail == p);            tiw-&gt;at_once.tail = p-&gt;prev;        }        ERTS_TW_ASSERT(tiw-&gt;at_once.nto &gt; 0);        tiw-&gt;at_once.nto--;    }    p-&gt;slot = ERTS_TWHEEL_SLOT_INACTIVE;    tiw-&gt;nto--;}</code></pre><p>先看第一个断言slot != ERTS_TWHEEL_SLOT_INACTIVE，这个宏值为-2，前面的函数知道槽数一定是介于0-65535之间，所以猜测如果槽数为-2了，表示定时器未激活。</p><p>往后看，如果槽存在，又分两种情况，一种是这个定时器所处的槽只有它一个定时器，那么需要将槽指针w[slot]置为空，另一种是槽上还有很多定时器，则从循环双向链表中取下一个结点。<br>如果槽不存在，且看else的slot为宏值ERTS_TWHEEL_SLOT_AT_ONCE，那么就从at_once队列中去除定时器，并且nto字段减1。</p><p>将定时器的slot字段置为ERTS_TWHEEL_SLOT_INACTIVE，时间轮的nto字段减1。</p><p><strong>结论：</strong></p><p>定时器有三种状态分别为正常、at_once、未激活；at_once队列实则为不循环双向链表；at_once的nto字段记录这个队列上的定时器个数；tiw的nto字段记录所有定时器包括at_once队列上的定时器个数。</p><h1 id="定时器到时回调-timeout-timer"><a href="#定时器到时回调-timeout-timer" class="headerlink" title="定时器到时回调 timeout_timer"></a>定时器到时回调 timeout_timer</h1><p>回调就很简单，将定时器的slot字段设置为未激活，然后调用回调函数</p><h1 id="取消定时器-erts-twheel-cancel-timer"><a href="#取消定时器-erts-twheel-cancel-timer" class="headerlink" title="取消定时器 erts_twheel_cancel_timer"></a>取消定时器 erts_twheel_cancel_timer</h1><p>逻辑与4的到时回调差不多，判断了定时器的slot不能为未激活状态，然后调用remove去除定时器，接着调用定时器的cancel回调函数</p><h1 id="创建定时器-erts-twheel-set-timer"><a href="#创建定时器-erts-twheel-set-timer" class="headerlink" title="创建定时器 erts_twheel_set_timer"></a>创建定时器 erts_twheel_set_timer</h1><pre><code>voiderts_twheel_set_timer(ErtsTimerWheel *tiw,              ErtsTWheelTimer *p, ErlTimeoutProc timeout,              ErlCancelProc cancel, void *arg,              ErtsMonotonicTime timeout_pos){    ErtsMonotonicTime timeout_time;    ERTS_MSACC_PUSH_AND_SET_STATE_M_X(ERTS_MSACC_STATE_TIMERS);    p-&gt;u.func.timeout = timeout;    p-&gt;u.func.cancel = cancel;    p-&gt;u.func.arg = arg;    ERTS_TW_ASSERT(p-&gt;slot == ERTS_TWHEEL_SLOT_INACTIVE);    if (timeout_pos &lt;= tiw-&gt;pos) {    tiw-&gt;nto++;    tiw-&gt;at_once.nto++;    p-&gt;next = NULL;    p-&gt;prev = tiw-&gt;at_once.tail;    if (tiw-&gt;at_once.tail) {        ERTS_TW_ASSERT(tiw-&gt;at_once.head);        tiw-&gt;at_once.tail-&gt;next = p;    }    else {        ERTS_TW_ASSERT(!tiw-&gt;at_once.head);        tiw-&gt;at_once.head = p;    }    tiw-&gt;at_once.tail = p;    p-&gt;timeout_pos = tiw-&gt;pos;    p-&gt;slot = ERTS_TWHEEL_SLOT_AT_ONCE;    timeout_time = ERTS_CLKTCKS_TO_MONOTONIC(tiw-&gt;pos);    }    else {    int slot;    /* calculate slot */    slot = (int) (timeout_pos &amp; (ERTS_TIW_SIZE-1));    insert_timer_into_slot(tiw, slot, p);    tiw-&gt;nto++;    timeout_time = ERTS_CLKTCKS_TO_MONOTONIC(timeout_pos);    p-&gt;timeout_pos = timeout_pos;    }    if (timeout_time &lt; tiw-&gt;next_timeout_time) {    tiw-&gt;true_next_timeout_time = 1;    tiw-&gt;next_timeout_time = timeout_time;    }    ERTS_MSACC_POP_STATE_M_X();}</code></pre><p>逻辑很清楚：传入一个时间轮、定时器、以及定时器要用的相关函数、时间轮上的超时位置（monotonic time / 1000*1000）。</p><p>然后判断超时位置是否小于等于时间轮当前的指针pos，如果是，就把它加入到at_once链表，pos的精度为ms，这个at_once的意思就是加入的定时器差1ms就要到时，而针对这种定时器，再把它插入到槽里做管理和到时是没有意义的，因为马上就到时了。</p><p>正常的定时器则可以插入到槽里了，槽的计算是用到时位置与槽总大小做与运算，举个例子：当前monotonic时间为10,000,000,000，表示开始或者erlang虚拟机开启了10s， 此时创建了一个时间轮，它的pos就该为10,000，然后插入一个5,000,000,000纳秒后到时的定时器，因为时间轮精度为ms，顾折算为(10,000,000,000 + 5,000,000,000)/1000*1000=15,000，即timeout_pos就为15000，那么timeout_pos &amp; ERTS_TIW_SIZE = 15000，那么槽就是15000位置，此时槽还在10000位置，要走5000个滴答才到，同理，如果插入一个距现在65536ms后到时的定时器，则65536超出了65535，但与运算，又变为了0，实现了定时器的循环相加。</p><p>相应nto计数加一，然后判断加入的定时器的到时时间是否小于等于时间轮的下一次到时时间，如果是，就更新时间轮的相应到时值。</p><p><strong>总结：</strong></p><p>定时器如果马上（差1ms）到时的，会加入到at_once队列，否则加入到时间槽里做管理；定时器的到时时间为一个精度为ms的值，然后用这个值跟ERTS_TIW_SIZE做与运算，保证了槽的循环；时间轮还有字段用来表示下一次最近的到时时间，true_next_timeout_time为1表示存在这个时间（即槽上至少存在一个激活的定时器还没到时）。</p><h1 id="寻找下一个最近到时时间-find-next-timeout"><a href="#寻找下一个最近到时时间-find-next-timeout" class="headerlink" title="寻找下一个最近到时时间 find_next_timeout"></a>寻找下一个最近到时时间 find_next_timeout</h1><pre><code>static ERTS_INLINE ErtsMonotonicTimefind_next_timeout(ErtsSchedulerData *esdp,          ErtsTimerWheel *tiw,          int search_all,          ErtsMonotonicTime curr_time,       /* When !search_all */          ErtsMonotonicTime max_search_time) /* When !search_all */{    int start_ix, tiw_pos_ix;    ErtsTWheelTimer *p;    int true_min_timeout = 0;    ErtsMonotonicTime min_timeout, min_timeout_pos, slot_timeout_pos;    if (tiw-&gt;nto == 0) { /* no timeouts in wheel */        if (!search_all)            min_timeout_pos = tiw-&gt;pos;        else {            curr_time = erts_get_monotonic_time(esdp);            tiw-&gt;pos = min_timeout_pos = ERTS_MONOTONIC_TO_CLKTCKS(curr_time);        }        min_timeout_pos += ERTS_MONOTONIC_TO_CLKTCKS(ERTS_MONOTONIC_DAY);        goto found_next;    }    slot_timeout_pos = min_timeout_pos = tiw-&gt;pos;    if (search_all)       min_timeout_pos += ERTS_MONOTONIC_TO_CLKTCKS(ERTS_MONOTONIC_DAY);    else       min_timeout_pos = ERTS_MONOTONIC_TO_CLKTCKS(curr_time + max_search_time);    start_ix = tiw_pos_ix = (int) (tiw-&gt;pos &amp; (ERTS_TIW_SIZE-1));    do {        if (++slot_timeout_pos &gt;= min_timeout_pos)            break;        p = tiw-&gt;w[tiw_pos_ix];        if (p) {            ErtsTWheelTimer *end = p;            do  {            ErtsMonotonicTime timeout_pos;            timeout_pos = p-&gt;timeout_pos;            if (min_timeout_pos &gt; timeout_pos) {                true_min_timeout = 1;                min_timeout_pos = timeout_pos;                if (min_timeout_pos &lt;= slot_timeout_pos)                goto found_next;            }            p = p-&gt;next;            } while (p != end);        }        tiw_pos_ix++;        if (tiw_pos_ix == ERTS_TIW_SIZE)            tiw_pos_ix = 0;    } while (start_ix != tiw_pos_ix);found_next:    min_timeout = ERTS_CLKTCKS_TO_MONOTONIC(min_timeout_pos);    tiw-&gt;next_timeout_time = min_timeout;    tiw-&gt;true_next_timeout_time = true_min_timeout;    return min_timeout;}</code></pre><p>函数作用是寻找时间轮所处指针到当前时间curr_time之间最近的一个定时器到时时间。</p><p>函数逻辑分两种情况，一种是时间轮上没有定时器，则判断search_all的值是否要将时间轮的指针拨到当前时间点，然后最小超时时间就为明天的这个时候（因为没有定时器，自然不存在下一个到时的定时器时间）；另一种是时间轮上有定时器，则判断search_all的值是，如果为1，寻找的间隔就是一天(24<em>60</em>60*1000)，否则间隔就是时间轮当前指针到curr_time+max_search_time的距离，然后从时间轮当前指针处开始循环判断每个槽链表，有无定时器的到时时间小于curr_time+max_search_time，如果找了一圈（即走过的距离为ERTS_TIW_SIZE）没找到，就退出，并设置时间轮的下一次到时时间。</p><p><strong>结论：</strong></p><p>时间轮维护了一个下一次到时时间，避免了一段连续的槽上都没有定时器，而在做到时判断时空循环破坏效率。</p><h1 id="时间轮嘀嗒-erts-bump-timers"><a href="#时间轮嘀嗒-erts-bump-timers" class="headerlink" title="时间轮嘀嗒 erts_bump_timers"></a>时间轮嘀嗒 erts_bump_timers</h1><pre><code>voiderts_bump_timers(ErtsTimerWheel *tiw, ErtsMonotonicTime curr_time){    int tiw_pos_ix, slots, yielded_slot_restarted, yield_count;    ErtsMonotonicTime bump_to, tmp_slots, old_pos;    ERTS_MSACC_PUSH_AND_SET_STATE_M_X(ERTS_MSACC_STATE_TIMERS);    yield_count = ERTS_TWHEEL_BUMP_YIELD_LIMIT;    /*     * In order to be fair we always continue with work     * where we left off when restarting after a yield.     */    if (tiw-&gt;yield_slot &gt;= 0) {        yielded_slot_restarted = 1;        tiw_pos_ix = tiw-&gt;yield_slot;        slots = tiw-&gt;yield_slots_left;        bump_to = tiw-&gt;pos;        old_pos = tiw-&gt;yield_start_pos;        goto restart_yielded_slot;    }    do {        yielded_slot_restarted = 0;        bump_to = ERTS_MONOTONIC_TO_CLKTCKS(curr_time);        while (1) {            ErtsTWheelTimer *p;            old_pos = tiw-&gt;pos;            if (tiw-&gt;nto == 0) {                empty_wheel:                ERTS_DBG_CHK_SAFE_TO_SKIP_TO(tiw, bump_to);                tiw-&gt;true_next_timeout_time = 0;                tiw-&gt;next_timeout_time = curr_time + ERTS_MONOTONIC_DAY;                tiw-&gt;pos = bump_to;                tiw-&gt;yield_slot = ERTS_TWHEEL_SLOT_INACTIVE;                        ERTS_MSACC_POP_STATE_M_X();                return;            }            p = tiw-&gt;at_once.head;            while (p) {                if (--yield_count &lt;= 0) {                    ERTS_TW_ASSERT(tiw-&gt;nto &gt; 0);                    ERTS_TW_ASSERT(tiw-&gt;at_once.nto &gt; 0);                    tiw-&gt;yield_slot = ERTS_TWHEEL_SLOT_AT_ONCE;                    tiw-&gt;true_next_timeout_time = 1;                    tiw-&gt;next_timeout_time = ERTS_CLKTCKS_TO_MONOTONIC(old_pos);                            ERTS_MSACC_POP_STATE_M_X();                    return;                }                ERTS_TW_ASSERT(tiw-&gt;nto &gt; 0);                ERTS_TW_ASSERT(tiw-&gt;at_once.nto &gt; 0);                tiw-&gt;nto--;                tiw-&gt;at_once.nto--;                tiw-&gt;at_once.head = p-&gt;next;                if (p-&gt;next)                    p-&gt;next-&gt;prev = NULL;                else                    tiw-&gt;at_once.tail = NULL;                timeout_timer(p);                p = tiw-&gt;at_once.head;            }            if (tiw-&gt;pos &gt;= bump_to) {                ERTS_MSACC_POP_STATE_M_X();                break;            }            if (tiw-&gt;nto == 0)                goto empty_wheel;            if (tiw-&gt;true_next_timeout_time) {                ErtsMonotonicTime skip_until_pos;                /*                 * No need inspecting slots where we know no timeouts                 * to trigger should reside.                 */                skip_until_pos = ERTS_MONOTONIC_TO_CLKTCKS(tiw-&gt;next_timeout_time);                if (skip_until_pos &gt; bump_to)                    skip_until_pos = bump_to;                skip_until_pos--;                if (skip_until_pos &gt; tiw-&gt;pos) {                    ERTS_DBG_CHK_SAFE_TO_SKIP_TO(tiw, skip_until_pos);                    tiw-&gt;pos = skip_until_pos;                }            }            tiw_pos_ix = (int) ((tiw-&gt;pos+1) &amp; (ERTS_TIW_SIZE-1));            tmp_slots = (bump_to - tiw-&gt;pos);            if (tmp_slots &lt; (ErtsMonotonicTime) ERTS_TIW_SIZE)              slots = (int) tmp_slots;            else              slots = ERTS_TIW_SIZE;            tiw-&gt;pos = bump_to;            while (slots &gt; 0) {                p = tiw-&gt;w[tiw_pos_ix];                if (p) {                    if (p-&gt;next == p) {                        ERTS_TW_ASSERT(tiw-&gt;sentinel.next == &amp;tiw-&gt;sentinel);                        ERTS_TW_ASSERT(tiw-&gt;sentinel.prev == &amp;tiw-&gt;sentinel);                    } else {                        tiw-&gt;sentinel.next = p-&gt;next;                        tiw-&gt;sentinel.prev = p-&gt;prev;                        tiw-&gt;sentinel.next-&gt;prev = &amp;tiw-&gt;sentinel;                        tiw-&gt;sentinel.prev-&gt;next = &amp;tiw-&gt;sentinel;                    }                    tiw-&gt;w[tiw_pos_ix] = NULL;                    while (1) {                        if (p-&gt;timeout_pos &gt; bump_to) {                            /* Very unusual case... */                            ++yield_count;                            insert_timer_into_slot(tiw, tiw_pos_ix, p);                        } else {                            /* Normal case... */                            timeout_timer(p);                            tiw-&gt;nto--;                        }                        restart_yielded_slot:                        p = tiw-&gt;sentinel.next;                        if (p == &amp;tiw-&gt;sentinel) {                            ERTS_TW_ASSERT(tiw-&gt;sentinel.prev == &amp;tiw-&gt;sentinel);                            break;                        }                        if (--yield_count &lt;= 0) {                            tiw-&gt;true_next_timeout_time = 1;                            tiw-&gt;next_timeout_time = ERTS_CLKTCKS_TO_MONOTONIC(old_pos);                            tiw-&gt;yield_slot = tiw_pos_ix;                            tiw-&gt;yield_slots_left = slots;                            tiw-&gt;yield_start_pos = old_pos;                            ERTS_MSACC_POP_STATE_M_X();                            return; /* Yield! */                        }                        tiw-&gt;sentinel.next = p-&gt;next;                        p-&gt;next-&gt;prev = &amp;tiw-&gt;sentinel;                    }                }                tiw_pos_ix++;                if (tiw_pos_ix == ERTS_TIW_SIZE)                    tiw_pos_ix = 0;                slots--;            }        }    } while (yielded_slot_restarted);    tiw-&gt;yield_slot = ERTS_TWHEEL_SLOT_INACTIVE;    tiw-&gt;true_next_timeout_time = 0;    tiw-&gt;next_timeout_time = curr_time + ERTS_MONOTONIC_DAY;    /* Search at most two seconds ahead... */    (void) find_next_timeout(NULL, tiw, 0, curr_time, ERTS_SEC_TO_MONOTONIC(2));    ERTS_MSACC_POP_STATE_M_X();}</code></pre><p>这是最重要的一个函数，erlang虚拟机启动后，有一个线程做周期性调用，来检测有无定时器到时。</p><p>函数接收一个curr_time形参，将时间轮上小于等于此时间的定时器都视为到时，所以估计是1ms调用一次。</p><p>函数定义了yield_count=100，如果at_once或者某个槽上大于100个定时器，就丢弃多的。</p><p>这个函数写得很恶心，又是do while{}，又是while(1)，又是while，但剥离开，真正的逻辑就一段：循环将at_once链表的定时器全部到时，则at_once链表清空了；开始判断时间槽，先利用下一个最近的到时时间next_timeout_time跳过一段槽，然后开始遍历从时间轮的当前指针pos到curr_time之间的间隔槽，再遍历每个槽上的链表，对每个结点判断是否大于等于curr_time，即判断是否到时，如果到时就可以去掉定时器，并执行回调任务。</p><p>以上步骤就做完了到时任务，调用一下find_next_timeout寻找一次最近到时时间。</p><p>#</p><p>在看erts_bump_timers函数时候看到一段goto的代码形如：</p><pre><code>goto test_label:int a = 0;test_label:    a = 1;</code></pre><p>当时很诧异，a不是没定义吗？激动得不行，摩拳擦掌准备提bug，抱着谨慎的态度还是查了一下，这种用法是可以的，真是菜得不行 …… 自己猜想一下可能是编译期已经将a加入了符号表，goto只影响运行时。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Erlang底层的定时器实现位于源码的erts/emulator/beam/time.c文件，用时间轮的方式动态添加和删除定时器，结构体名为&lt;code&gt;typedef struct ErtsTimerWheel_ ErtsTimerWheel&lt;/code&gt;，每一个定时器的结
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Erlang" scheme="http://lkness/tags/Erlang/"/>
    
  </entry>
  
  <entry>
    <title>erlang:now()与os:timestamp()-Erlang源码学习一</title>
    <link href="http://lkness/2018/06/20/029erlang-time/index/"/>
    <id>http://lkness/2018/06/20/029erlang-time/index/</id>
    <published>2018-06-20T11:44:02.000Z</published>
    <updated>2018-06-20T12:04:28.254Z</updated>
    
    <content type="html"><![CDATA[<p>erlang中，关于erlang:now()与os:timestamp()两个接口，查看官方文档的解释：</p><p><img src="/img/erlang_time1.png" alt="erlang_time1"></p><p><img src="/img/erlang_time2.png" alt="erlang_time2"></p><p>按官方文档上说erlang:now/0是废弃了的，它可以获取一个持续递增的唯一时间戳。除此也没说讲到更多。</p><p>再看erlang:now/0文档给的<a href="http://erlang.org/doc/apps/erts/time_correction.html#Dos_and_Donts" target="_blank" rel="noopener">时间和时间修正</a>，里面详细描述了erlang对于时间的处理，暂不看。</p><p>直接跳到c源码看吧，在这之前可以看看<a href="https://blog.csdn.net/hytgxljh/article/details/52440837" target="_blank" rel="noopener">linux内核时间的管理</a>，明白什么是墙上时间(wall time)、单调递增时间(monotonic time)等。</p><h1 id="erlang-now-0"><a href="#erlang-now-0" class="headerlink" title="erlang:now/0"></a>erlang:now/0</h1><pre><code>erlang:now/0的bif函数对应erlang源码:erts/emulator/beam/bif.c</code></pre><p><img src="/img/erlang_time3.png" alt="erlang_time3"></p><p><code>now_0()</code>的获取时间调用<code>get_now()</code>函数，位于erts/emulator/beam/erl_time_sup.c</p><p><img src="/img/erlang_time4.png" alt="erlang_time4"></p><p>获取时间主要用一个回调<code>get_time()</code>，而获取时间之后会与上一次调用产生的值比较，并产生一个新的保证单调递增的唯一值，并加锁修改旧值。关于<code>get_time()</code>的初始化要在同文件的<code>erlang_init_time_sup()</code>函数</p><p><img src="/img/erlang_time5.png" alt="erlang_time5"></p><p>可以看到有一个条件编译宏 ERTS_HAVE_OS_MONOTONIC_TIME_SUPPORT，在没有配置erlang源码时，这些宏都未定义，但如果在源码根目录执行了./configure配置后，会在emulator目录生成一个文件夹（我的是x86_64-unknown-linux-gnu），里面放有config.h配置文件，里面根据操作系统类型做了对应宏定义，对应宏ERTS_HAVE_OS_MONOTONIC_TIME_SUPPORT就是在config.h里，表示这个操作系统有单调递增时间(monotonic time)，那么这里可以看到get_time回调指向了<code>get_os_grift_corrected_time()</code>，此函数直接返回<code>read_corrected_time()</code>函数结果：</p><p><img src="/img/erlang_time6.png" alt="erlang_time6"></p><p>可以看到<code>read_corrected_time()</code>函数主要执行了<code>erts_os_monitonic_time()</code>和<code>calc_corrected_erl_mtime()</code>来获取操作系统的monitonic_time以及修正时间。<br><code>erts_os_monitonic_time()</code>直接调用<code>posix_clock_gettime()</code>函数，参数为MONOTONIC_CLOCK_ID，获取monotonic time：</p><p><img src="/img/erlang_time7.png" alt="erlang_time7"></p><p>获取时间的函数实则调用了linux的系统函数<code>clock_gettime()</code>，可以man手册看一看；<br><code>calc_corrected_erl_time()</code>函数：</p><p><img src="/img/erlang_time8.png" alt="erlang_time8"></p><p>将获取的当前操作系统monitonic time与最近一次更新的操作系统monitonic time做一个差值计算，然后根据erlang时间的设计来计算一个新的erlang monitonic time。</p><h1 id="os-timestamp-0"><a href="#os-timestamp-0" class="headerlink" title="os:timestamp/0"></a>os:timestamp/0</h1><p><code>os:timestamp()</code>函数代码：</p><p><img src="/img/erlang_time9.png" alt="erlang_time9"></p><p>代码里调用了<code>erts_os_system_time()</code>函数来获取操作系统的时间：</p><p><img src="/img/erlang_time10.png" alt="erlang_time10"></p><p>又是熟悉的<code>posix_clock_gettime()</code>，并且参数为WALL_CLOCK_ID获取墙上时间。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>erlang:now/0</code>获取的是erlang系统的monotonic time，它从操作系统获取后还要用erlang时间处理的方式在调整为erlang monotonic time，期间几次会对全局变量加锁，故效率会有损耗，而每一次获取时间值后会与上一次获取的值做一个对比，并加一来保证获取值的严格单调递增，所以可以用来作为唯一名(unique name)的生成，但是，erts7.0之后就不建议用这个函数了，可以用<code>erlang:timestamp/0</code>替代，如果要生成唯一名可以用<code>erlang:unique_integer/0</code>等等。 而<code>os:timestamp/0</code>则是获取操作系统的墙上时间(wall time)，并做调整变为erlang system time。</p><p><code>erlang:now/0</code>获取时间的文件为erl_time_sup.c，所有的erlang关于时间处理方式的逻辑都定义在里面，包括维护全局变量来处理操作系统转变为erlang规则的内部时间、注册定时器周期检查erlang时间与os时间对比的偏移量等；<code>os:timestamp/0</code>获取时间的文件为sys_time.c，是对os获取时间的库函数的封装、以及对获取的时间进行简单调整的文件，比较轻量级。</p><p>后记：看了erlang时间的处理，感觉很有趣，后面学习一下erlang源码中对时间的管理代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;erlang中，关于erlang:now()与os:timestamp()两个接口，查看官方文档的解释：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/erlang_time1.png&quot; alt=&quot;erlang_time1&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/er
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Erlang" scheme="http://lkness/tags/Erlang/"/>
    
  </entry>
  
  <entry>
    <title>图的简单表示-算法学习笔记十七</title>
    <link href="http://lkness/2018/06/20/028graph/index/"/>
    <id>http://lkness/2018/06/20/028graph/index/</id>
    <published>2018-06-20T04:49:36.000Z</published>
    <updated>2018-06-20T04:50:55.817Z</updated>
    
    <content type="html"><![CDATA[<p>基于邻接矩阵和邻接链表的图表示法，以及各自的深度优先遍历和广度优先遍历，但图的表示中没有加带权的边，只是简单写一写，学习一下，底层链表和队列用了通用链表</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#define PRINT(format, arg...) \do{ \    printf(&quot;[%s/%d]:&quot;, __func__, __LINE__); \    printf(format, ##arg); \    printf(&quot;\n&quot;); \}while(0)/*****************************图********************************/#define MAX_VERTEX_NUM 100typedef struct init_array {    int start_v;    int end_v;} init_array;/**************邻接矩阵表示****************/typedef struct matrix_graph {    int vertex[MAX_VERTEX_NUM];  // 存放顶点信息    int v_num;  // 顶点数    int e_num;  // 边数    int matrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];} matrix_graph;matrix_graph *init_matrix_graph(    int v_num,    int e_num ){    int i = 0, j = 0;    matrix_graph *graph = NULL;    graph = ( matrix_graph * )malloc( sizeof(matrix_graph) );    graph-&gt;v_num = v_num;    graph-&gt;e_num = e_num;    for ( i = 0; i &lt; MAX_VERTEX_NUM; i++ ) {        if ( i &lt; v_num )            graph-&gt;vertex[i] = i;        else            graph-&gt;vertex[i] = -1;        for ( j = 0; j &lt; MAX_VERTEX_NUM; j++ ) {            graph-&gt;matrix[i][j] = 0;        }    }    return graph;}matrix_graph *create_matrix_graph(    init_array *i_arr,    int arr_size,    int v_num ){    int i = 0;    matrix_graph *graph = NULL;    graph = init_matrix_graph( v_num, arr_size );    for ( i = 0; i &lt; arr_size; i++ ) {        graph-&gt;matrix[i_arr[i].start_v][i_arr[i].end_v] = 1;    }    return graph;}int visited[MAX_VERTEX_NUM] = {0};// 深度优先遍历void dfs_matrix_graph1(    matrix_graph *g,    int v ){    visited[v] = 1;    printf(&quot;%d &quot;, v);    // 搜索此结点的下一个结点    int i = 0;    for ( i; i &lt; g-&gt;v_num; i++ ) {        if ( g-&gt;matrix[v][i] &amp;&amp; !visited[i] )            dfs_matrix_graph1( g, i );    }}void dfs_matrix_graph(    matrix_graph *g ){    int i = 0;    for ( i; i &lt; g-&gt;v_num; i++ )        visited[i] = 0;    printf(&quot;deep first visit:\n\t&quot;);    for ( i = 0; i &lt; g-&gt;v_num; i++ ) {        if ( !visited[i] )            dfs_matrix_graph1( g, i );    }    printf(&quot;\n&quot;);}// 广度优先搜索void bfs_matrix_graph(    matrix_graph *g ){    int i = 0;    // 栈结点数据域，需要void *    int tmp_vertex[MAX_VERTEX_NUM] = {0};    queue *q = create_queue();    for ( i = 0; i &lt; g-&gt;v_num; i++ )        visited[i] = 0;    printf(&quot;broad first visit:\n\t&quot;);    for ( i = 0; i &lt; g-&gt;v_num; i++ ) {        if ( !visited[i] ) {            tmp_vertex[i] = i;            q-&gt;enqueue(q-&gt;this, &amp;tmp_vertex[i]);            while ( q-&gt;size(q-&gt;this) != 0 ) {                int tmp = *( int * )q-&gt;dequeue( q-&gt;this );                if ( !visited[tmp] )                    printf(&quot;%d &quot;, tmp);                visited[tmp] = 1;                int j = 0;                for ( j = 0; j &lt; g-&gt;v_num; j++ ) {                    if ( g-&gt;matrix[tmp][j] &amp;&amp; !visited[j] ) {                        tmp_vertex[j] = j;                        q-&gt;enqueue( q-&gt;this, &amp;tmp_vertex[j] );                    }                }            }        }    }    q-&gt;free( q-&gt;this );    printf(&quot;\n&quot;);}void free_matrix_graph(    matrix_graph *g ){    free( g );}#undef DEBUG_MATRIX_GRAPH#ifdef DEBUG_MATRIX_GRAPHint main(){    init_array i_arr[20] =        {            {0, 4},            {0, 9},            {1, 5},            {2, 1},            {2, 6},            {3, 2},            {3, 6},            {4, 7},            {4, 8},            {5, 2},            {6, 5},            {7, 6},            {7, 3},            {8, 7},            {8, 4},            {9, 8},        };    matrix_graph *g = create_matrix_graph( i_arr, 16, 10 );    dfs_matrix_graph( g );    bfs_matrix_graph( g );    free_matrix_graph( g );}#endif/********************************************//**************图的邻接链表*******************/typedef struct link_list_graph {    int vertex[MAX_VERTEX_NUM];    int v_num;    int e_num;    link_list v_list[MAX_VERTEX_NUM];} link_list_graph;// 链表数据域，需要void *int tmp_vertex[MAX_VERTEX_NUM] = {0};link_list_graph *create_link_list_graph(    init_array *i_arr,    int arr_size,    int v_num ){    int i = 0;    link_list_graph *graph = NULL;    graph = ( link_list_graph * )malloc( sizeof(link_list_graph) );    graph-&gt;e_num = arr_size;    graph-&gt;v_num = v_num;    for ( i = 0; i &lt; v_num; i++ ) {        tmp_vertex[i] = i;        //定制链表操作        graph-&gt;v_list[i].size = 0;        graph-&gt;v_list[i].insert = insert_tail;        graph-&gt;v_list[i].get_first = get_head;        graph-&gt;v_list[i].get_last = get_tail;        graph-&gt;v_list[i].del = del_tail;        graph-&gt;v_list[i].insert( &amp;graph-&gt;v_list[i], &amp;tmp_vertex[i]);    }    for ( i = 0; i &lt; arr_size; i++ ) {        int start = i_arr[i].start_v;        int end = i_arr[i].end_v;        graph-&gt;v_list[start].insert( &amp;graph-&gt;v_list[start], &amp;tmp_vertex[end]);        printf(&quot;start:%d-&gt;end:%d, size:%d\n&quot;, start, end, graph-&gt;v_list[start].size);    }    return graph;}void dfs_link_list_graph1(    link_list_graph *g,    int v ){    link_list_node *p = g-&gt;v_list[v].head;    if ( !visited[*(int *)(p-&gt;data)] ) {        printf(&quot;%d &quot;, *(int *)(p-&gt;data));        visited[v] = 1;        while ( 1 ) {            p = p-&gt;next;            if ( p == g-&gt;v_list[v].head )                break;            if ( !visited[*(int *)(p-&gt;data)] ) {                dfs_link_list_graph1( g, *(int *)(p-&gt;data) );            }        }    }}void dfs_link_list_graph(    link_list_graph *g ){    int i = 0;    printf(&quot;深度优先遍历：\n\t&quot;);    for ( i = 0; i &lt; g-&gt;v_num; i++ )        visited[i] = 0;    for ( i = 0; i &lt; g-&gt;v_num; i++ ) {        if ( g-&gt;v_list[i].size &gt; 0 &amp;&amp; !visited[i] )            dfs_link_list_graph1( g, i );    }    printf(&quot;\n&quot;);}void bfs_link_list_graph(    link_list_graph *g ){    int i = 0;    // 栈结点数据域，需要void *    int tmp_vertex[MAX_VERTEX_NUM] = {0};    queue *q = create_queue();    for ( i = 0; i &lt; g-&gt;v_num; i++ ){        tmp_vertex[i] = i;        visited[i] = 0;    }    printf(&quot;广度优先遍历:\n\t&quot;);    for ( i = 0; i &lt; g-&gt;v_num; i++ ) {        if ( !visited[i] ) {            tmp_vertex[i] = i;            q-&gt;enqueue(q-&gt;this, &amp;tmp_vertex[i]);            while ( q-&gt;size(q-&gt;this) != 0 ) {                int tmp = *( int * )q-&gt;dequeue( q-&gt;this );                if ( !visited[tmp] )                    printf(&quot;%d &quot;, tmp);                visited[tmp] = 1;                int j = 0;                link_list_node *p = g-&gt;v_list[tmp].head-&gt;next;                while ( p != g-&gt;v_list[tmp].head ) {                    if ( !visited[*(int *)p-&gt;data] ) {                        q-&gt;enqueue( q-&gt;this, &amp;tmp_vertex[*(int *)p-&gt;data] );                    }                    p = p-&gt;next;                }            }        }    }    q-&gt;free( q-&gt;this );    printf(&quot;\n&quot;);}void free_link_list_graph(    link_list_graph *g ){    int i = 0;    for ( i = 0; i &lt; g-&gt;v_num; ++i ) {        del_list( &amp;g-&gt;v_list[i] );    }    free( g );}#define DEBUG_LINK_LIST_GRAPH#ifdef DEBUG_LINK_LIST_GRAPHint main(){    init_array i_arr[20] =        {            {0, 4},            {0, 9},            {1, 5},            {2, 1},            {2, 6},            {3, 2},            {3, 6},            {4, 7},            {4, 8},            {5, 2},            {6, 5},            {7, 6},            {7, 3},            {8, 7},            {8, 4},            {9, 8},        };    link_list_graph *g = create_link_list_graph( i_arr, 16, 10 );    dfs_link_list_graph( g );    bfs_link_list_graph( g );    free_link_list_graph( g );}#endif/********************************************//***************************************************************/</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基于邻接矩阵和邻接链表的图表示法，以及各自的深度优先遍历和广度优先遍历，但图的表示中没有加带权的边，只是简单写一写，学习一下，底层链表和队列用了通用链表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://lkness/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>通用链表/栈/队列-算法学习笔记十六</title>
    <link href="http://lkness/2018/06/20/027list-stack-queue/index/"/>
    <id>http://lkness/2018/06/20/027list-stack-queue/index/</id>
    <published>2018-06-20T04:47:44.000Z</published>
    <updated>2018-06-20T04:49:04.717Z</updated>
    
    <content type="html"><![CDATA[<p>今天准备学习数据结构-图，会用到栈和队列，因此写了下代码，底层用了通用链表，为循环双向结构，结点数据域为void *；通用链表层之上封装了栈和队列，比较简单，但是代码行数有点多，单独摘出：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#define MAX_VERTEX_NUM 1000#define PRINT(format, arg...) \do{ \    printf(&quot;[%s/%d]:&quot;, __func__, __LINE__); \    printf(format, ##arg); \    printf(&quot;\n&quot;); \}while(0)/*****************************底层链表***************************/// 循环双向链表typedef struct link_list_node {    void *data;    struct link_list_node *pre;    struct link_list_node *next;} link_list_node;typedef struct link_list {    int size;    //链表插入函数    void (*insert)( struct link_list *list, void *data );    //链表取第一个结点    void *(*get_first)( struct link_list *list );    //链表取最后一个结点    void *(*get_last)( struct link_list *list );    //链表删除第一个结点    void *(*del)( struct link_list *list );    struct link_list_node *head;} link_list;link_list_node *create_link_list_node(    void *data ){    link_list_node *node = NULL;    node = ( link_list_node * )malloc( sizeof(link_list_node) );    node-&gt;data = data;    node-&gt;pre = NULL;    node-&gt;next = NULL;    return node;}//头插void insert_head(    link_list *list,    void *data ){    if ( !list ) {        PRINT(&quot;list is null.&quot;);        return;    }    link_list_node *node = create_link_list_node( data );    if ( !list-&gt;head ) {        node-&gt;next = node;        node-&gt;pre = node;        list-&gt;head = node;        list-&gt;size = 1;        return;    }    node-&gt;next = list-&gt;head;    node-&gt;pre = list-&gt;head-&gt;pre;    list-&gt;head-&gt;pre-&gt;next = node;    list-&gt;head-&gt;pre = node;    list-&gt;head = node;    list-&gt;size += 1;}//尾插，栈/队列的插入void insert_tail (    link_list *list,    void *data ){    if ( !list ) {        return;    }    link_list_node *node = create_link_list_node( data );    if ( !list-&gt;head ) {        node-&gt;next = node;        node-&gt;pre = node;        list-&gt;head = node;        list-&gt;size = 1;        return;    }    node-&gt;pre = list-&gt;head-&gt;pre;    node-&gt;next = list-&gt;head;    list-&gt;head-&gt;pre-&gt;next = node;    list-&gt;head-&gt;pre = node;    list-&gt;size += 1;}//获取链表头数据void *get_head(    link_list *list ){    if ( !list || !list-&gt;head ) {        PRINT(&quot;list is null.&quot;);        return NULL;    }    return list-&gt;head-&gt;data;}//获取链表尾数据void *get_tail(    link_list *list ){    if ( !list || !list-&gt;head ){        PRINT(&quot;list is null.&quot;);        return NULL;    }    return list-&gt;head-&gt;pre-&gt;data;}//删除链表头，并返回删除结点的数据void *del_head(    link_list *list ){    if ( !list || !list-&gt;head ) {        return NULL;    }    if ( list-&gt;size == 1 ) {        void *data = list-&gt;head-&gt;data;        free( list-&gt;head );        list-&gt;head = NULL;        list-&gt;size = 0;        return data;    }    link_list_node *p = list-&gt;head;    void *data = p-&gt;data;    list-&gt;head-&gt;pre-&gt;next = list-&gt;head-&gt;next;    list-&gt;head-&gt;next-&gt;pre = list-&gt;head-&gt;pre;    list-&gt;head = list-&gt;head-&gt;next;    list-&gt;size -= 1;    free( p );    return data;}//删除链表尾，并返回删除结点的数据void *del_tail(    link_list *list ){    if ( !list || !list-&gt;head ) {        PRINT(&quot;list is null.&quot;);        return NULL;    }    if ( list-&gt;size == 1 ) {        void *data = list-&gt;head-&gt;data;        free( list-&gt;head );        list-&gt;head = NULL;        list-&gt;size = 0;        return data;    }    link_list_node *p = list-&gt;head-&gt;pre;    void *data = p-&gt;data;    list-&gt;head-&gt;pre-&gt;pre-&gt;next = list-&gt;head;    list-&gt;head-&gt;pre = list-&gt;head-&gt;pre-&gt;pre;    list-&gt;size -= 1;    free( p );    return data;}/******************************************************************//********************************队列***********************************/typedef struct queue {    void *(*first)( struct queue *this );    void *(*last)( struct queue *this );    void (*enqueue)( struct queue *this, void *data );    void *(*dequeue)( struct queue *this );    int (*size)( struct queue *this );    void (*free)( struct queue *this );    struct link_list *list;    struct queue *this;} queue;void *queue_get_first(    queue *q ){    if ( !q || !q-&gt;list )        return NULL;    return q-&gt;list-&gt;get_first( q-&gt;list );}void *queue_get_last(    queue *q ){    if ( !q || !q-&gt;list )        return NULL;    return q-&gt;list-&gt;get_last( q-&gt;list );}void enqueue(    queue *q,    void *data ){    if ( !q || !q-&gt;list )        return ;    q-&gt;list-&gt;insert( q-&gt;list, data );}void *dequeue(    queue *q ){    if ( !q || !q-&gt;list )        return NULL;    q-&gt;list-&gt;del( q-&gt;list );}int queue_size(    queue *q ){    if ( !q || !q-&gt;list)        return 0;    return q-&gt;list-&gt;size;}void queue_free(    queue *q ){    if ( !q )        return ;    if ( !q-&gt;list ) {        free( q );        return;    }    while ( q-&gt;dequeue( q-&gt;this ) );    free( q-&gt;list );    free( q );}queue *create_queue(){    queue *q = NULL;    q = ( queue * )malloc( sizeof(queue) );    q-&gt;first = queue_get_first;    q-&gt;last = queue_get_last;    q-&gt;enqueue = enqueue;    q-&gt;dequeue = dequeue;    q-&gt;size = queue_size;    q-&gt;free = queue_free;    q-&gt;list = ( link_list * )malloc( sizeof(link_list) );    q-&gt;list-&gt;size = 0;    q-&gt;list-&gt;insert = insert_tail;    q-&gt;list-&gt;get_first = get_head;    q-&gt;list-&gt;get_last = get_tail;    q-&gt;list-&gt;del = del_head;    q-&gt;this = q;}#undef DEBUG_QUEUE#ifdef DEBUG_QUEUEvoid test_queue(){    queue *q = create_queue();    int data1 = 5;    int data2 = 6;    int data3 = 7;    q-&gt;enqueue(q-&gt;this, (void *)&amp;data1);    PRINT(&quot;q-&gt;last:%d&quot;, *(int *)q-&gt;last(q-&gt;this));    q-&gt;enqueue(q-&gt;this, (void *)&amp;data2);    PRINT(&quot;q-&gt;last:%d&quot;, *(int *)q-&gt;last(q-&gt;this));    q-&gt;enqueue(q-&gt;this, (void *)&amp;data3);    PRINT(&quot;q-&gt;last:%d\n&quot;, *(int *)q-&gt;last(q-&gt;this));    PRINT(&quot;q-&gt;size:%d\n&quot;, q-&gt;size(q-&gt;this));    PRINT(&quot;q-&gt;first:%d&quot;, (int)*(int *)(q-&gt;first(q-&gt;this)));    PRINT(&quot;q-&gt;last:%d\n&quot;, (int)*(int *)(q-&gt;last(q-&gt;this)));    PRINT(&quot;q-&gt;dequeue:%d&quot;, (int)*(int *)(q-&gt;dequeue(q-&gt;this)));    PRINT(&quot;q-&gt;first:%d&quot;, (int)*(int *)(q-&gt;first(q-&gt;this)));    PRINT(&quot;q-&gt;size:%d\n&quot;, q-&gt;size(q-&gt;this));    PRINT(&quot;q-&gt;dequeue:%d&quot;, (int)*(int *)(q-&gt;dequeue(q-&gt;this)));    PRINT(&quot;q-&gt;first:%d&quot;, (int)*(int *)(q-&gt;first(q-&gt;this)));    PRINT(&quot;q-&gt;size:%d\n&quot;, q-&gt;size(q-&gt;this));    PRINT(&quot;q-&gt;dequeue the last element&quot;);    q-&gt;dequeue(q-&gt;this);    PRINT(&quot;q-&gt;size:%d\n&quot;, q-&gt;size(q-&gt;this));    q-&gt;free( q-&gt;this );}int main(){    test_queue();    return 0;}#endif/*****************************************************************//*****************************栈********************************/typedef struct stack {    void *(*first)( struct stack *this );    void *(*last)( struct stack *this );    void (*push)( struct stack *this, void *data );    void *(*pop)( struct stack *this );    int (*size)( struct stack *this );    void (*free)( struct stack *this );    struct link_list *list;    struct stack *this;} stack;void *stack_get_first(    stack *s ){    if ( !s || !s-&gt;list )        return NULL;    return s-&gt;list-&gt;get_first( s-&gt;list );}void *stack_get_last(    stack *s ){    if ( !s || !s-&gt;list )        return NULL;    return s-&gt;list-&gt;get_last( s-&gt;list );}void stack_push(    stack *s,    void *data ){    if ( !s || !s-&gt;list )        return ;    s-&gt;list-&gt;insert( s-&gt;list, data );}void *stack_pop(    stack *s ){    if ( !s || !s-&gt;list )        return NULL;    s-&gt;list-&gt;del( s-&gt;list );}int stack_size(    stack *s ){    if ( !s || !s-&gt;list)        return 0;    return s-&gt;list-&gt;size;}void stack_free(    stack *s ){    if ( !s )        return ;    if ( !s-&gt;list ) {        free( s );        return;    }    while ( s-&gt;pop( s-&gt;this ) );    free( s-&gt;list );    free( s );}stack *create_stack(){    stack *s = NULL;    s = ( stack * )malloc( sizeof(stack) );    s-&gt;first = stack_get_first;    s-&gt;last = stack_get_last;    s-&gt;push = stack_push;    s-&gt;pop = stack_pop;    s-&gt;size = stack_size;    s-&gt;free = stack_free;    s-&gt;list = ( link_list * )malloc( sizeof(link_list) );    s-&gt;list-&gt;size = 0;    s-&gt;list-&gt;insert = insert_tail;    s-&gt;list-&gt;get_first = get_tail;    s-&gt;list-&gt;get_last = get_head;    s-&gt;list-&gt;del = del_tail;    s-&gt;this = s;}#define DEBUG_STACK#ifdef DEBUG_STACKvoid test_stack(){    stack *s = create_stack();    int data1 = 5;    int data2 = 6;    int data3 = 7;    s-&gt;push(s-&gt;this, (void *)&amp;data1);    PRINT(&quot;s-&gt;first:%d&quot;, *(int *)s-&gt;first(s-&gt;this));    s-&gt;push(s-&gt;this, (void *)&amp;data2);    PRINT(&quot;s-&gt;first:%d&quot;, *(int *)s-&gt;first(s-&gt;this));    s-&gt;push(s-&gt;this, (void *)&amp;data3);    PRINT(&quot;s-&gt;first:%d\n&quot;, *(int *)s-&gt;first(s-&gt;this));    PRINT(&quot;s-&gt;size:%d\n&quot;, s-&gt;size(s-&gt;this));    PRINT(&quot;s-&gt;last:%d&quot;, (int)*(int *)(s-&gt;last(s-&gt;this)));    PRINT(&quot;s-&gt;first:%d\n&quot;, (int)*(int *)(s-&gt;first(s-&gt;this)));    PRINT(&quot;s-&gt;pop:%d&quot;, (int)*(int *)(s-&gt;pop(s-&gt;this)));    PRINT(&quot;s-&gt;first:%d&quot;, (int)*(int *)(s-&gt;first(s-&gt;this)));    PRINT(&quot;s-&gt;size:%d\n&quot;, s-&gt;size(s-&gt;this));    PRINT(&quot;s-&gt;pop:%d&quot;, (int)*(int *)(s-&gt;pop(s-&gt;this)));    PRINT(&quot;s-&gt;first:%d&quot;, (int)*(int *)(s-&gt;first(s-&gt;this)));    PRINT(&quot;s-&gt;size:%d\n&quot;, s-&gt;size(s-&gt;this));    PRINT(&quot;s-&gt;pop the first element&quot;);    s-&gt;pop(s-&gt;this);    PRINT(&quot;s-&gt;size:%d\n&quot;, s-&gt;size(s-&gt;this));    s-&gt;free( s-&gt;this );}int main(){    test_stack();    return 0;}#endif</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天准备学习数据结构-图，会用到栈和队列，因此写了下代码，底层用了通用链表，为循环双向结构，结点数据域为void *；通用链表层之上封装了栈和队列，比较简单，但是代码行数有点多，单独摘出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#i
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://lkness/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>外排序多路归并+败者树-算法学习笔记十五</title>
    <link href="http://lkness/2018/06/20/026out-sort/index/"/>
    <id>http://lkness/2018/06/20/026out-sort/index/</id>
    <published>2018-06-20T04:40:53.000Z</published>
    <updated>2018-06-20T04:46:12.233Z</updated>
    
    <content type="html"><![CDATA[<p>问题：一个文件有大量的数，现要对文件排序，但内存无法一次读取完全，而磁盘空间足够，要如何排序。</p><p>学习了几篇博客：</p><ol><li>july<a href="https://blog.csdn.net/v_july_v/article/details/6451990" target="_blank" rel="noopener">大神的海量数据排序</a>(他的其他博客都很值得看)</li><li>对july大神的算法进行改进不用选择法而是败者树的<a href="www.cnblogs.com/harryshayne/archive/2011/07/02/2096196.html">博客</a></li><li>以及另一篇但不知道是否为原创的<a href="http://kenby.iteye.com/blog/1017532" target="_blank" rel="noopener">博客</a></li><li>还有<a href="http://www.cnblogs.com/eaglet/archive/2011/01/17/1937083.html" target="_blank" rel="noopener">生成不重复乱序m-n的数的博客</a>(先生成m-n的数，然后洗牌算法)</li></ol><p>#<br>以上几篇博客写得很完全了，看懂了思路，自己临摹写一个简单的测试 ….<br><strong>先用生成随机数的代码生成data.txt待排序大文件:</strong></p><pre><code>//生成随机的不重复的测试数据#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;assert.h&gt;#include &lt;stdlib.h&gt;  // RAND_MAXusing namespace std;//产生[i,u]区间的随机数int randint(int l, int u){    int a = RAND_MAX * rand();    int b = rand();    //取低31位    int c = ( a + b ) &amp; (0x7fffffff) % ( u - l + 1 );    int d = l + c;    return d;}const int size = 10000000;// const int size = 10;int num[size];int main(){    srand((int)time(NULL));    int i, j;    FILE *fp = fopen(&quot;data.txt&quot;, &quot;w&quot;);    assert(fp);    for (i = 0; i &lt; size; i++)        num[i] = i+1;    // printf(&quot;rand_max:%d\n&quot;, RAND_MAX);    for (i = 0; i &lt; size; i++)    {        j = randint(i, size-1);        // printf(&quot;%d &quot;, j);        fflush(stdout);        int t = num[i]; num[i] = num[j]; num[j] = t;        //swap(num[i], num[j]);    }    // printf(&quot;\n&quot;);    for (i = 0; i &lt; size; i++)        fprintf(fp, &quot;%d\n&quot;, num[i]);    fclose(fp);    return 0;}</code></pre><p><strong>对data.txt文件开始外排序:</strong></p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;time.h&gt;#define TEMP_PREFIX &quot;ftemp_&quot;#define OUTPUT_FILE &quot;out_data.txt&quot;#define MAX_WAYS  100// 无穷大，用于某一路文件或缓冲区读到尾了// 败者树产生一个注定失败的结点#define INFINITY 1000000000int *buf;int lst[MAX_WAYS];void read_data(FILE *fp, int *buf){    if ( fscanf(fp, &quot;%d &quot;, buf) == EOF )        *buf = INFINITY;}int partition( int *arr, int p, int r ){    int x = arr[r];    int i = p - 1;    int j = 0, temp;    for ( j = p; j &lt;= r - 1; j++ ) {        if ( arr[j] &lt;= x ) {            i += 1;            temp = arr[i];            arr[i] = arr[j];            arr[j] = temp;        }    }    temp = arr[i + 1];    arr[i + 1] = arr[r];    arr[r] = temp;    return i + 1;}void quick_sort( int *arr, int p, int r ){    if ( p &lt; r ) {        int q = partition( arr, p, r );        quick_sort( arr, p, q - 1 );        quick_sort( arr, q + 1, r );    }}void adjust( int k, int s ){    // t为结点s在败者树数组的父结点，    // 例如64路归并，输入63/62，他们    // 的父结点均为 63    int t = ( k + s ) / 2;    while ( t &gt; 0 ) {        if ( s == -1 ) {            break;        }        // 第一趟，输入一个叶子结点s，让s与父结点的值比较        // （这里父结点一定保存上一次比较的较大者），如果s        // 大于父结点的值，表示s为新的败者，将表示s结点的        // 索引放到父结点处，胜者（父结点）继续到更上层的        // 父结点进行比较，这样比较完后，顶点一定放置的最        // 小的值        // 将败者树想象为一场淘汰赛，假如有8个参赛者入口，        // 8个参赛者编号1-8，第一轮（即初始化败者树），假        // 设产生了2/4/6/8四强败者，放置到8个入口上一层（        // 即父结点），然后再产生两强败者5/7，放置到更上一        // 层的结点，然后产生最后的失败者1，而剩余的8就是最        // 终的胜者，这样一棵败者树就初始化好了，        // 8个入口，之后我们可以随便哪个入口加入一个参赛者，        // 这个参赛者只需要与父结点进行比较，败者留下，胜者        // 可以往更高的父结点去参加比赛....这样每一轮进入一        // 个参赛者，每次能得到一个新的冠军(最小值)，然后写入        // 文件末尾        // 这里的8其实就是8路归并，这个入口的参赛者每次就去        // 读取8个排好序的文件或缓冲区        if ( buf[s] &gt; buf[lst[t]] ) {            int temp = s;            s = lst[t];            lst[t] = temp;        }        t &gt;&gt;= 1;    }    // 以2^n次方来算，顶层败者编号为1，所以败者树数组lst[0]一定    // 没存东西，可以用来存放最后的冠军    lst[0] = s;}void create_loser_tree(int k){    int i = 0;    for( i; i &lt; k; i++ ) {        lst[i] = -1;    }    for( i = k - 1; i &gt;= 0; i-- ) {        adjust(k, i);    }}void k_merge(    int k ){    int i = 0;    FILE **ftemp = ( FILE * )malloc( sizeof(FILE *) * k );    FILE *fout = NULL;    // 归并路数大小的数组，每个数组值存放每一个归并路文件读取的    // 一个值，某一个索引的值写入输出文件，又读取对应文件下一个    // 值补充    buf = ( int * )malloc( sizeof(int) * k );    fout = fopen( OUTPUT_FILE, &quot;w+&quot; );    for ( i; i &lt; k; i++ ) {        char file_name[20] = {0};        snprintf( file_name, sizeof(file_name), TEMP_PREFIX&quot;%d&quot;, i );        ftemp[i] = fopen( file_name, &quot;r&quot; );        // 读取每个排序好的临时文件第一个数        fscanf( ( FILE * )ftemp[i], &quot;%d &quot;, buf + i );    }    // 以排好序文件第一个数的数组来创建败者树，    // 树结点产生败者，这样以后的每轮比较只需要    // 去文件或缓冲区读取下一个值加入败者树入口即可    create_loser_tree( k );    // 开始归并， 哪一个入口产生的冠军，先把冠军写入输出文件，    // 然后冠军所属的文件或缓冲区再读入一个数进行比赛，如果某一路    // 文件或缓冲区读到尾了，那么这个入口的参赛者为无限大，这样    // 与之共有一个父结点的兄弟结点每次读取的值都能成为胜者，参加    // 父结点以上的比较，到所有节点都读完时，最终败者结点，即lst[1]    // 为无穷大，再加入一个参赛者，lst[0]也为无穷大了，    while ( buf[lst[0]] != INFINITY ) {        // 读取冠军的值        int q = lst[0];        // 将冠军写入输出文件        fprintf(fout, &quot;%d\n&quot;, buf[q]);        // 读取冠军所属队列（文件或缓冲区）的下一个值        read_data(ftemp[q], &amp;buf[q]);        // 加入了一个新参赛者，调整败者树        adjust(k, q);    }    // 清理    free( buf );    for ( i = 0; i &lt; k; i++ ) {        fclose(ftemp[i]);    }}void memory_sort_small_file(    FILE *fp,    int num, // 待排序数的数量    int k ){    int i = 0;    int num_per_ways = num / k; // 每一路多少个数    int *buf = NULL;    FILE **ftemp = ( FILE * )malloc( sizeof(FILE *) * k );    buf = ( int * )malloc( sizeof(int) * num_per_ways + 1000 );    // for ( i = 0; i &lt; k; i++ ) {    //     char temp_buf[20] = {0};    //     snprintf( temp_buf, sizeof(temp_buf), TEMP_PREFIX&quot;%d&quot;, i);    //     ftemp[i] = fopen( temp_buf, &quot;w+&quot; );    //     if ( ftemp[i] == NULL ) {    //         printf(&quot;[%s:%d],error occured!!(%s)\n&quot;, __func__, __LINE__, strerror(errno));    //         exit( 0 );    //     }    // }    // 先不处理最后一个，可能总数/k路带余数，多余的    // 留到最后一个文件处理    k--;    while ( k &gt; 0 ) {        char temp_buf[20] = {0};        snprintf( temp_buf, sizeof(temp_buf), TEMP_PREFIX&quot;%d&quot;, k);        ftemp[k] = fopen( temp_buf, &quot;w+&quot; );        if ( ftemp[k] == NULL ) {            printf(&quot;[%s:%d],error occured!!(%s)\n&quot;, __func__, __LINE__, strerror(errno));            exit( 0 );        }        i = 0;        memset( buf, 0, sizeof(buf) );        for ( i; i &lt; num_per_ways; i++ ) {            fscanf(fp, &quot;%d &quot;, &amp;buf[i]);        }        printf(&quot;%s:%d, K:%d\n&quot;, __func__, __LINE__, k);        quick_sort( buf, 0, num_per_ways - 1 );        for ( i = 0; i &lt; num_per_ways; i++ ) {            fprintf(ftemp[k], &quot;%d &quot;, buf[i]);        }        fclose( ftemp[k] );        k--;    }    // 处理剩余的最后一个待排序文件    char temp_buf[20] = {0};    snprintf( temp_buf, sizeof(temp_buf), TEMP_PREFIX&quot;%d&quot;, 0);    ftemp[0] = fopen( temp_buf, &quot;w+&quot; );    if ( ftemp[0] == NULL ) {        printf(&quot;[%s:%d],error occured!!(%s)\n&quot;, __func__, __LINE__, strerror(errno));        exit( 0 );    }    i = 0;    while ( fscanf(fp, &quot;%d &quot;, &amp;buf[i]) != EOF ) i++;    printf(&quot;%s:%d, K:%d\n&quot;, __func__, __LINE__, 0);    quick_sort( buf, 0, i );    int j = 0;    for ( j = 0; j &lt;= i; j++ ) {        fprintf(ftemp[0], &quot;%d &quot;, buf[j]);    }    free( buf );    fclose( ftemp[0] );}int main(    int argc,    char **argv ){    if ( argc != 3 ) {        printf(&quot;usage:\n\t./xxx file_name k ways to merge\n&quot;);        exit( 0 );    }    int k = atoi( argv[2] );    char *file_name = argv[1];    FILE *fp = fopen(file_name, &quot;r&quot;);    if ( fp == NULL ) {        printf(&quot;[%s:%d],error occured!!(%s)\n&quot;, __func__, __LINE__, strerror(errno));        exit( 0 );    }    time_t t1 = time(NULL), t2, t3;    memory_sort_small_file( fp, 10000000, k );    t2 = time(NULL);    k_merge( k );    t3 = time(NULL);    printf(&quot;---------------------------finish-----------------------------\n&quot;);    printf(&quot;\tmemory sort &amp; ouput to temp file cost:  %ds\n&quot;, (int)(t2 - t1));    printf(&quot;\tk_merge &amp; ouput to file cost:  %ds\n&quot;, (int)(t3 - t2));    printf(&quot;\ttotal cost time:  %ds\n&quot;, (int)(t3 - t1));    printf(&quot;--------------------------------------------------------------\n&quot;);    fclose( fp );    return 0;}</code></pre><p>64路归并排序1000w个数用时：</p><p><img src="/img/out_sort1.png" alt="out_sort1"></p><p>生成文件：</p><p><img src="/img/out_sort2.png" alt="out_sort2"></p><p>排序后的文件头和尾：</p><p><img src="/img/out_sort3.png" alt="out_sort3"><br><img src="/img/out_sort4.png" alt="out_sort4"></p><p>代码注释写了很多了，以后忘了回头看看也能记起来 …..</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;问题：一个文件有大量的数，现要对文件排序，但内存无法一次读取完全，而磁盘空间足够，要如何排序。&lt;/p&gt;
&lt;p&gt;学习了几篇博客：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;july&lt;a href=&quot;https://blog.csdn.net/v_july_v/article/details/
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://lkness/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>trie树-《算法导论》学习笔记十四</title>
    <link href="http://lkness/2018/06/20/025trie-tree/index/"/>
    <id>http://lkness/2018/06/20/025trie-tree/index/</id>
    <published>2018-06-20T04:34:50.000Z</published>
    <updated>2018-06-20T04:38:29.448Z</updated>
    
    <content type="html"><![CDATA[<p>引用一下百度百科的话吧：<br>Trie树，又称单词查找树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p><p>这里构建了一棵字典树，每个结点有52个孩子指针，对应26个小写字母和26个大写字母，根节点不存储数据，一个单词从第一个字母开始经由根结点走对应分支进行插入和统计。</p><p>trie树结点卫星数据包含了字母、出现次数、是否构成一个单词，孩子指针就是一个52大小的trie树结点指针数组。</p><p>实现了几个操作：</p><h1 id="插入单词"><a href="#插入单词" class="headerlink" title="插入单词"></a>插入单词</h1><blockquote><p>遍历每个字母，从根结点出发，如果结点对应字母的孩子结点为空，就创建结点，出现次数为1，如果存在这个结点，出现次数就+1，并且如果单词结束，结束处的结点是否构成一个单词字段标识为构成</p></blockquote><h1 id="遍历树，并打印所有单词和每个单词出现次数"><a href="#遍历树，并打印所有单词和每个单词出现次数" class="headerlink" title="遍历树，并打印所有单词和每个单词出现次数"></a>遍历树，并打印所有单词和每个单词出现次数</h1><h1 id="统计树，按给定的数字统计出现次数前几的单词"><a href="#统计树，按给定的数字统计出现次数前几的单词" class="headerlink" title="统计树，按给定的数字统计出现次数前几的单词"></a>统计树，按给定的数字统计出现次数前几的单词</h1><blockquote><p>树统计，与遍历类似，用尾递归，并传入一个大于单词最大长度的数组来存储每个分支的单词，如果遇到结点能构成一个单词，就判断你单词个数，并以插入排序的方式插入创建的统计链表（类似打扑克的插排序）；<br> 统计链表有更新操作，根据输入的统计前几的数字来维护这个链表该去掉哪些结点，该更新哪些结点的顺序等</p></blockquote><p>##<br>获取单词来源为编写的一个简单单词随机生成代码，写入一个文件中，可指定单词最大长度，全大写/全小写/大小写均有，单词个数，单词范围（只支持a-<em>或A-</em>，例如5，就是生成a-e/A-E的单词）<br>贴代码：<br><strong>随机生成单词</strong></p><pre><code>#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int word_len = 0;int upper_low = 65;int lowwer_low = 97;// if letter_size = 5// it will generate a-e or A-E letter.int letter_size = 0;int random_letter(){    return rand() % letter_size;}int random_word(    char *word,    int opt ){    // minimum word&apos;length is 3.    int true_word_len = rand() % word_len + 3;    int true_word_len1 = true_word_len;    while ( true_word_len-- ) {        char letter = 0;        if ( opt == 0 ) {            letter = random_letter() + lowwer_low;        } else if ( opt == 1 ) {            letter = random_letter() + upper_low;        } else {            int opt_case = rand() % 2;            if ( opt_case == 0 )                letter = random_letter() + lowwer_low;            else                letter = random_letter() + upper_low;        }        word[true_word_len] = letter;    }    return true_word_len1;}void gen_word(    int fd,    int word_num,    int opt ){    char word[20] = {0};    int true_word_len = 0;    while ( word_num-- ) {        memset( word, 0, 20);        true_word_len = random_word( word, opt );        word[true_word_len] = &apos;\n&apos;;        write( fd, word, true_word_len + 1 );    }}int main(    int argc,    char **argv ){    srand((int)time(NULL));    if ( argc != 5 ) {        printf(&quot;please input &quot;                &quot;word&apos;s length &amp; &quot;                &quot;words&apos; number &amp; &quot;                &quot;word&apos;s range &amp; &quot;                &quot;gen_case(0:lowwer case,1:upper case,other:both\n&quot;);        exit( 0 );    }    word_len = atoi( argv[1] );    int word_num = atoi( argv[2] );    letter_size = atoi( argv[3] );    int opt = atoi( argv[4] );    int fd = open(&quot;word.txt&quot;, O_RDWR | O_TRUNC, 0777);    gen_word( fd, word_num, opt );    close( fd );    return 0;}</code></pre><p><strong>trie树</strong></p><pre><code>#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#define MAX_CHILD_NUM 52#define UPPER_LOW 65#define UPPER_UP 90#define LOWER_LOW 97#define LOWER_UP 122#define PRINT(format, arg...) \do { \    printf(&quot;[%s/%d]:&quot;, __func__, __LINE__); \    printf(format, ##arg); \    printf(&quot;\n&quot;); \}while(0)typedef struct trieTreeNode {    char letter;    int count;    int is_word;    struct trieTreeNode *next[MAX_CHILD_NUM];} trieTreeNode;typedef struct trieTree {    trieTreeNode *root;} trieTree;typedef struct count_data {    int order;    int count;    char string[20];    struct count_data *next;} count_data;int trans_letter_2_index(    char letter ){    int index = -1;    if ( letter &gt;= LOWER_LOW        &amp;&amp; letter &lt;= LOWER_UP ) {        index = letter - LOWER_LOW + 26;    } else if ( letter &gt;= UPPER_LOW        &amp;&amp; letter &lt;= UPPER_UP ) {        index = letter - UPPER_LOW;    } else {        PRINT(&quot;error letter input:%c&quot;, letter);        exit( 0 );    }    return index;}trieTreeNode *create_node(    char letter ){    trieTreeNode *node =        ( trieTreeNode * )calloc( 1, sizeof(trieTreeNode) );    node-&gt;letter = letter;    node-&gt;count = 0;    node-&gt;is_word = 0;}void insert(    trieTreeNode *root,    char *word ){    if ( root == NULL ) {        PRINT(&quot;root node is null.&quot;);        return;    }    int i = 0;    trieTreeNode *cur = root;    for ( i; word[i] != &apos;\0&apos;; i++ ) {        int next_index = trans_letter_2_index(word[i]);        //PRINT(&quot;letter:%c, index:%d&quot;, word[i], next_index);        if ( cur-&gt;next[next_index] == NULL ) {            cur-&gt;next[next_index] = create_node( word[i] );        } else {            //cur-&gt;next[next_index]-&gt;count += 1;        }        if ( word[i+1] == &apos;\0&apos; ) {            cur-&gt;next[next_index]-&gt;count += 1;            cur-&gt;next[next_index]-&gt;is_word = 1;        }        cur = cur-&gt;next[next_index];    }}// 删除链表所有结点void delete_list_all_node(    count_data *node ){    count_data *p = NULL;    while ( node ) {        p = node;        node = node-&gt;next;        free( p );    }}void print_list_all_node(    count_data *node ){    printf(&quot;\n&quot;);    node = node-&gt;next;    while ( node ) {        printf(&quot;[%d],count:%d\tword:%s\n&quot;,            node-&gt;order, node-&gt;count, node-&gt;string);        node = node-&gt;next;    }    printf(&quot;\n&quot;);}void update_insert_node(    count_data *insert_node ){    if ( !insert_node-&gt;next )        return;    count_data *print_p = insert_node;    if ( insert_node-&gt;order == 1 ) {        delete_list_all_node( insert_node-&gt;next );        insert_node-&gt;next = NULL;    } else if ( insert_node-&gt;order &lt; 1 ) {        PRINT(&quot;ERROR!!!!!&quot;);        exit( 0 );    } else {        count_data *p = insert_node;        insert_node = insert_node-&gt;next;        while ( insert_node ) {            if ( insert_node-&gt;count &lt; p-&gt;count ) {                insert_node-&gt;order = p-&gt;order - 1;            } else if ( insert_node-&gt;count &gt; p-&gt;count ) {                PRINT(&quot;ERROR!!!cur-&gt;count:%d, pre-&gt;count:%d&quot;,                    insert_node-&gt;count, p-&gt;count);                exit( 0 );            } else {                insert_node-&gt;order = p-&gt;order;            }            if ( insert_node-&gt;order &lt; 1 ) {                delete_list_all_node( insert_node );                p-&gt;next = NULL;                break;            }            p = insert_node;            insert_node = insert_node-&gt;next;        }    }}void list_insert(    char *tmp_word,    int cur_count,    int tail,    count_data *head,    int top_num ){    tmp_word[tail] = &apos;\0&apos;;    count_data *new_data = ( count_data * )malloc( sizeof(count_data) );    new_data-&gt;count = cur_count;    memcpy( new_data-&gt;string, tmp_word, tail + 1 );    new_data-&gt;next = NULL;    //PRINT(&quot;count:%d\ttmp_word:%s, string:%s&quot;, cur_count, tmp_word, new_data-&gt;string);    if ( head-&gt;next == NULL ) {        head-&gt;next = new_data;        new_data-&gt;order = top_num;    } else if ( cur_count &gt; head-&gt;next-&gt;count ) {        new_data-&gt;order = head-&gt;next-&gt;order;        new_data-&gt;next = head-&gt;next;        head-&gt;next = new_data;        update_insert_node( new_data );    } else {        while ( 1 ) {            head = head-&gt;next;            if ( head-&gt;next == NULL ) {                if ( head-&gt;order &gt; 1 ) {                    head-&gt;next = new_data;                    if ( head-&gt;count == new_data-&gt;count )                        new_data-&gt;order = head-&gt;order;                    else                        new_data-&gt;order = head-&gt;order - 1;                    head-&gt;next = new_data;                } else if ( head-&gt;count &gt; new_data-&gt;count ) {                    // 不插入                    free( new_data );                } else if ( head-&gt;count == new_data-&gt;count ) {                    head-&gt;next = new_data;                    new_data-&gt;order = head-&gt;order;                } else if ( head-&gt;count &lt; new_data-&gt;count ) {                    // 此种情况只有求出现次数最多的前1个单词时有                    head-&gt;count = new_data-&gt;count;                    free( new_data );                }                break;            } else if ( head-&gt;count &gt;= cur_count                &amp;&amp; head-&gt;next-&gt;count &lt; cur_count ) {                new_data-&gt;next = head-&gt;next;                head-&gt;next = new_data;                new_data-&gt;order = head-&gt;order;                update_insert_node( new_data );                break;            }        }    }}void find_top_count1(    trieTreeNode *root,    char *tmp_word,    int tail,    count_data *head,    int top_num ){    if ( !root )        return;    tmp_word[tail] = root-&gt;letter;    tail++;    if ( root-&gt;is_word ) {        /*        printf(&quot;\n--------------before delete------------------\n&quot;);        print_list_all_node( head );        printf(&quot;\n--------------------------------------------\n&quot;);        */        list_insert( tmp_word, root-&gt;count, tail, head, top_num );        /*        printf(&quot;\n--------------------after delete----------------------------\n&quot;);        print_list_all_node( head );        printf(&quot;\n-----------------------------------------------------------\n&quot;);        */    }    int i = 0;    for ( i; i &lt; MAX_CHILD_NUM; i++ ) {        find_top_count1( root-&gt;next[i], tmp_word, tail, head, top_num );    }}void find_top_count(    trieTreeNode *root,    int top_num ){    if ( !root )        return;    int i = 0;    count_data *head = ( count_data * )malloc( sizeof(count_data) );    for ( i; i &lt; MAX_CHILD_NUM; i++ ) {        char tmp_word[20] = {0};        find_top_count1( root-&gt;next[i], tmp_word, 0, head, top_num );    }    printf(&quot;出现次数最大前%d次的单词:\n&quot;, top_num);    count_data *p = head-&gt;next;    count_data *free_p = NULL;    while ( p != NULL ) {        free_p = p;        printf(&quot;前%d,count:%d\t%s\n&quot;, p-&gt;order, p-&gt;count, p-&gt;string);        p = p-&gt;next;        free( free_p );    }    free( head );}void tree_walk1(    trieTreeNode *root,    char *tmp_word,    int tail ){    if ( !root )        return;    tmp_word[tail] = root-&gt;letter;    tail++;    //printf(&quot;%c\n&quot;, root-&gt;letter);    if ( root-&gt;is_word ) {        int j = 0;        printf(&quot;count:%d\t&quot;, root-&gt;count);        for ( j; j &lt; tail; j++ ) {            printf(&quot;%c&quot;, tmp_word[j]);        }        printf(&quot;\n&quot;);    }    int i = 0;    for ( i; i &lt; MAX_CHILD_NUM; i++ ) {        tree_walk1( root-&gt;next[i], tmp_word, tail );    }}void tree_walk(    trieTreeNode *root ){    if ( !root )        return;    int i = 0;    for ( i; i &lt; MAX_CHILD_NUM; i++ ) {        char tmp_word[20] = {0};        tree_walk1( root-&gt;next[i], tmp_word, 0 );    }}int main(    int argc,    char **argv ){    if ( argc != 3 ) {        PRINT(&quot;USAGE: please input words file &amp; top number&quot;);        exit( 0 );    }    char *file_name = argv[1];    int top_num = atoi( argv[2] );    trieTree *tree = ( trieTree * )malloc( sizeof(trieTree) );    tree-&gt;root = create_node( -1 );    int fd = open(file_name, O_RDONLY);    if ( fd &lt; 0 ) {        PRINT(&quot;OPEN FILE %s ERROR!!!(%s)&quot;, file_name, (char *)strerror(errno));        exit( 0 );    }    // 每次读取文件的缓冲区    char buf[1024 * 10] = {0};    // 每次读取的大小    int read_len = 1024;    // 读取的返回值    int read_bytes = 0;    // 从读取的缓冲区每次提取&apos;\n&apos; - &apos;\n&apos;之间的单词    char tmp_word[20] = {0};    // 读取文件缓冲区如果出现单词隔断，剩余部分在下一次    // read才能读到，这个index做单词继续拼接    int tmp_index = 0;    while ( 1 ) {        memset( buf, 0, read_len );        read_bytes = read( fd, buf, read_len );        if ( read_bytes &lt;= 0 )            break;        //printf(&quot;readbytes:%d------\n%s\n&quot;, read_bytes, buf);        int cur = 0;        while ( cur &lt; read_bytes ) {            // 单词文件最后一个单词末尾一定要有&apos;\n&apos;            if ( buf[cur] == &apos;\n&apos; ) {                tmp_word[tmp_index] = &apos;\0&apos;;                //printf(&quot;insert word:%s\n&quot;, tmp_word);                insert( tree-&gt;root, tmp_word );                memset( tmp_word, 0, 20 );                tmp_index = 0;            } else {                tmp_word[tmp_index] = buf[cur];                tmp_index++;            }            cur++;        }    }    printf(&quot;\n========================================\n&quot;);    tree_walk( tree-&gt;root );    find_top_count( tree-&gt;root, top_num );    close( fd );    return 0;}</code></pre><p>trie树的代码使用：./xxx word.txt 10即统计出现次数前10的单词，并打印单词和次数</p><p>例如对生成了10000个单词的word.txt文件，统计前5：<br>./xxx word.txt 5</p><p><img src="/img/trie_tree.png" alt="trie_tree"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引用一下百度百科的话吧：&lt;br&gt;Trie树，又称单词查找树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://lkness/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>avl树-《算法导论》学习笔记十三</title>
    <link href="http://lkness/2018/06/20/024avl-tree/index/"/>
    <id>http://lkness/2018/06/20/024avl-tree/index/</id>
    <published>2018-06-20T02:55:19.000Z</published>
    <updated>2018-06-20T04:39:26.707Z</updated>
    
    <content type="html"><![CDATA[<p>（引用算法导论）AVL树是一种高度平衡的二叉搜索树：对每一个结点x，y的左子树与右子树的高度至多为1。AVL树相比二叉搜索树，每个结点维护一个额外的属性：结点的高度。</p><p>AVL树实现了几个操作：</p><h1 id="树结点创建"><a href="#树结点创建" class="headerlink" title="树结点创建"></a>树结点创建</h1><h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><blockquote><p>递归的前序、中序、后序遍历，以及基于层序遍历的简单图形打印</p></blockquote><h1 id="后序遍历释放树结点"><a href="#后序遍历释放树结点" class="headerlink" title="后序遍历释放树结点"></a>后序遍历释放树结点</h1><h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h1 id="寻找结点子树最小关键字结点、寻找结点子树最大关键字结点"><a href="#寻找结点子树最小关键字结点、寻找结点子树最大关键字结点" class="headerlink" title="寻找结点子树最小关键字结点、寻找结点子树最大关键字结点"></a>寻找结点子树最小关键字结点、寻找结点子树最大关键字结点</h1><h1 id="求结点高度"><a href="#求结点高度" class="headerlink" title="求结点高度"></a>求结点高度</h1><h1 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h1><h1 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h1><h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><blockquote><p>先以普通二叉搜索树的方式插入结点；</p><p>插入结点后可能影响平衡（一个子树高度-另一子树高度等于2），具体的不平衡的情况分四种：</p><ol><li>结点左子树高度-右子树高度=2，且结点左孩子的左子树更高</li><li>结点左子树高度-右子树高度=2，且结点右孩子的右子树更高</li><li>结点右子树高度-左子树高度=2，且结点右孩子的右子树更高</li><li>结点右子树高度-左子树高度=2，且结点右孩子的左子树更高</li></ol><p>对于情况1，只需对结点进行右旋即可重新平衡；</p><p>对于情况3，只需对结点进行左旋即可重新平衡；</p><p>对于情况2，需要先对结点的左孩子进行左旋，然后对结点进行右旋即可平衡；</p><p>对于情况4，需要先对结点的右孩子进行右旋，然后对结点进行左旋即可平衡；</p><p>旋转之后，结点的左子树与右子树达到平衡，但结点父结点的树可能不平衡，</p><p>需要循环向根节点判断结点高度有无平衡，直至根节点。</p></blockquote><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><blockquote><ol><li><p>先查询相同的key的结点；</p></li><li><p>找到待删除结点，如果待删除结点的左孩子与右孩子都不为空，则判断左右孩子的树高：</p></li></ol><ul><li>若左子树更高，则将左子树的最大关键字结点的关键字替换掉待删除结点的关键字，然后再删除那个左子树最大关键字结点</li><li>若右子树与左子树同高或更高，则将右子树的最小关键字结点的关键字替换掉待删除节点的关键字，然后再删除那个右子树最小关键字结点</li></ul><ol start="3"><li>删除结点后，会影响树平衡，具体不平衡情况与插入时相同，依然进行相同操作来重新平衡树</li></ol></blockquote><p>#</p><p>代码:</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#include &lt;math.h&gt;#define MAX(a, b) ((a &gt; b) ? (a) : (b))typedef struct avlTreeNode {    int key;    int height;    //这里有父结点，有了父结点多很多代码，    //大部分的调试都是父结点的值没注意，    //可取消这个字段    struct avlTreeNode *parent;    struct avlTreeNode *left;    struct avlTreeNode *right;}avlTreeNode;typedef struct avlTree {    int node_num;    avlTreeNode *root;}avlTree;// 随机基数尽量大，代码不支持key值相同的// 树节点，但不影响插入，删除会出错，所以// 尽量保证不同int random_num(){    int a = 1;    int b = 10000;    return rand() % ( b - a ) + a;}avlTreeNode *tree_create_node(    int key,    avlTreeNode *parent,    avlTreeNode *left,    avlTreeNode *right ){    avlTreeNode *node = ( avlTreeNode * )malloc( sizeof(avlTreeNode) );    node-&gt;height = 1;    node-&gt;key = key;    node-&gt;parent = parent;    node-&gt;left = left;    node-&gt;right = right;    return node;}//后续遍历释放树结点void postorder_tree_free(    avlTreeNode *root ){    if ( root != NULL ) {        postorder_tree_free( root-&gt;left );        postorder_tree_free( root-&gt;right );        printf(&quot;%d &quot;, root-&gt;key);        free( root );    }}void inorder_tree_walk(    avlTreeNode *root ){    if ( root != NULL ) {        inorder_tree_walk( root-&gt;left );        printf(&quot;%d(%d) &quot;, root-&gt;key, root-&gt;height);        inorder_tree_walk( root-&gt;right );    }}void preorder_tree_walk(    avlTreeNode *root ){    if ( root != NULL ) {        printf(&quot;%d(%d) &quot;, root-&gt;key, root-&gt;height);        preorder_tree_walk( root-&gt;left );        preorder_tree_walk( root-&gt;right );    }}void postorder_tree_walk(    avlTreeNode *root ){    if ( root != NULL ) {        postorder_tree_walk( root-&gt;left );        postorder_tree_walk( root-&gt;right );        printf(&quot;%d(%d) &quot;, root-&gt;key, root-&gt;height);    }}//层序遍历，支持简单的树形打印//为了调试代码，而不用中序和前序//去推算树int queue_pre = -1;int queue_post = 0;avlTreeNode *node_queue[1000] = {NULL};int factor( int n ){    if ( n == 1 )        return 1;    return (pow(2,n-1) + factor( n - 1 ));}void graph_tree_walk(    avlTreeNode *root,    int height,    int root_height ){    if ( queue_pre == factor( root_height ) - 1 )        return ;    queue_pre++;    if ( root == NULL ) {        printf(&quot;* &quot;);        node_queue[queue_post] = NULL;        queue_post++;        node_queue[queue_post] = NULL;        queue_post++;    } else {        node_queue[queue_post] = root-&gt;left;        queue_post++;        node_queue[queue_post] = root-&gt;right;        queue_post++;        printf(&quot;%d &quot;, root-&gt;key);    }    int new_height = height;    if ( queue_pre == factor( height ) - 1 ) {        printf(&quot;\n&quot;);        new_height = height + 1;    }    graph_tree_walk( node_queue[queue_pre], new_height, root_height );}void print_tree(    avlTree *tree ){    printf(&quot;中序:&quot;);    inorder_tree_walk( tree-&gt;root );    printf(&quot;\n&quot;);    printf(&quot;前序:&quot;);    preorder_tree_walk( tree-&gt;root );    printf(&quot;\n&quot;);    printf(&quot;后序:&quot;);    postorder_tree_walk( tree-&gt;root );    printf(&quot;\n&quot;);    printf(&quot;图形:\n&quot;);    graph_tree_walk( tree-&gt;root, 1, tree-&gt;root-&gt;height );    queue_pre = -1;    queue_post = 0;    int i = 999;    for ( i ; i &gt;=0; i-- )        node_queue[i] = NULL;    printf(&quot;\n\n&quot;);}//检查avl树的树高是否差2以内int check_is_avltree(    avlTreeNode *root ){    if ( root == NULL )        return 0;    int left_height = check_is_avltree( root-&gt;left );    int right_height = check_is_avltree( root-&gt;right );    if ( left_height - right_height &gt;= 2 || right_height - left_height &gt;= 2 )        printf(&quot;it&apos;s not a avl tree!!!! l:%d, r:%d\n&quot;, left_height, right_height);    else        //printf(&quot;left:%d,right:%d\n&quot;, left_height, right_height);    return (left_height &gt; right_height ? left_height : right_height ) + 1;}avlTreeNode *tree_search_recursion(    avlTreeNode *root,    int key ){    if ( root == NULL || key == root-&gt;key ) {        return root;    }    if ( key &lt; root-&gt;key )        return tree_search_recursion( root-&gt;left, key );    else        return tree_search_recursion( root-&gt;right, key );}avlTreeNode *tree_search(    avlTreeNode *root,    int key ){    while ( root != NULL &amp;&amp; key != root-&gt;key ) {        if ( key &lt; root-&gt;key )            root = root-&gt;left;        else            root = root-&gt;right;    }    return root;}avlTreeNode *tree_minimum(    avlTreeNode *root ){    while ( root-&gt;left != NULL ) {        root = root-&gt;left;    }    return root;}avlTreeNode *tree_maximum(    avlTreeNode *root ){    while ( root-&gt;right != NULL ) {        root = root-&gt;right;    }    return root;}int node_height(    avlTreeNode *node ){    if ( node == NULL )        return 0;    return node-&gt;height;}int tree_height(    avlTree *tree ){    return node_height( tree-&gt;root );}avlTreeNode *left_rotate(    avlTreeNode *node ){    if ( node != NULL &amp;&amp; node-&gt;right != NULL ) {        avlTreeNode *p = node-&gt;right-&gt;left;        if ( node-&gt;parent == NULL ) {            node-&gt;right-&gt;parent = NULL;        } else if ( node == node-&gt;parent-&gt;left ) {            node-&gt;parent-&gt;left = node-&gt;right;            node-&gt;right-&gt;parent = node-&gt;parent;        } else {            node-&gt;parent-&gt;right = node-&gt;right;            node-&gt;right-&gt;parent = node-&gt;parent;        }        node-&gt;parent = node-&gt;right;        node-&gt;right-&gt;left = node;        node-&gt;right = p;        if ( p != NULL )            p-&gt;parent = node;        node-&gt;height = MAX( node_height(node-&gt;left),                            node_height(node-&gt;right) ) + 1;        node-&gt;parent-&gt;height = MAX( node_height(node-&gt;parent-&gt;left),                                    node_height(node-&gt;parent-&gt;right) ) + 1;        return node-&gt;parent;    }    return node;}avlTreeNode *right_rotate(    avlTreeNode *node ){    if ( node != NULL &amp;&amp; node-&gt;left != NULL ) {        avlTreeNode *p = node-&gt;left-&gt;right;        if ( node-&gt;parent == NULL ) {            node-&gt;left-&gt;parent = NULL;        } else if ( node == node-&gt;parent-&gt;left ) {            node-&gt;parent-&gt;left = node-&gt;left;            node-&gt;left-&gt;parent = node-&gt;parent;        } else {            node-&gt;parent-&gt;right = node-&gt;left;            node-&gt;left-&gt;parent = node-&gt;parent;        }        node-&gt;parent = node-&gt;left;        node-&gt;left-&gt;right = node;        node-&gt;left = p;        if ( p != NULL )            p-&gt;parent = node;        node-&gt;height = MAX( node_height(node-&gt;left),                            node_height(node-&gt;right) ) + 1;        node-&gt;parent-&gt;height = MAX( node_height(node-&gt;parent-&gt;right),                                    node_height(node-&gt;parent-&gt;left) ) + 1;        return node-&gt;parent;    }    return node;}avlTreeNode *tree_insert1(    avlTreeNode *root,    avlTreeNode *node ){    if ( root == NULL ) {        node-&gt;height = 1;        return node;    } else if ( node-&gt;key &lt; root-&gt;key ) {        root-&gt;left = tree_insert1( root-&gt;left, node );        root-&gt;left-&gt;parent = root;        if ( node_height( root-&gt;left ) - node_height( root-&gt;right ) == 2 ) {            if ( node-&gt;key &lt; root-&gt;left-&gt;key ) {                // right rotate;                root = right_rotate( root );            } else {                // left right rotate;                root-&gt;left = left_rotate( root-&gt;left );                root = right_rotate( root );            }        }        root-&gt;height = MAX( node_height(root-&gt;left), node_height(root-&gt;right) ) + 1;    } else {        root-&gt;right = tree_insert1( root-&gt;right, node );        root-&gt;right-&gt;parent = root;        if ( node_height( root-&gt;right ) - node_height( root-&gt;left ) == 2 ) {            if ( node-&gt;key &gt;= root-&gt;right-&gt;key ) {                root = left_rotate( root );            } else {                root-&gt;right = right_rotate( root-&gt;right );                root = left_rotate( root );            }        }        root-&gt;height = MAX( node_height(root-&gt;right), node_height(root-&gt;left) ) + 1;    }    return root;}void tree_insert(    avlTree *tree,    int key ){    avlTreeNode *node = tree_create_node( key, NULL, NULL, NULL );    if ( tree-&gt;root == NULL ) {        tree-&gt;root = node;    } else {        tree-&gt;root = tree_insert1( tree-&gt;root, node );    }}avlTreeNode *tree_delete1(    avlTreeNode *root,    int key ){    if ( root == NULL )        return NULL;    if ( key &lt; root-&gt;key ) {        root-&gt;left = tree_delete1( root-&gt;left, key );        if ( node_height(root-&gt;right) - node_height(root-&gt;left) == 2 ) {            if ( node_height(root-&gt;right-&gt;left) &gt; node_height(root-&gt;right-&gt;right) ) {                root-&gt;right = right_rotate( root-&gt;right );                root = left_rotate( root );            } else {                root = left_rotate( root );            }        }    } else if ( key &gt; root-&gt;key ) {        root-&gt;right = tree_delete1( root-&gt;right, key );        if ( node_height(root-&gt;left) - node_height(root-&gt;right) == 2 ) {            if ( node_height(root-&gt;left-&gt;right) &gt; node_height(root-&gt;left-&gt;left) ) {                root-&gt;left = left_rotate( root-&gt;left );                root = right_rotate( root );            } else {                root = right_rotate( root );            }        }    } else {        if ( root-&gt;left != NULL &amp;&amp; root-&gt;right != NULL ) {            avlTreeNode *replace = NULL;            // 这里做了替换后要删除最大值结点，但匹配无法确认同key值的不同结点            // ，因此树不能有相同key值的结点，但插入没有这个问题            if ( node_height(root-&gt;left) &gt; node_height(root-&gt;right) ) {                replace = tree_maximum( root-&gt;left );                root-&gt;key = replace-&gt;key;                root-&gt;left = tree_delete1( root-&gt;left, replace-&gt;key );            } else {                replace = tree_minimum( root-&gt;right );                root-&gt;key = replace-&gt;key;                root-&gt;right = tree_delete1( root-&gt;right, replace-&gt;key );            }        } else {            avlTreeNode *delete = root;            if ( root-&gt;left ) {                root-&gt;left-&gt;parent = root-&gt;parent;                root = delete-&gt;left;            } else if ( root-&gt;right ) {                root-&gt;right-&gt;parent = root-&gt;parent;                root = delete-&gt;right;            } else {                root = NULL;            }            free( delete );        }    }    if ( root != NULL )        root-&gt;height = MAX( node_height(root-&gt;left), node_height(root-&gt;right) ) + 1;    return root;}void tree_delete(    avlTree *tree,    int key ){    if ( tree-&gt;root != NULL ) {        tree-&gt;root = tree_delete1( tree-&gt;root, key );    }}void free_tree(    avlTree *tree ){    printf(&quot;\ndelete tree node...\n&quot;);    postorder_tree_free( tree-&gt;root );    tree-&gt;root = NULL;    printf(&quot;\ndelete tree...\n&quot;);    free( tree );    printf(&quot;free tree over!\n&quot;);}int main(    int argc,    char **argv ){    srand((int)time(NULL));    int i = 10;    int len = 20;    int arr[10] = {10,4,15,14,5, 2,8,13,1,19};    avlTree *tree = ( avlTree * )malloc( sizeof(avlTree) );    int delete_key_a, delete_key_b, delete_key_c;    for ( i = 0; i &lt; len; i++ ) {        //tree_insert( tree, arr[i] );        int randomnum = random_num();        if ( i == 2 )            delete_key_a = randomnum;        if ( i == 5 )            delete_key_b = randomnum;        if ( i == 9 )            delete_key_c = randomnum;        //printf(&quot;randon num:%d\n&quot;, randomnum);        tree_insert( tree, randomnum );    }    print_tree( tree );    check_is_avltree( tree-&gt;root );    printf(&quot;删除结点%d\n&quot;, delete_key_a);    tree_delete( tree, delete_key_a );    print_tree( tree );    check_is_avltree( tree-&gt;root );    tree_delete( tree, delete_key_b );    printf(&quot;删除结点%d\n&quot;, delete_key_b );    print_tree( tree );    check_is_avltree( tree-&gt;root );    tree_delete( tree, delete_key_c );    printf(&quot;删除结点%d\n&quot;, delete_key_c );    print_tree( tree );    check_is_avltree( tree-&gt;root );    printf(&quot;\n===========================================free================================================\n&quot;);    free_tree( tree );    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;（引用算法导论）AVL树是一种高度平衡的二叉搜索树：对每一个结点x，y的左子树与右子树的高度至多为1。AVL树相比二叉搜索树，每个结点维护一个额外的属性：结点的高度。&lt;/p&gt;
&lt;p&gt;AVL树实现了几个操作：&lt;/p&gt;
&lt;h1 id=&quot;树结点创建&quot;&gt;&lt;a href=&quot;#树结点创
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://lkness/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>红黑树-《算法导论》学习笔记十二</title>
    <link href="http://lkness/2018/06/19/023red-black-tree/index/"/>
    <id>http://lkness/2018/06/19/023red-black-tree/index/</id>
    <published>2018-06-19T12:38:53.000Z</published>
    <updated>2018-06-20T04:39:52.623Z</updated>
    
    <content type="html"><![CDATA[<p>红黑树是一种二叉搜索树，它在每个结点上增加了一个存储为来表示结点的颜色，或红或黑，通过从根到叶子的简单路径上各个结点的颜色进行约束，红黑树确保没有一条路径会比其它路径长出2倍，近似平衡的。</p><p>树种每个结点包含5个属性：color、key、left、right、parent，如果一个结点没有子结点或父结点，则该结点相应指针属性值指向空（这里的空不是空指针，而是定义一个空结点，结点颜色为黑色），一颗红黑树是满足几个特殊性质的二叉搜索树：</p><ul><li>每个结点或是红色的，或是黑色的</li><li>根结点是黑色的</li><li>每个叶结点（亦即空结点）为黑色的</li><li>如果一个结点是红色的，则它的两个子结点都是黑色的</li><li>对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点（经过的黑色结点数为黑高）</li></ul><p>与二叉搜索树相似，红黑树也有一些操作接口：</p><ul><li>遍历</li><li>寻找结点中序遍历的后继:tree_minimum</li><li>寻找结点中序遍历的前驱:tree_maximum</li><li>结点左右旋转（红黑树不同于二叉搜索树的操作），用来平衡黑高<ul><li>左旋：结点的父结点的左孩子指向结点的右孩子，右孩子的左孩子变为结点的右孩子，右孩子变为它的父结点</li><li>右旋：结点的父结点的右孩子指向结点的左孩子，做孩子的右孩子变为结点的左孩子，左孩子变为它的父结点*</li></ul></li><li>插入，插入一个新结点时，考虑如果插入黑色结点，破坏了原树的红黑性质（黑高），要进行重新平衡</li><li>删除，删除了一个结点后，考虑如果删除的是黑色结点，或删除了结点，后继提升到删除节点的位置后，平衡红黑性质</li></ul><p><strong>———-插入</strong></p><ol><li><p>如果结点的父结点为黑色，表示没插入这个结点前满足红黑树<br>性质，且插入这个红色结点后，也不影响红黑树黑高，故保持当前位置</p></li><li><p>如果结点的父结点为红色，那么判断插入结点与父结点，以及父结点的<br>父结点，叔结点，这四个结点是否组成一个倒立的”v”字形：</p><p> (1). 如果是倒立”v”，则插入结点的父结点为红色，破坏了红黑树的：红<br>色结点的左右孩子都为黑色的性质，故父结点一定要变为黑色;<br>那么将父结点变为黑色;</p><p> 判断叔结点若为红色，则将叔结点变为黑色，父结点的父结点变为红色，<br>插入结点的指针指向父结点的父结点，再次从步骤1判断（因为经过变换，<br>从插入结点的父结点的父结点开始的子数都满足红黑树性质，只需要将<br>父结点的父结点单独当作一个新插入它的父结点的子结点再进行处理即可）;</p><p> 否则叔结点为黑色，则直接将父结点的父结点变为红色，但是这样做之后，<br>父结点因为变为黑色，而叔结点还是黑色，两个子树路径的黑高相差1,要<br>维持黑高相等，则将父结点的父结点的父结点向叔结点相同的方向旋转（<br>可以针对这种情况画图，会发现这样旋转后，两个黑高不一样的子树分开了，<br>，且满足红黑树性质）。</p><p> (2). 如果不是倒立”v”，即插入结点的父结点所处子树为某方向上的子树，但插入<br>结点又是父结点另一方的孩子结点，则只需要进行一下旋转，就将结点变为<br>倒立的”v”形状，继续从步骤1开始作为倒立”v”子树判断。</p></li><li><p>将根结点变为黑色</p></li></ol><p><strong>———-删除</strong></p><ol><li><p>以指针p指向待删除结点node，p_color记录node颜色</p></li><li><p>判断node的左右孩子<br> (1). 如果左孩子为空<br>寻找node的右孩子，记为q（不管是否指向空）<br>用q结点替换node结点</p><p> (2). 但如果右孩子为空<br>寻找node的左孩子，记为q（不管是否指向空）<br>用q结点替换node结点</p><p> (3). 否则左右孩子都不为空<br>寻找node的中序遍历后继(tree_minimum())，p指向它;</p><p> p_color记录后继的颜色;</p><p> q指向p的右结点（不管是否为空）;</p><p> 判断p的父结点是否为node:是，则， q的父结点设为p（只有当q为空结点时有用）/否，则，用p的右结点替换p(rb_transplant(tree, p, p-&gt;right))，用p结点接管node结点右子树（p-&gt;right = node-&gt;right, p-&gt;right-&gt;parent = p）;</p><p> 用p结点替换node结点(rb_transplant(tree, node, p));</p><p> p结点接管node结点左子树(p-&gt;left = node-&gt;left,p-&gt;left-&gt;parent = p);</p><p> p结点的颜色设置为node结点的颜色</p></li><li><p>判断p_color的颜色如果为黑色，表示删除结点后，黑高可能-1,<br>要修复红黑树，从结点q处开始修复红黑树，根据q的颜色来修复</p></li><li><p>循环.直到q结点不为根结点以及p结点的颜色不为黑色</p><p> (1). 如果node的兄弟结点为红色<br>（因为node结点替换了删除结点，黑高-1,与兄弟结点子树黑高差1）<br>设置兄弟结点为黑色，父结点设置为红色，从父结点开始向node一侧旋转，兄弟结点成为新的子树根结点，因为兄弟结点为黑色，则经过兄弟结点到node结点的子树黑高+1,平衡，但对于兄弟结点的父结点的子树，黑高又可能不平衡，node指针指向兄弟结点，继续步骤4</p><p> (2). 如果node的兄弟结点为黑色，且兄弟结点的左右孩子均为黑色<br>（因为node结点替换了删除结点，黑高-1,与兄弟结点子树黑高差1）<br>设置兄弟结点颜色为红色，兄弟结点子树黑高-1,达到平衡，但父结点以上的子树可能受影响，node指针指向父结点，继续步骤4</p><p> (3). 如果node的兄弟结点为黑色，且兄弟结点的靠近node一侧的孩子结点颜色为红色，另一侧的孩子结点为黑色<br>（因为node结点替换了删除结点，黑高-1,与兄弟结点子树黑高差1）<br>兄弟结点靠近node一侧的孩子结点设置为黑色，兄弟结点设置为红色，从兄弟结点开始进行向远离node一侧旋转，兄弟结点的孩子结点成为它的父结点，原兄弟结点的左右子树黑高不变，但node结点所处子树因为替换删除结点，黑高-1，还是没有平衡，node指针指向新的兄弟结点的孩子结点，继续4</p><p> (4). 如果node的兄弟结点为黑色，且兄弟结点的远离node一侧的孩子结点颜色为红色，另一侧颜色未知<br>（因为node结点替换了删除结点，黑高-1,与兄弟结点子树黑高差1）<br>兄弟结点设置为node父结点的颜色，父结点设置为黑色，兄弟结点为红色的设置为黑色，然后从node父结点开始进行向node一侧旋转，旋转前，可以思考，父结点若为红色，旋转后不改变子树黑高，若父结点为黑色，旋转后也不会改变黑高经过一轮变换后，node结点的父结点的父结点左右子树黑高一样，且经过node替换后-1的黑高，因为变换，又+1,本子树在整个红黑树中没有破坏黑高一致性，故将node指针指向整个树的根结点，跳出循环<br>设置node指针的结点颜色为黑色</p></li></ol><p>代码：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;//#define COLOR_RED   1;//#define COLOR_BLACK 2;typedef enum color {    COLOR_RED,    COLOR_BLACK}color;typedef struct rbTreeNode {    int key;    color color;    struct rbTreeNode *parent;    struct rbTreeNode *left;    struct rbTreeNode *right;}rbTreeNode;typedef struct rbTree {    int node_num;    int height;    rbTreeNode *root;    rbTreeNode *null;}rbTree;void print_tree( rbTree * );rbTreeNode *tree_minimum(    rbTreeNode *root,    rbTreeNode *null ){    while ( root-&gt;left != null ) {        root = root-&gt;left;    }    return root;}rbTreeNode *tree_maximum(    rbTreeNode *root,    rbTreeNode *null ){    while ( root-&gt;right != null ) {        root = root-&gt;right;    }    return root;}void left_rotate(    rbTree *tree,    rbTreeNode *node ){    rbTreeNode *p = node-&gt;right;    node-&gt;right = p-&gt;left;    if ( p-&gt;left != tree-&gt;null )        p-&gt;left-&gt;parent = node;    p-&gt;parent = node-&gt;parent;    if ( node-&gt;parent == tree-&gt;null )        tree-&gt;root = p;    else if ( node == node-&gt;parent-&gt;left )        node-&gt;parent-&gt;left = p;    else        node-&gt;parent-&gt;right = p;    p-&gt;left = node;    node-&gt;parent = p;}void right_rotate(    rbTree *tree,    rbTreeNode *node ){    rbTreeNode *p = node-&gt;left;    node-&gt;left = p-&gt;right;    if ( p-&gt;right != tree-&gt;null )        p-&gt;right-&gt;parent = node;    p-&gt;parent = node-&gt;parent;    if ( node-&gt;parent == tree-&gt;null )        tree-&gt;root = p;    else if ( node == node-&gt;parent-&gt;right )        node-&gt;parent-&gt;right = p;    else        node-&gt;parent-&gt;left = p;    p-&gt;right = node;    node-&gt;parent = p;}void rb_insert_fixup(    rbTree *tree,    rbTreeNode *node ){    rbTreeNode *p = tree-&gt;null;    while ( node-&gt;parent-&gt;color == COLOR_RED ) {        if ( node-&gt;parent == node-&gt;parent-&gt;parent-&gt;left ) {            p = node-&gt;parent-&gt;parent-&gt;right;            if ( p-&gt;color == COLOR_RED ) {                node-&gt;parent-&gt;color = COLOR_BLACK;                p-&gt;color = COLOR_BLACK;                node-&gt;parent-&gt;parent-&gt;color = COLOR_RED;                node = node-&gt;parent-&gt;parent;            } else if ( node == node-&gt;parent-&gt;right ) {                node = node-&gt;parent;                left_rotate( tree, node );            } else {                node-&gt;parent-&gt;color = COLOR_BLACK;                node-&gt;parent-&gt;parent-&gt;color = COLOR_RED;                right_rotate( tree, node-&gt;parent-&gt;parent );            }        } else {            p = node-&gt;parent-&gt;parent-&gt;left;            if ( p-&gt;color == COLOR_RED ) {                node-&gt;parent-&gt;color = COLOR_BLACK;                p-&gt;color = COLOR_BLACK;                node-&gt;parent-&gt;parent-&gt;color = COLOR_RED;                node = node-&gt;parent-&gt;parent;            } else if ( node == node-&gt;parent-&gt;left ) {                node = node-&gt;parent;                right_rotate( tree, node );            } else {                node-&gt;parent-&gt;color = COLOR_BLACK;                node-&gt;parent-&gt;parent-&gt;color = COLOR_RED;                left_rotate( tree, node-&gt;parent-&gt;parent );            }        }    }    tree-&gt;root-&gt;color = COLOR_BLACK;}void rb_insert(    rbTree *tree,    rbTreeNode *node ){    rbTreeNode *p = tree-&gt;null;    rbTreeNode *q = tree-&gt;root;    while ( q != tree-&gt;null ) {        p = q;        if ( node-&gt;key &lt; q-&gt;key )            q = q-&gt;left;        else            q = q-&gt;right;    }    node-&gt;parent = p;    if ( p == tree-&gt;null )        tree-&gt;root = node;    else if ( node-&gt;key &lt; p-&gt;key )        p-&gt;left = node;    else        p-&gt;right = node;    node-&gt;left = tree-&gt;null;    node-&gt;right = tree-&gt;null;    node-&gt;color = COLOR_RED;    rb_insert_fixup( tree, node );}void rb_transplant(    rbTree *tree,    rbTreeNode *node_a,    rbTreeNode *node_b ){    if ( node_a-&gt;parent == tree-&gt;null )        tree-&gt;root = node_b;    else if ( node_a == node_a-&gt;parent-&gt;left )        node_a-&gt;parent-&gt;left = node_b;    else        node_a-&gt;parent-&gt;right = node_b;    node_b-&gt;parent = node_a-&gt;parent;    free( node_a );}void rb_delete_fixup(    rbTree *tree,    rbTreeNode *node ){    rbTreeNode *p = tree-&gt;null;    while ( node != tree-&gt;null &amp;&amp; node-&gt;color == COLOR_BLACK ) {        if ( node == node-&gt;parent-&gt;left ) {            p = node-&gt;parent-&gt;right;            if ( p-&gt;color == COLOR_RED ) {                p-&gt;color = COLOR_BLACK;                node-&gt;parent-&gt;color = COLOR_RED;                left_rotate( tree, node-&gt;parent );                p = node-&gt;parent-&gt;right;            } else if ( p-&gt;left-&gt;color == COLOR_BLACK                &amp;&amp; p-&gt;right-&gt;color == COLOR_BLACK ) {                p-&gt;color = COLOR_RED;                node = node-&gt;parent;            } else if ( p-&gt;right-&gt;color == COLOR_BLACK ) {                p-&gt;left-&gt;color = COLOR_BLACK;                p-&gt;color = COLOR_RED;                right_rotate( tree, p );                p = node-&gt;parent-&gt;right;            } else {                p-&gt;color = node-&gt;parent-&gt;color;                node-&gt;parent-&gt;color = COLOR_BLACK;                left_rotate( tree, node-&gt;parent );                node = tree-&gt;root;            }        } else {            p = node-&gt;parent-&gt;left;            if ( p-&gt;color == COLOR_RED ) {                p-&gt;color = COLOR_BLACK;                node-&gt;parent-&gt;color = COLOR_RED;                right_rotate( tree, node-&gt;parent );                p = node-&gt;parent-&gt;left;            } else if ( p-&gt;left-&gt;color == COLOR_BLACK                &amp;&amp; p-&gt;right-&gt;color == COLOR_BLACK ) {                p-&gt;color = COLOR_RED;                node = node-&gt;parent;            } else if ( p-&gt;left-&gt;color == COLOR_BLACK ) {                p-&gt;right-&gt;color = COLOR_BLACK;                p-&gt;color = COLOR_RED;                left_rotate( tree, p );                p = node-&gt;parent-&gt;left;            } else {                p-&gt;color = node-&gt;parent-&gt;color;                node-&gt;parent-&gt;color = COLOR_BLACK;                right_rotate( tree, node-&gt;parent );                node = tree-&gt;root;            }        }    }    node-&gt;color = COLOR_BLACK;}void rb_delete(    rbTree *tree,    rbTreeNode *node ){    rbTreeNode *p = node;    rbTreeNode *q = tree-&gt;null;    color origin_color = p-&gt;color;    if ( node-&gt;left == tree-&gt;null ) {        q = node-&gt;right;        rb_transplant( tree, node, node-&gt;right );    } else if ( node-&gt;right == tree-&gt;null ) {        q = node-&gt;left;        rb_transplant( tree, node, node-&gt;left );    } else {        p = tree_minimum( node-&gt;right, tree-&gt;null );        origin_color = p-&gt;color;        q = p-&gt;right;        if ( p-&gt;parent == node )            q-&gt;parent = p;        else {            rb_transplant( tree, p, p-&gt;right );            p-&gt;right = node-&gt;right;            p-&gt;right-&gt;parent = p;        }        rb_transplant( tree, node, p );        p-&gt;left = node-&gt;left;        p-&gt;left-&gt;parent = p;        p-&gt;color = node-&gt;color;    }    if ( origin_color == COLOR_BLACK )        rb_delete_fixup( tree, q );}int random_num(){    int a = 1;    int b = 100;    return rand() % ( b - a ) + a;}void postorder_tree_free(    rbTreeNode *root,    rbTreeNode *null ){    if ( root != null ) {        postorder_tree_free( root-&gt;left, null );        postorder_tree_free( root-&gt;right, null );        free( root );    }}void inorder_tree_walk(    rbTreeNode *root,    rbTreeNode *null ){    if ( root != null ) {        inorder_tree_walk( root-&gt;left, null );        printf(&quot;%d(%d) &quot;, root-&gt;key, root-&gt;color);        inorder_tree_walk( root-&gt;right, null );    }}void preorder_tree_walk(    rbTreeNode *root,    rbTreeNode *null ){    if ( root != null ) {        printf(&quot;%d(%d) &quot;, root-&gt;key, root-&gt;color);        preorder_tree_walk( root-&gt;left, null );        preorder_tree_walk( root-&gt;right, null );    }}void postorder_tree_walk(    rbTreeNode *root,    rbTreeNode *null ){    if ( root != null ) {        postorder_tree_walk( root-&gt;left, null );        postorder_tree_walk( root-&gt;right, null );        printf(&quot;%d(%d) &quot;, root-&gt;key, root-&gt;color);    }}void print_tree(    rbTree *tree ){    printf(&quot;中序:&quot;);    inorder_tree_walk( tree-&gt;root, tree-&gt;null );    printf(&quot;\n&quot;);    printf(&quot;前序:&quot;);    preorder_tree_walk( tree-&gt;root, tree-&gt;null );    printf(&quot;\n&quot;);    printf(&quot;后序:&quot;);    postorder_tree_walk( tree-&gt;root, tree-&gt;null );    printf(&quot;\n\n&quot;);}rbTreeNode *tree_search_recursion(    rbTreeNode *root,    int key,    rbTreeNode *null){    if ( root == null || key == root-&gt;key ) {        return root;    }    if ( key &lt; root-&gt;key )        return tree_search_recursion( root-&gt;left, key, null );    else        return tree_search_recursion( root-&gt;right, key, null );}rbTreeNode *tree_search(    rbTreeNode *root,    int key,    rbTreeNode *null ){    while ( root != null &amp;&amp; key != root-&gt;key ) {        if ( key &lt; root-&gt;key )            root = root-&gt;left;        else            root = root-&gt;right;    }    return root;}// 找前驱 即中序遍历的前一个位置值rbTreeNode *tree_predecessor(    rbTreeNode *node,    rbTreeNode *null ){    if ( node-&gt;left != null )        return tree_maximum( node-&gt;left, null );    rbTreeNode *p = node-&gt;parent;    while ( p != null &amp;&amp; node == p-&gt;left ) {        node = p;        p = p-&gt;parent;    }    return p;}// 找后继 即中序遍历的后一个位置值rbTreeNode *tree_successor(    rbTreeNode *node,    rbTreeNode *null ){    if ( node-&gt;right != null )        return tree_minimum( node-&gt;right, null );    rbTreeNode *p = node-&gt;parent;    while ( p != null &amp;&amp; node == p-&gt;right ) {        node = p;        p = p-&gt;parent;    }    return p;}void free_tree(    rbTree *tree ){    rbTreeNode *root = tree-&gt;root;    postorder_tree_free( root, tree-&gt;null );    free( tree );}int main(    int argc,    char **argv ){    srand((int)time(NULL));    int i = 10;    int len = 10;    int arr[10] = {10,4,15,14,5, 2,8,13,1,19};    rbTree *tree = ( rbTree * )malloc( sizeof(rbTree) );    tree-&gt;node_num = 0;    tree-&gt;height = 0;    tree-&gt;null = ( rbTreeNode * )malloc( sizeof(rbTreeNode) );    tree-&gt;null-&gt;color = COLOR_BLACK;    tree-&gt;root = tree-&gt;null;    for ( i = 0; i &lt; len; i++ ) {        rbTreeNode *node =            ( rbTreeNode * )malloc( sizeof(rbTreeNode) );        //node-&gt;key = random_num();        node-&gt;key = arr[i];        node-&gt;parent = tree-&gt;null;        node-&gt;left = tree-&gt;null;        node-&gt;right = tree-&gt;null;        rb_insert( tree, node );        printf(&quot;insert %d successfully\n&quot;, arr[i]);    }    print_tree( tree );    rbTreeNode *delete_node = tree_search( tree-&gt;root, 4, tree-&gt;null );    if ( delete_node != tree-&gt;null ) {        rb_delete( tree, delete_node );    }    printf(&quot;\n删除%d的节点后遍历顺序为:\n&quot;, 4);    print_tree( tree );    printf(&quot;\n&quot;);    delete_node = tree_search( tree-&gt;root, 15, tree-&gt;null );    if ( delete_node != tree-&gt;null ) {        rb_delete( tree, delete_node );    }    printf(&quot;\n删除%d的节点后中序遍历顺序为:\n&quot;, 15);    print_tree( tree );    printf(&quot;\n&quot;);    free_tree( tree );    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;红黑树是一种二叉搜索树，它在每个结点上增加了一个存储为来表示结点的颜色，或红或黑，通过从根到叶子的简单路径上各个结点的颜色进行约束，红黑树确保没有一条路径会比其它路径长出2倍，近似平衡的。&lt;/p&gt;
&lt;p&gt;树种每个结点包含5个属性：color、key、left、right、p
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://lkness/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树-《算法导论》学习笔记十一</title>
    <link href="http://lkness/2018/06/19/022bin-search-tree/index/"/>
    <id>http://lkness/2018/06/19/022bin-search-tree/index/</id>
    <published>2018-06-19T12:36:13.000Z</published>
    <updated>2018-06-19T12:38:27.885Z</updated>
    
    <content type="html"><![CDATA[<p>二叉搜索树是以一颗二叉树来组织的，每个节点除数据外，还包括三个分别指向父结点、左孩子、右孩子的指针，二叉搜索树有个特性：某个结点root的左子树的某个节点x的关键值小于等于root结点右子树某个结点y的关键值。</p><p>二叉搜索树有几个操作：</p><p><strong>1、查找</strong></p><p>查找与给定关键值相等的结点</p><p><strong>2、遍历</strong></p><p>前序、中序、后序遍历输出</p><p><strong>3、从某结点出发，寻找子树中最小关键值的结点</strong></p><p><strong>4、从某结点出发，寻找子树中最大关键值的结点</strong></p><p><strong>5、以某种遍历方式的次数，寻找某结点的前驱结点和后继结点</strong></p><p>例如中序遍历的顺序为123456，则4结点的前驱为3，后继为5</p><p><strong>6、插入结点</strong></p><p><strong>7、删除结点</strong></p><p>删除某个结点后，要把它的后继结点补在删除的位置上，要注意：</p><ul><li>如果结点没有孩子结点，那么只是简单地将它删除，并删改它的父结点的孩子指针指向它</li><li><p>如果结点只有一个孩子，那么将它孩子提升到它的位置，并修改它的父结点的孩子指针指向它</p></li><li><p>如果节点有两个孩子，那么寻找它的后继（按中序遍历来说一定在右子树），并让后继占据它的位置，后继（按中序遍历来说一定没有左子树）的子树提升到后继的位置</p></li><li><p>情况如上，具体删除时如何替换，又有不同情况：</p></li><li><p>如果结点只有左或孩子，用孩子替换结点</p></li><li>如果结点有左右两个孩子，那么要查找结点的后继：(1)、如果后继是结点的右孩子，用后继替换结点，并留下后继的右孩子；(2)、后继位于结点的右子树，但并不是结点的右孩子，则，先用后继的右孩子替换后继，再用后继替换结点</li></ul><p>代码：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;typedef struct biSearchTreeNode {    int key;    struct biSearchTreeNode *parent;    struct biSearchTreeNode *left;    struct biSearchTreeNode *right;}biSearchTreeNode;typedef struct biSearchTree {    int node_num;    int height;    biSearchTreeNode *root;}biSearchTree;int random_num(){    int a = 1;    int b = 100;    return rand() % ( b - a ) + a;}void postorder_tree_free(    biSearchTreeNode *root ){    if ( root != NULL ) {        postorder_tree_free( root-&gt;left );        postorder_tree_free( root-&gt;right );        free( root );    }}void inorder_tree_walk(    biSearchTreeNode *root ){    if ( root != NULL ) {        inorder_tree_walk( root-&gt;left );        printf(&quot;%d &quot;, root-&gt;key);        inorder_tree_walk( root-&gt;right );    }}void preorder_tree_walk(    biSearchTreeNode *root ){    if ( root != NULL ) {        printf(&quot;%d &quot;, root-&gt;key);        preorder_tree_walk( root-&gt;left );        preorder_tree_walk( root-&gt;right );    }}void postorder_tree_walk(    biSearchTreeNode *root ){    if ( root != NULL ) {        postorder_tree_walk( root-&gt;left );        postorder_tree_walk( root-&gt;right );        printf(&quot;%d &quot;, root-&gt;key);    }}void print_tree(    biSearchTree *tree ){    printf(&quot;中序:&quot;);    inorder_tree_walk( tree-&gt;root );    printf(&quot;\n&quot;);    printf(&quot;前序:&quot;);    preorder_tree_walk( tree-&gt;root );    printf(&quot;\n&quot;);    printf(&quot;后序:&quot;);    postorder_tree_walk( tree-&gt;root );    printf(&quot;\n\n&quot;);}biSearchTreeNode *tree_search_recursion(    biSearchTreeNode *root,    int key ){    if ( root == NULL || key == root-&gt;key ) {        return root;    }    if ( key &lt; root-&gt;key )        return tree_search_recursion( root-&gt;left, key );    else        return tree_search_recursion( root-&gt;right, key );}biSearchTreeNode *tree_search(    biSearchTreeNode *root,    int key ){    while ( root != NULL &amp;&amp; key != root-&gt;key ) {        if ( key &lt; root-&gt;key )            root = root-&gt;left;        else            root = root-&gt;right;    }    return root;}biSearchTreeNode *tree_minimum(    biSearchTreeNode *root ){    while ( root-&gt;left != NULL ) {        root = root-&gt;left;    }    return root;}biSearchTreeNode *tree_maximum(    biSearchTreeNode *root ){    while ( root-&gt;right != NULL ) {        root = root-&gt;right;    }    return root;}// 找前驱 即中序遍历的前一个位置值biSearchTreeNode *tree_predecessor(    biSearchTreeNode *node ){    if ( node-&gt;left != NULL )        return tree_maximum( node-&gt;left );    biSearchTreeNode *p = node-&gt;parent;    while ( p != NULL &amp;&amp; node == p-&gt;left ) {        node = p;        p = p-&gt;parent;    }    return p;}// 找后继 即中序遍历的后一个位置值biSearchTreeNode *tree_successor(    biSearchTreeNode *node ){    if ( node-&gt;right != NULL )        return tree_minimum( node-&gt;right );    biSearchTreeNode *p = node-&gt;parent;    while ( p != NULL &amp;&amp; node == p-&gt;right ) {        node = p;        p = p-&gt;parent;    }    return p;}void tree_insert(    biSearchTree *tree,    biSearchTreeNode *node ){    biSearchTreeNode *root = tree-&gt;root;    biSearchTreeNode *p = NULL;    biSearchTreeNode *q = root;    while ( q != NULL ) {        p = q;        if ( node-&gt;key &lt; q-&gt;key )            q = q-&gt;left;        else            q = q-&gt;right;    }    node-&gt;parent = p;    if ( p == NULL ) {        tree-&gt;root = node;    }    else if ( node-&gt;key &lt; p-&gt;key )        p-&gt;left = node;    else        p-&gt;right = node;}void transplant(    biSearchTree *tree,    biSearchTreeNode *node_a,    biSearchTreeNode *node_b ){    if ( node_a-&gt;parent == NULL )        tree-&gt;root = node_b;    else if ( node_a == node_a-&gt;parent-&gt;left )        node_a-&gt;parent-&gt;left = node_b;    else        node_a-&gt;parent-&gt;right = node_b;    if ( node_b != NULL )        node_b-&gt;parent = node_a-&gt;parent;}void tree_delete(    biSearchTree *tree,    biSearchTreeNode *node ){    if ( node-&gt;left == NULL )        transplant( tree, node, node-&gt;right );    else if ( node-&gt;right == NULL )        transplant( tree, node, node-&gt;left );    else {        biSearchTreeNode *p = tree_minimum( node-&gt;right );        if ( p-&gt;parent != node ) {            transplant( tree, p, p-&gt;right );            p-&gt;right = node-&gt;right;            p-&gt;right-&gt;parent = p;        }        transplant( tree, node, p );        p-&gt;left = node-&gt;left;        p-&gt;left-&gt;parent = p;    }    free( node );}void free_tree(    biSearchTree *tree ){    biSearchTreeNode *root = tree-&gt;root;    postorder_tree_free( root );    free( tree );}int main(    int argc,    char **argv ){    srand((int)time(NULL));    int i = 10;    int len = 10;    int arr[10] = {10,4,15,14,5, 2,8,13,1,19};    biSearchTree *tree = ( biSearchTree * )malloc( sizeof(biSearchTree) );    tree-&gt;node_num = 0;    tree-&gt;height = 0;    for ( i = 0; i &lt; len; i++ ) {        biSearchTreeNode *node =            ( biSearchTreeNode * )malloc( sizeof(biSearchTreeNode) );        //node-&gt;key = random_num();        node-&gt;key = arr[i];        node-&gt;parent = NULL;        node-&gt;left = NULL;        node-&gt;right = NULL;        tree_insert( tree, node );    }    print_tree( tree );    for ( i = 0; i &lt; len; i++ ) {        biSearchTreeNode *pre = tree_predecessor( tree_search(tree-&gt;root, arr[i]) );        biSearchTreeNode *post = tree_successor( tree_search(tree-&gt;root, arr[i]) );        printf(&quot;\n&quot;);        if ( pre != NULL )            printf(&quot;查找%d的中序遍历前驱为:%d\n&quot;, arr[i], pre-&gt;key);        else            printf(&quot;查找%d的中序遍历前驱为空！\n&quot;, arr[i]);        if ( post != NULL )            printf(&quot;查找%d的中序遍历后继为:%d\n&quot;, arr[i], post-&gt;key);        else            printf(&quot;查找%d的中序遍历后继为空！\n&quot;, arr[i]);    }    biSearchTreeNode *delete_node = tree_search( tree-&gt;root, 4 );    if ( delete_node != NULL ) {        tree_delete( tree, delete_node );    }    printf(&quot;\n删除%d的节点后中序遍历顺序为:&quot;, 4);    inorder_tree_walk( tree-&gt;root );    printf(&quot;\n&quot;);    delete_node = tree_search( tree-&gt;root, 15 );    if ( delete_node != NULL ) {        tree_delete( tree, delete_node );    }    printf(&quot;\n删除%d的节点后中序遍历顺序为:&quot;, 15);    inorder_tree_walk( tree-&gt;root );    printf(&quot;\n&quot;);    free_tree( tree );    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;二叉搜索树是以一颗二叉树来组织的，每个节点除数据外，还包括三个分别指向父结点、左孩子、右孩子的指针，二叉搜索树有个特性：某个结点root的左子树的某个节点x的关键值小于等于root结点右子树某个结点y的关键值。&lt;/p&gt;
&lt;p&gt;二叉搜索树有几个操作：&lt;/p&gt;
&lt;p&gt;&lt;stro
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://lkness/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>查找数组第i小的数-《算法导论》学习笔记十</title>
    <link href="http://lkness/2018/06/19/021search-min-i/index/"/>
    <id>http://lkness/2018/06/19/021search-min-i/index/</id>
    <published>2018-06-19T12:32:13.000Z</published>
    <updated>2018-06-19T12:35:17.286Z</updated>
    
    <content type="html"><![CDATA[<p>查找第i小的数利用了快速排序的一点思想，即以数组某个值作为比较值，然后遍历数组中除这个数以外的数，小于它的就放左边，大于它的放右边，然后作为比较值的数放中间，并返回比较值的下标，如果下标等于i，表示就找到了，如果下标大于i，又再次从大于此下标的数组递归进行此过程，同理，小于i就从小于此下标的数组递归进行此过程，代码：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int partition( int *arr, int p, int r ){    int x = arr[r];    int i = p - 1;    int j = 0;    int temp = 0;    for ( j = p; j &lt; r; j++ ) {        if ( arr[j] &lt;= x ) {            i += 1;            temp = arr[i];            arr[i] = arr[j];            arr[j] = temp;        }    }    temp = arr[i + 1];    arr[i + 1] = arr[r];    arr[r] = temp;    return i + 1;}int randomized_partition( int *arr, int p, int r ){    int i = rand() % (r - p) + p;    int temp = arr[r];    arr[r] = arr[i];    arr[i] = temp;    return partition( arr, p, r );}int randomized_select(    int *arr,    int p,    int r,    int i ){    if ( p == r )        return arr[p];    int q = 0, k = 0;    q = randomized_partition( arr, p, r );    k = q - p + 1;    if ( i == k )        return arr[q];    else if ( i &lt; k )        return randomized_select( arr, p, q - 1, i );    else        return randomized_select( arr, q + 1, r, i - k );}int main(){    int arr[10] = {1,2,3,4,5,6,7,8,9,10};    int len = 10;    int i = 8;    printf(&quot;第%d小的数是:%d\n&quot;, i, randomized_select(arr, 0, 9, i));    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;查找第i小的数利用了快速排序的一点思想，即以数组某个值作为比较值，然后遍历数组中除这个数以外的数，小于它的就放左边，大于它的放右边，然后作为比较值的数放中间，并返回比较值的下标，如果下标等于i，表示就找到了，如果下标大于i，又再次从大于此下标的数组递归进行此过程，同理，小于
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://lkness/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>桶排序-《算法导论》学习笔记九</title>
    <link href="http://lkness/2018/06/19/020bucket-sort/index/"/>
    <id>http://lkness/2018/06/19/020bucket-sort/index/</id>
    <published>2018-06-19T12:28:14.000Z</published>
    <updated>2018-06-19T12:29:00.827Z</updated>
    
    <content type="html"><![CDATA[<p>桶排序要求数据均匀、独立分布在某个区间上，然后将待排序值按某个区间划分为几个区间数组，然后将待排序的数按这个区间划分公式有序放入对应桶中，这样放完之后再按顺序从桶中拿出来一个一个放入原数组。<br>c代码桶可以用链表，如待排序数组的值为0-99，那么桶可以划分为0-9、10-19、20-29…..，这样就得到了10个桶数组链表，然后遍历待排序的数组，将值/10后以链表插入排序方式放入对应桶链表中（就像打扑克一样从前往后遍历，能插入就插入），待所有数遍历完后，就得到了桶数据了，然后再排序0-9的桶，每个桶做链表遍历取数据，直接从数组0开始插入到待排序数组，代码：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;//#define DEBUGtypedef struct bucket_data {    int no;    struct bucket_data *next;} bucket_data;void sort_insert( bucket_data *, int );void bucket_sort( int *arr, int len ){    bucket_data *tmp_arr = ( bucket_data * )malloc( sizeof(bucket_data) * 10 );    int i = 0, count = 0;    //初始化链表头数组    for ( i = 0; i &lt; 10; i++ ) {        tmp_arr[i].next = NULL;    }    //遍历数据并有序插入到相应链表中    for ( i = 0; i &lt; len; i++ ) {        sort_insert( &amp;tmp_arr[arr[i] / 10], arr[i] );    }    //从链表中取数据到数组    count = 0;    for ( i = 0; i &lt; 10; i++ ) {        bucket_data *p = tmp_arr[i].next;        bucket_data *free_p = NULL;        #ifdef DEBUG            printf(&quot;bucket[%d]:\n&quot;, i);        #endif        while( p != NULL ) {        #ifdef DEBUG            printf(&quot;%d &quot;, p-&gt;no);        #endif            free_p = p;            arr[count] = p-&gt;no;            count++;            p = p-&gt;next;            free( free_p );        }        #ifdef DEBUG            printf(&quot;\n&quot;);        #endif    }    free( tmp_arr );}void sort_insert( bucket_data *head, int no ){    bucket_data *p = head;    bucket_data *data = ( bucket_data * )malloc( sizeof(bucket_data) );    data-&gt;no = no;    data-&gt;next = NULL;    while ( p != NULL &amp;&amp; p-&gt;next != NULL ) {        if ( p-&gt;next-&gt;no &gt;= no ) {            data-&gt;next = p-&gt;next;            p-&gt;next = data;            break;        }        p = p-&gt;next;    }    if ( p-&gt;next == NULL ) {        p-&gt;next = data;    }}void check_is_inc_arr(    int *arr,    int len ){    int i = 0;    for ( i = 0; i &lt; len; i++ ) {        if ( arr[i] &lt; arr[i - 1] ) {            printf(&quot;check_is_inc_arr fail.\n&quot;);            return;        }    }}//初始化随机数组void initArr( int *arr, int lowV,    int upV, int len ){    int i = 0;    int size = upV - lowV;    for ( i = 0; i &lt; len; i++ )    {        arr[i] = rand() % size + lowV;    }}void print_arr(    int *arr,    int len ){    int i = 0;    printf(&quot;\n=============================================\n&quot;);    for ( i = 0; i &lt; len; i++ ) {        printf(&quot;%d &quot;, arr[i]);    }    printf(&quot;\n=============================================\n&quot;);}int main(    int argc,    char **argv ){    if ( argc != 4 ) {        printf(&quot;input array length and the random value range.\n&quot;);        exit( 0 );    }    srand( (int)time(NULL) );    int length = atoi( argv[1] );    int lowV = atoi( argv[2] );    int upV = atoi( argv[3] );    int *arr = ( int * )malloc( sizeof(int) * (length) );    int i = 1000;    for ( ; i &gt; 0; i-- ) {        initArr( arr, lowV, upV, length );        //print_arr( arr, length );        bucket_sort( arr, length );        //print_arr( arr, length );        check_is_inc_arr( arr, length );    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;桶排序要求数据均匀、独立分布在某个区间上，然后将待排序值按某个区间划分为几个区间数组，然后将待排序的数按这个区间划分公式有序放入对应桶中，这样放完之后再按顺序从桶中拿出来一个一个放入原数组。&lt;br&gt;c代码桶可以用链表，如待排序数组的值为0-99，那么桶可以划分为0-9、10
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://lkness/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计数排序-《算法导论》学习笔记八</title>
    <link href="http://lkness/2018/06/19/019count-sort/index/"/>
    <id>http://lkness/2018/06/19/019count-sort/index/</id>
    <published>2018-06-19T12:27:08.000Z</published>
    <updated>2018-06-19T12:27:51.135Z</updated>
    
    <content type="html"><![CDATA[<p>计数排序：假设n个输入元素中的每一个都是在0-k区间内的一个整数(k为正整数)，对每一个输入元素x，确定小于x的元素个数，用一个0-k长度的数组做记录，例如输入数组的数为0-10长度，随机出[2,5,3,0,2,3,0,3]，可以计算出一个0-10的数组，分别表示小于等于x的数的个数，于是有：0-&gt;2,1-&gt;2,2-&gt;4,3-&gt;7,4-&gt;7,5-&gt;8,6-&gt;8,7-&gt;8,9-&gt;8,10-&gt;8，然后再倒序遍历待排序数组，根据值去0-10数组取索引，然后将数组值放入一个新的等长数组那个索引处，取过的索引值要减一，这是为了下次再取到相同值不会放在同一位置，代码：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;void counting_sort(    int *in_arr,    int *out_arr,    int arr_len,    int k ){    int *tmp_arr = ( int * )malloc( sizeof(int) * (k + 1) );    int i = 0, j = 0;    for ( i = 0; i &lt; k; i++ ) {        tmp_arr[i]  = 0;    }    for ( j = 0; j &lt; arr_len; j++ ) {        tmp_arr[in_arr[j]] = tmp_arr[in_arr[j]] + 1;    }    for ( i = 1; i &lt; k + 1; i++ ) {        tmp_arr[i] = tmp_arr[i] + tmp_arr[i - 1];    }    for ( j = arr_len - 1; j &gt;= 0; j-- ) {        //printf(&quot;j:%d, in_arr[j]:%d, tmp_arr[in_arr[j]]:%d\n&quot;,        //  j, in_arr[j], tmp_arr[in_arr[j]]);        out_arr[tmp_arr[in_arr[j]] - 1] = in_arr[j];        tmp_arr[in_arr[j]] = tmp_arr[in_arr[j]] - 1;    }    free( tmp_arr );}void check_is_inc_arr(    int *arr,    int len ){    int i = 0;    for ( i = 0; i &lt; len; i++ ) {        if ( arr[i] &lt; arr[i - 1] ) {            printf(&quot;check_is_inc_arr fail.\n&quot;);            return;        }    }}//初始化随机数组void initArr( int *arr, int lowV,    int upV, int len ){    int i = 0;    int size = upV - lowV;    for ( i = 0; i &lt; len; i++ )    {        arr[i] = rand() % size + lowV;    }}void print_arr(    int *arr,    int len ){    int i = 0;    printf(&quot;\n=============================================\n&quot;);    for ( i = 0; i &lt; len; i++ ) {        printf(&quot;%d &quot;, arr[i]);    }    printf(&quot;\n=============================================\n&quot;);}int main(    int argc,    char **argv ){    if ( argc != 4 ) {        printf(&quot;input array length and the random value range.\n&quot;);        exit( 0 );    }    srand( (int)time(NULL) );    int length = atoi( argv[1] );    int lowV = atoi( argv[2] );    int upV = atoi( argv[3] );    int *arr = ( int * )malloc( sizeof(int) * (length) );    int *new_arr = ( int * )malloc( sizeof(int) * length );    int i = 1000;    for ( ; i &gt; 0; i-- ) {        initArr( arr, lowV, upV, length );        //print_arr( arr, length );        counting_sort( arr, new_arr, length, upV );        //print_arr( new_arr, length );        check_is_inc_arr( new_arr, length );    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计数排序：假设n个输入元素中的每一个都是在0-k区间内的一个整数(k为正整数)，对每一个输入元素x，确定小于x的元素个数，用一个0-k长度的数组做记录，例如输入数组的数为0-10长度，随机出[2,5,3,0,2,3,0,3]，可以计算出一个0-10的数组，分别表示小于等于x
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://lkness/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>快速排序-《算法导论》学习笔记七</title>
    <link href="http://lkness/2018/06/19/018quick-sort/index/"/>
    <id>http://lkness/2018/06/19/018quick-sort/index/</id>
    <published>2018-06-19T12:24:39.000Z</published>
    <updated>2018-06-19T12:26:47.543Z</updated>
    
    <content type="html"><![CDATA[<p>快排利用分治的思想，将问题规模切分为小的子规模问题，类似归并排序，归并是将两个待排序的子数组合并为一个有序的数组，而快排是将数组以某个数组值划分为两个子数组，一个数组的所有数比这个值小，一个数组的所有数比这个值大，然后再递归地对两个子数组再以某个数组值做切分和交换：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;int partition( int *arr, int p, int r ){    int x = arr[r];    int i = p - 1;    int j = 0;    int temp = 0;    for ( j = p; j &lt; r; j++ ) {        if ( arr[j] &lt;= x ) {            i += 1;            temp = arr[i];            arr[i] = arr[j];            arr[j] = temp;        }    }    temp = arr[i + 1];    arr[i + 1] = arr[r];    arr[r] = temp;    return i + 1;}void quick_sort( int *arr, int p, int r ){    int q = 0;    if ( p &lt; r ) {        q = partition( arr, p, r );        //printf(&quot;p-&gt;%d, q-&gt;%d, r-&gt;%d\n&quot;, p, q, r);        quick_sort( arr, p, q - 1 );        quick_sort( arr, q + 1, r );    }}void check_is_inc_arr(    int *arr,    int len ){    int i = 0;    for ( i = 0; i &lt; len; i++ ) {        if ( arr[i] &lt; arr[i - 1] ) {            printf(&quot;check_is_inc_arr fail.\n&quot;);            return;        }    }}//初始化随机数组void initArr( int *arr, int lowV,    int upV, int len ){    int i = 0;    int size = upV - lowV;    for ( i = 0; i &lt; len; i++ )    {        arr[i] = rand() % size + lowV;    }}void print_arr(    int *arr,    int len ){    int i = 0;    printf(&quot;\n=============================================\n&quot;);    for ( i = 0; i &lt; len; i++ ) {        printf(&quot;%d &quot;, arr[i]);    }    printf(&quot;\n=============================================\n&quot;);}int main(    int argc,    char **argv ){    if ( argc != 4 ) {        printf(&quot;input array length and the random value range.\n&quot;);        exit( 0 );    }    srand( (int)time(NULL) );    int length = atoi( argv[1] );    int lowV = atoi( argv[2] );    int upV = atoi( argv[3] );    int *arr = ( int * )malloc( sizeof(int) * (length) );    initArr( arr, lowV, upV, length );    print_arr( arr, length );    quick_sort( arr, 0, length - 1 );    print_arr( arr, length );    check_is_inc_arr( arr, length );    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;快排利用分治的思想，将问题规模切分为小的子规模问题，类似归并排序，归并是将两个待排序的子数组合并为一个有序的数组，而快排是将数组以某个数组值划分为两个子数组，一个数组的所有数比这个值小，一个数组的所有数比这个值大，然后再递归地对两个子数组再以某个数组值做切分和交换：&lt;/p&gt;
      
    
    </summary>
    
      <category term="开发" scheme="http://lkness/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据结构/算法" scheme="http://lkness/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
