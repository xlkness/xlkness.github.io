<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>c半同步半异步进程池模型之cgi服务器 | My Blog | 我的小站</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="C/C++">
    <meta name="description" content="对半同步半异步进程池模型垂涎已久，这次中秋放假撸了下代码。 模型的简单介绍：主进程创建几个子进程作为工作进程，主进程监听客户端connect事件，一旦有连接事件，即通过round robin(简单轮询)选取一个子进程， 通过父子进程间的通信管道通知子进程有连接事件，子进程epoll监听到管道通信时间，即知道有客户端连接，因此进程accept，并将客户端连接套接字加入epoll监听事件，客户端浏览器">
<meta name="keywords" content="C&#x2F;C++">
<meta property="og:type" content="article">
<meta property="og:title" content="c半同步半异步进程池模型之cgi服务器">
<meta property="og:url" content="http://lkness/2018/06/15/009cgiserver/index/index.html">
<meta property="og:site_name" content="My Blog">
<meta property="og:description" content="对半同步半异步进程池模型垂涎已久，这次中秋放假撸了下代码。 模型的简单介绍：主进程创建几个子进程作为工作进程，主进程监听客户端connect事件，一旦有连接事件，即通过round robin(简单轮询)选取一个子进程， 通过父子进程间的通信管道通知子进程有连接事件，子进程epoll监听到管道通信时间，即知道有客户端连接，因此进程accept，并将客户端连接套接字加入epoll监听事件，客户端浏览器">
<meta property="og:locale" content="zh">
<meta property="og:updated_time" content="2018-06-19T02:02:56.131Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="c半同步半异步进程池模型之cgi服务器">
<meta name="twitter:description" content="对半同步半异步进程池模型垂涎已久，这次中秋放假撸了下代码。 模型的简单介绍：主进程创建几个子进程作为工作进程，主进程监听客户端connect事件，一旦有连接事件，即通过round robin(简单轮询)选取一个子进程， 通过父子进程间的通信管道通知子进程有连接事件，子进程epoll监听到管道通信时间，即知道有客户端连接，因此进程accept，并将客户端连接套接字加入epoll监听事件，客户端浏览器">
    
        <link rel="alternate" type="application/atom+xml" title="My Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/head.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">lkness</h5>
          <a href="mailto:906102152@qq.com" title="906102152@qq.com" class="mail">906102152@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/xlkness" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://www.weibo.com/2968846605" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">c半同步半异步进程池模型之cgi服务器</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">c半同步半异步进程池模型之cgi服务器</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-06-15T10:47:28.000Z" itemprop="datePublished" class="page-time">
  2018-06-15
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/开发/">开发</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    

<article id="post-009cgiserver/index"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">c半同步半异步进程池模型之cgi服务器</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-06-15 18:47:28" datetime="2018-06-15T10:47:28.000Z"  itemprop="datePublished">2018-06-15</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/开发/">开发</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>对半同步半异步进程池模型垂涎已久，这次中秋放假撸了下代码。</p>
<p>模型的简单介绍：主进程创建几个子进程作为工作进程，主进程监听客户端connect事件，一旦有连接事件，即通过round robin(简单轮询)选取一个子进程， 通过父子进程间的通信管道通知子进程有连接事件，子进程epoll监听到管道通信时间，即知道有客户端连接，因此进程accept，并将客户端连接套接字加入epoll监听事件，客户端浏览器发送get请求，客户端监听到请求事件，即调用封装好的客户端事件进行处理，本例子的客户端处理为recv客户的请求，从中提取文件名(now.cgi)，并重定向客户端连接套接字到stdout，然后执行对应cgi文件，cgi文件打印html页面字符串，因为重定向的缘故，打印的html字符串发送给客户端，客户端浏览器即显示了html页面。</p>
<p>代码写了几个模块，分别是：</p>
<p><code>util</code>：封装了套接字创建、unix族socket管道创建、中断信号、简单屏幕输出(可自行替换为日志文件输出)</p>
<p><code>epoll_wrapper</code>：封装了epoll相关操作包括创建epfd、添加epoll监听事件、删除epoll监听事件</p>
<p><code>myhshappool</code>(我的半同步半异步进程池 - -!…)：封装了进程池初始化、启动进程池进行事件监听</p>
<p><code>client_handle</code>：进程池监听到客户事件、即调用client_handle封装的处理事件，这里封装的是执行cgi文件向客户端浏览器返回服务器时间(最近在看unix网络编程，里面都是时间获取的服务器，借鉴下拿来搞事，当然，嵌入式里拿来控制个灯泡开关想来特别带劲，用android做个网页app，板子接wifi模块接智能灯，cgi负责开关灯泡 。。)</p>
<p><code>cgisrv</code>：入口，初始化进程池，启动进程池</p>
<p>代码快1k行，不知道一个博客文章能不能写下，这种玩具demo代码就不往github放了。代码中凑合写了注释(有时候不想切换中英文因此用了蹩脚的英文注释)，限(wo)于(tai)篇(lan)幅(le)没有写文件头注释和函数头注释。</p>
<p><code>util.h</code>：</p>
<pre><code>#ifndef _UTIL_H
#define _UTIL_H

#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;

//这里不用 #转字符串了，不方便管理等级
#ifdef LEVELNUMPRINT
    #define LEVEL0 &quot;LEVEL0&quot;
    #define LEVEL1 &quot;LEVEL1&quot;
    #define LEVEL2 &quot;LEVEL2&quot;
    #define LEVEL3 &quot;LEVEL3&quot;
    #define LEVEL4 &quot;LEVEL4&quot;
    #define LEVEL4 &quot;LEVEL5&quot;
#else
    #define LEVEL0  &quot;DEBUG&quot;
    #define LEVEL1  &quot;INFO&quot;
    #define LEVEL2  &quot;NOTICE&quot;
    #define LEVEL3  &quot;WARN&quot;
    #define LEVEL4  &quot;ERROR&quot;
    #define LEVEL5  &quot;FATAL&quot;
#endif

#define PRINTINFO( LEVEL, format, args... ) \
do { \
    printf(&quot;[%s]:(pid:%d)/(file:%s)/(func:%s)/(line:%d)&quot;, \
        LEVEL, getpid(), __FILE__, __func__, __LINE__); \
    /*printf(&quot;\t&quot; #LEVEL &quot;:&quot;);*/ \
    printf(&quot;--|--&quot;); \
    printf( format, ##args ); \
    printf(&quot;\n&quot;); \
} while( 0 )

#define PRINTINFO_ERR( LEVEL, format, args... ) \
do { \
    printf(&quot;[%s]:(pid:%d)/(file:%s)/(func:%s)/(line:%d)&quot;, \
        LEVEL, getpid(), __FILE__, __func__, __LINE__); \
    /*printf(&quot;\t&quot; #LEVEL &quot;:&quot;);*/ \
    printf(&quot;--|--&quot;); \
    printf( format, ##args ); \
    printf(&quot;(errmsg:%s)&quot;, strerror(errno)); \
    printf(&quot;\n&quot;); \
} while( 0 )


void Add_sig( int sig, void (*handler)(int),
    int restart_syscall );

void Socketpair( int *pairpipefd );

int Socket_create( char *ipaddr, int port );

void Setnonblocking( int fd );

#endif
</code></pre><p><code>util.c</code>:</p>
<pre><code>#include &quot;util.h&quot;


static int add_sig( int sig, void (*handler)(int),
    int restart_syscall )
{
    struct sigaction act;
    bzero( &amp;act, sizeof(act) );

    act.sa_handler = handler;
    act.sa_flags = 0;

    //早期unix系统对于进程在执行一个低速系统调用(如ioctl、
    //read、write、wait)而阻塞期间捕捉到一个信号，则系统
    //调用被中断不再执行，该系统调用返回错误，设置errno为
    //EINTR，随后的bsd系统引入了自动重启，即再次进行此系统
    //调用。unix衍生系统默认的方式可能为可选、总是等，类
    //unix系统的linux系统可能默认为不重启，因此添加重启标识
    if ( restart_syscall ) {
        act.sa_flags |= SA_RESTART;
    }

    //宏定义：
    //#define sigfillset(*p) (*p) = ~(0,0)
    sigfillset( &amp;act.sa_mask );

    if ( -1 == sigaction(sig, &amp;act, NULL) ) {
        PRINTINFO_ERR( LEVEL4, &quot;sigaction error&quot; );
        return -1;
    }

    return 0;
}
void Add_sig( int sig, void (*handler)(int),
    int restart_syscall )
{
    if ( add_sig(sig, handler, restart_syscall) &lt; 0 ) {
        PRINTINFO( LEVEL5, &quot;add_sig error&quot; );
        exit( 0 );
    }
}
void Socketpair( int *pairpipefd )
{
    int ret;

    ret = socketpair( PF_UNIX, SOCK_STREAM,
            0, pairpipefd );

    if ( ret &lt; 0 ) {
        PRINTINFO_ERR( LEVEL5, &quot;socketpair error!!&quot; );
        exit( 0 );
    }
}
static int socket_create( char *ipaddr, int port,
    int backlog )
{
    int sockfd;
    int ret;

    sockfd = socket( AF_INET, SOCK_STREAM, 0 );
    if ( sockfd &lt; 0 ) {
        PRINTINFO_ERR( LEVEL4, &quot;socket error!!!&quot; );
        return -1;
    }

    struct sockaddr_in addr;
    bzero( &amp;addr, sizeof(addr) ) ;

    addr.sin_family     = AF_INET;
    addr.sin_port       = htons( port );
    inet_pton( AF_INET, ipaddr, &amp;addr.sin_addr );

    int reuseaddr = 1;
    setsockopt( sockfd, SOL_SOCKET, SO_REUSEADDR,
        &amp;reuseaddr, sizeof(int) );

    ret = bind( sockfd, (struct sockaddr *)&amp;addr, (socklen_t)sizeof(addr) ) ;
    if ( ret &lt; 0 ) {
        PRINTINFO_ERR( LEVEL4, &quot;bind error!!!&quot; );
        return -1;
    }

    ret = listen( sockfd, backlog );
    if ( ret &lt; 0 ) {
        PRINTINFO_ERR( LEVEL4, &quot;listen error!!!&quot; );
        return -1;
    }

    return sockfd;
}
int Socket_create( char *ipaddr, int port )
{
    int ret;

    ret = socket_create( ipaddr, port, 5 );
    if ( ret &lt; 0 ) {
        PRINTINFO( LEVEL5, &quot;socket_creaet error!!!&quot; );
        exit( 0 );
    }

    return ret;
}
static int setnonblocking( int fd )
{
    int old_opt = fcntl( fd, F_GETFL );
    int new_opt = old_opt | O_NONBLOCK;

    fcntl( fd, F_SETFL, new_opt );

    return old_opt;
}
void Setnonblocking( int fd )
{
    setnonblocking( fd );
}
int Send ( int socket_fd, const unsigned char * send_buf,
    int buf_size, int flag )
{
    int snd_bytes = 0;
    int snd_total_bytes = 0;
    int snd_count = 3;

    while ( snd_count -- ) {
        snd_bytes = send( socket_fd, send_buf, buf_size, flag );
        if ( snd_bytes &lt;= 0 ) {
            if ( EAGAIN == errno || EINTR == errno
              || EWOULDBLOCK == errno ) { //暂时发送失败，需要重复发送
                usleep( 50 );
                continue;
            }else {  //连接不正常，返回-1交由上层清理此套接字
                PRINTINFO_ERR( LEVEL4, &quot;send return error!!!&quot; );
                return -1;
            }
        }
        snd_total_bytes += snd_bytes;
        if ( snd_total_bytes &gt;= buf_size ) {
            break;
        }
    }
    if ( !snd_count ) {
        PRINTINFO( LEVEL4, &quot;send timeout!!!&quot; );
        return -1;
    }
    return snd_total_bytes;
}
#if 0
int main()
{
    PRINTINFO( LEVEL0, &quot;likun:%d&quot;, 123 );
    PRINTINFO( LEVEL1, &quot;likun:&quot; );
    //PRINTINFO( likun, &quot;likun:&quot; );

    return 0;
}
#endif
</code></pre><p><code>epoll_wrapper.h</code>:</p>
<pre><code>#ifndef _EPOLL_WRAPPER_H
#define _EPOLL_WRAPPER_H

#include &lt;sys/epoll.h&gt;
#include &lt;stdlib.h&gt;

int Epoll_create( int size );

int Epoll_wait( int epfd, struct epoll_event *events,
        int maxevents, int timeout );

void Epoll_add_fd( int epfd, int fd );

void Epoll_del_fd( int epfd, int fd );

#endif
</code></pre><p><code>epoll_wrapper.c</code>:</p>
<pre><code>#include &quot;epoll_wrapper.h&quot;
#include &quot;util.h&quot;

static int epoll_create0( int size )
{
    int ret;
    ret = epoll_create( size );
    if ( ret &lt;= 0 ) {
        PRINTINFO_ERR( LEVEL3, &quot;epoll_create error!!!&quot; );
        return -1;
    }

    return ret;
}
int Epoll_create( int size )
{
    int ret;

    if ( (ret = epoll_create0(size)) &lt; 0 ) {
        PRINTINFO( LEVEL5, &quot;epoll_create0 error!!!&quot; );
        exit( 0 );
    }
    return ret;
}
int Epoll_wait( int epfd, struct epoll_event *events,
        int maxevents, int timeout )
{
    return epoll_wait( epfd, events, maxevents, timeout );
}
static int epoll_add_fd( int epfd, int fd )
{
    struct epoll_event event;
    event.data.fd = fd;
    event.events  = EPOLLIN | EPOLLET;

    epoll_ctl( epfd, EPOLL_CTL_ADD, fd, &amp;event );

    Setnonblocking( fd );

    return 0;
}
void Epoll_add_fd( int epfd, int fd )
{
    epoll_add_fd( epfd, fd );
}
void Epoll_del_fd( int epfd, int fd )
{
    epoll_ctl( epfd, EPOLL_CTL_DEL, fd, NULL );
}

#if 0
int main()
{}
#endif
</code></pre><p><code>myhshappool.h</code>:</p>
<pre><code>#ifndef _MY_HS_HA_P_POOL_H
#define _MY_HS_HA_P_POOL_H

#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/epoll.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;libgen.h&gt;

typedef struct process {
    //当前进程id号
    pid_t   pid;
    //与父进程通信用的管道
    //0端父进程写
    //1端子进程读
    int     pipefd[2];
} process;

typedef struct processpool {
    //进程池最大进程数
    int     max_process_num;
    //每个进程最大处理客户数量
    int     max_user_num;
    //epoll最多处理的事件数
    int     max_epoll_event;
    //当前进程池进程总数
    int     cur_process_num;
    //当前子进程在进程池序号，从0开始
    int     index;
    //每个进程一个epoll内核事件表
    int     epollfd;
    //监听socket
    int     listenfd;
    //停止线程池
    int     stop;
    //进程池子进程管理
    struct process *sub_process;
} processpool;

int init_process_pool( processpool *ppool, int maxpnum,
    int maxunum, int maxeevent, int curpnum, int listenfd );

void run( processpool *ppool );

#endif
</code></pre><p><code>myhshappool.c</code>:</p>
<pre><code>#include &quot;myhshappool.h&quot;
#include &quot;client_handle.h&quot;
#include &quot;util.h&quot;

//用于信号中断时主进程通信，
//统一处理事件，即将客户端连接
//事件、信号事件都统一用epoll
//监听处理，0端信号处理函数写，
//1端进程读
static int sig_pipefd[2];

static void sig_handler( int sig )
{
    //保存旧的errno，对后续的send不
    //进行错误判定，但send假如返回
    //失败会设置errno，信号中断调用
    //结束后影响进程其它模块判断
    int old_errno = errno;
    char signo     = (char)sig;
    send( sig_pipefd[0], (char *)&amp;signo, 1, 0 );
    errno = old_errno;
}
static void init_signal( processpool *ppool )
{
    Socketpair( sig_pipefd );

    Setnonblocking( sig_pipefd[0] );
    //Epoll_add_fd( ppool-&gt;epollfd, sig_pipefd[1] );

    Add_sig( SIGCHLD, sig_handler, 1 );
    Add_sig( SIGTERM, sig_handler, 1 );
    Add_sig( SIGINT,  sig_handler, 1 );
    Add_sig( SIGPIPE, SIG_IGN, 1 );
}

int init_process_pool( processpool *ppool, int maxpnum,
    int maxunum, int maxeevent, int curpnum, int listenfd )
{
    if ( !ppool ) {
        PRINTINFO( LEVEL4, &quot;ppool is null!!!&quot; );
        return -1;
    }

    ppool-&gt;max_process_num  = maxpnum;
    ppool-&gt;max_user_num     = maxunum;
    ppool-&gt;max_epoll_event  = maxeevent;
    ppool-&gt;cur_process_num  = curpnum;
    ppool-&gt;listenfd         = listenfd;
    // ppool-&gt;epollfd          = Epoll_create( 5 );
    ppool-&gt;index            = -1;
    ppool-&gt;stop             = 0;

    ppool-&gt;sub_process =
        (process *)calloc( sizeof(process), curpnum );
    if ( !ppool-&gt;sub_process ) {
        PRINTINFO( LEVEL4, &quot;sub_process calloc error!!!&quot; );
        return -1;
    }

    int i = 0;
    int pid;

    //先模拟一下进程池创建之前的情况，假设终端
    //bash shell进程id为1000，运行此程序进程id
    //为1001，其父进程为1000，fork之后主进程不
    //变，子进程id为1002，其父进程为1001，因此
    //明白fork的过程，下面可以走一下进程池创建
    //的流程（条件均为以上假设）：
    //第一次fork:创建亲缘进程的管道，父进程1001
    //，子进程1002，其父进程为1001，子进程不再
    //执行for循环，且主进程与1002子进程有单独通
    //信的管道
    //第二次fork:创建亲缘进程的管道，父进程1001
    //，子进程1003，其父进程为1001，子进程不再
    //执行for循环，且主进程与1003子进程有单独通
    //信的管道
    //第三次fork .....1004.....
    //    ........
    //通过以上过程，可以看到for循环次数为创建的
    //子进程数量，且每个子进程可以单独与父进程
    //通信
    //
    //这里进程创建，没有脱离当前终端的会话，
    //我觉得可以setsid()来摆脱终端影响
    for ( ; i &lt; curpnum; i++ ) {
        Socketpair( ppool-&gt;sub_process[i].pipefd );
        pid = fork();
        if ( pid &gt; 0 ) { //parent fork
            close( ppool-&gt;sub_process[i].pipefd[1] );
            ppool-&gt;sub_process[i].pid = pid;
            Setnonblocking( ppool-&gt;sub_process[i].pipefd[0] );
            continue;
        } else if ( pid == 0 ) { //child
            ppool-&gt;index = i;
            PRINTINFO( LEVEL0, &quot;child(%d):%d\tparent:%d&quot;, i + 1, getpid(), getppid() );
            close( ppool-&gt;sub_process[i].pipefd[0] );
            //每次只由父进程去创建进程
            break;
        }
        else {
            PRINTINFO( LEVEL5, &quot;fork error!!!&quot; );
            exit( 0 );
        }
    }
}
static int client_signal_handle( processpool *ppool,
    char *signals, int signals_num )
{
    int i = 0;
    for ( ; i &lt; signals_num; i++ ) {
        switch( signals[i] ) {
            case SIGCHLD:
            {
                PRINTINFO( LEVEL0, &quot;child receive a SIGCHLD signal&quot; );
                pid_t pid;
                int stat;
                //catch SIGCHLD
                while ( (pid = waitpid(-1, &amp;stat, WNOHANG)) &gt; 0 ) {
                    continue;
                }
                break;
            }
            case SIGTERM:
            {
                PRINTINFO( LEVEL0, &quot;child receive a SIGTERM signal&quot; );
                ppool-&gt;stop = 1;
                break;
            }
            case SIGINT:
            {
                PRINTINFO( LEVEL0, &quot;child receive a SIGINT signal&quot; );
                ppool-&gt;stop = 1;
                break;
            }
            default:
            {
                break;
            }
        }
    }
}
static void run_child( processpool *ppool )
{
    if ( !ppool ) {
        PRINTINFO( LEVEL4, &quot;ppool is null!!!&quot; );
        return;
    }

    init_signal( ppool );

    ppool-&gt;epollfd          = Epoll_create( 5 );

    PRINTINFO( LEVEL0, &quot;child cur process:%d&quot;, ppool-&gt;cur_process_num );
    int pipefd = ppool-&gt;sub_process[ppool-&gt;index].pipefd[1];

    Epoll_add_fd( ppool-&gt;epollfd, pipefd );
    Epoll_add_fd( ppool-&gt;epollfd, sig_pipefd[1] );

    struct epoll_event *events = (struct epoll_event *)
        calloc( sizeof(struct epoll_event), ppool-&gt;max_epoll_event );
    if ( !events ) {
        PRINTINFO( LEVEL5, &quot;calloc error!!!&quot; );
        goto _free_source;
    }

    struct client_param *cparam = NULL;
    cparam = (struct client_param *)
                calloc( sizeof(struct client_param), ppool-&gt;max_user_num );
    if ( !cparam ) {
        PRINTINFO( LEVEL5, &quot;calloc error!!!&quot; );
        goto _free_source;
    }

    int event_num, event_fd;
    int i, j, ret, onebyte;

    while ( !ppool-&gt;stop ) {
        event_num = Epoll_wait( ppool-&gt;epollfd, events, ppool-&gt;max_epoll_event, -1);
        //PRINTINFO( LEVEL0, &quot;child event num:%d&quot;, event_num );
        if ( (event_num &lt; 0) &amp;&amp; (errno != EINTR) ) {
            PRINTINFO_ERR( LEVEL4, &quot;Epoll_wait error!!!&quot; );
            ppool-&gt;stop = 1;
            break;
        }

        for ( i = 0; i &lt; event_num; i++ ) {
            event_fd = events[i].data.fd;
            //parent process notify that there is a new client connect to.
            if ( event_fd == pipefd &amp;&amp; events[i].events &amp; EPOLLIN ) {
                PRINTINFO( LEVEL0, &quot;receive signal from parent there is a new client connection&quot; );
                ret = recv( event_fd, (char *)&amp;onebyte, 1, 0 );
                if ( ret &lt;= 0 ) {
                    continue;
                } else {
                    struct sockaddr_in clientaddr;
                    socklen_t addrlen = sizeof(clientaddr);
                    bzero( &amp;clientaddr, addrlen );

                    int connfd = accept( ppool-&gt;listenfd,
                                    (struct sockaddr *)&amp;clientaddr, &amp;addrlen );
                    if ( connfd &lt; 0 ) {
                        PRINTINFO_ERR( LEVEL3, &quot;accept a new client error!!!&quot; );
                        continue;
                    }
                    PRINTINFO( LEVEL0, &quot;one client conntect(fd:%d)&quot;, connfd );
                    Epoll_add_fd( ppool-&gt;epollfd, connfd );
                    client_param_init( &amp;cparam[connfd], connfd, &amp;clientaddr );
                }
            }
            //process catch a signal
            else if ( event_fd == sig_pipefd[1] &amp;&amp; events[i].events &amp; EPOLLIN ) {
                int sig;
                char signals[1024] = {0};
                ret = recv( sig_pipefd[1], signals, sizeof(signals), 0 );
                if ( ret &lt;= 0 ) {
                    continue;
                }
                client_signal_handle( ppool, signals, ret );
            }
            //client socket fd has readable event,maybe a
            //request
            else if ( events[i].events &amp; EPOLLIN ) {
                client_handle( &amp;cparam[event_fd] );
            }
            else {
                continue;
            }
        }
    }
_free_source:
    free( events );
    events = NULL;

    free( cparam );
    cparam = NULL;

    close( pipefd );
    close( ppool-&gt;epollfd );
}
static int parent_signal_handle( processpool *ppool,
    char *signals, int signals_num )
{
    int i = 0, j = 0;

    for ( ; i &lt; signals_num; i++ ) {
        switch( signals[i] ) {
            case SIGCHLD:
            {
                PRINTINFO( LEVEL0, &quot;parent receive SIGCHLD signal&quot; );
                pid_t pid;
                int stat;
                while ( (pid = waitpid(-1, &amp;stat, WNOHANG)) &gt; 0 ) {
                    PRINTINFO( LEVEL0, &quot;parent receive SIGCHLD signal(pid:%d)&quot;, pid );
                    for ( j = 0; j &lt; ppool-&gt;cur_process_num; j++ ) {
                        if ( ppool-&gt;sub_process[j].pid == pid ) {
                            PRINTINFO( LEVEL3, &quot;child process(%d) exit.&quot;, pid );
                            close( ppool-&gt;sub_process[j].pipefd[1] );
                            ppool-&gt;sub_process[j].pid = -1;
                        }
                    }
                }
                ppool-&gt;stop = 1;
                for ( j = 0; j &lt; ppool-&gt;cur_process_num; j++ ) {
                    PRINTINFO( LEVEL0, &quot;pid:%d&quot;, ppool-&gt;sub_process[j].pid );
                    if ( ppool-&gt;sub_process[j].pid != -1 ) {
                        ppool-&gt;stop = 0;
                        break;
                    }
                }
                break;
            }
            case SIGTERM:
            case SIGINT:
            {
                PRINTINFO( LEVEL2, &quot;recv SIGINT/SIGTERM, kill all child process now.&quot; );
                //PRINTINFO( LEVEL0, &quot;cur_process_num:%d&quot;, ppool-&gt;cur_process_num );
                for ( i = 0; i &lt; ppool-&gt;cur_process_num; i++ ) {
                    int pid = ppool-&gt;sub_process[i].pid;
                    if ( pid != -1 ) {
                        PRINTINFO( LEVEL0, &quot;kill process:%d&quot;, pid );
                        ppool-&gt;sub_process[i].pid = -1;
                        kill( pid, SIGTERM );
                    }
                }
                ppool-&gt;stop = 1;
                break;
            }
            default:
            {
                break;
            }
        }
    }
}
static void run_parent( processpool *ppool )
{
    if ( !ppool ) {
        PRINTINFO( LEVEL4, &quot;ppool is null!!!&quot; );
        return;
    }

    init_signal( ppool );

    ppool-&gt;epollfd          = Epoll_create( 5 );

    Epoll_add_fd( ppool-&gt;epollfd, ppool-&gt;listenfd );
    Epoll_add_fd( ppool-&gt;epollfd, sig_pipefd[1] );

    struct epoll_event *events = NULL;
    events = (struct epoll_event *)
        calloc( sizeof(struct epoll_event), ppool-&gt;max_epoll_event );
    if ( !events ) {
        PRINTINFO( LEVEL5, &quot;calloc error!!!&quot; );
        char sig = SIGINT;
        parent_signal_handle( ppool, &amp;sig, 1 );
        goto _free_source;
    }

    int event_num;
    int i, onebyte = 1, ret, j;
    //p_idx specifies current dispatched child process.
    //roll_index specifies the next child process.
    int p_idx , roll_index = 0;

    //PRINTINFO( LEVEL0, &quot;epollfd:%d&quot;, ppool-&gt;epollfd );

    while ( !ppool-&gt;stop ) {

        //Specifying  a timeout of -1 causes epoll_wait()
        //to block indefinitely.
        event_num =
            Epoll_wait( ppool-&gt;epollfd, events, ppool-&gt;max_epoll_event, -1 );

        if ( event_num &lt; 0 &amp;&amp; errno != EINTR ) {
            PRINTINFO_ERR( LEVEL5, &quot;Epoll_wait error!!!&quot; );
            ppool-&gt;stop = 1;
            break;
        }
        //PRINTINFO( LEVEL0, &quot;event_num:%d&quot;, event_num );
        for ( i = 0; i &lt; event_num; i++ ) {
            int event_fd = events[i].data.fd;

            //listenfd,there is a new client connection.
            //notify child process to accept
            if ( event_fd == ppool-&gt;listenfd ) {
                PRINTINFO( LEVEL0, &quot;event:parent listenfd&quot; );
                //round robin dispatch
                //easily roll polling
                p_idx = roll_index;
                do {
                    if ( ppool-&gt;sub_process[p_idx].pid != -1 ) {
                        break;
                    }
                    p_idx = ( p_idx + 1 ) % ppool-&gt;cur_process_num;
                } while ( p_idx != roll_index );

                //roll polling all the child process,but they are
                //all run error.so p_idx equals to roll_index.
                if ( ppool-&gt;sub_process[p_idx].pid &lt; 0 ) {
                    ppool-&gt;stop = 1;
                    break;
                }

                roll_index = ( p_idx + 1 ) % ppool-&gt;cur_process_num;

                if ( Send( ppool-&gt;sub_process[p_idx].pipefd[0],
                        (char *)&amp;onebyte, 1, 0 ) &lt; 0 ) {
                    PRINTINFO( LEVEL5, &quot;Send error!!!&quot; );
                    ppool-&gt;stop = 1;
                    break;
                }
            }
            //receive signal from signal handler.
            else if ( (event_fd == sig_pipefd[1])
                &amp;&amp; (events[i].events &amp; EPOLLIN) ) {
                PRINTINFO( LEVEL0, &quot;event:parent receive signal&quot; );
                int sig;
                char signals[1024];
                ret = recv( sig_pipefd[1], signals, sizeof(signals), 0 );
                if ( ret &lt;= 0 ) {
                    continue;
                } else {
                    parent_signal_handle( ppool, signals, ret );
                }
            }
        }
    }
_free_source:
    free( events );
    events = NULL;

    close( ppool-&gt;epollfd );
}
void run( processpool *ppool )
{
    if ( ppool-&gt;index != -1 ) {
        run_child( ppool );
        return;
    }
    run_parent( ppool );
}
</code></pre><p><code>client_handle.h</code>:</p>
<pre><code>#ifndef _CLIENT_HANDLE_H
#define _CLIENT_HANDLE_H

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;arpa/inet.h&gt;

#define MAXRECVBUF  1024

typedef struct client_param {
    //用于recv返回出错移除sockfd
    int epollfd;
    int sockfd;
    struct sockaddr_in addr;
    char buf[ MAXRECVBUF ];
} client_param;

void client_param_init( client_param *cparam,
    int connfd, struct sockaddr_in *addr );

void client_handle( client_param *cparam );

#endif
</code></pre><p><code>client_handle.c</code>:</p>
<pre><code>#include &quot;client_handle.h&quot;
#include &quot;util.h&quot;

void client_param_init( client_param *cparam,
    int connfd, struct sockaddr_in *addr )
{
    if ( !cparam ) {
        PRINTINFO( LEVEL4, &quot;cparam is null!!!&quot; );
        return;
    }
    cparam-&gt;sockfd = connfd;
    memcpy( &amp;cparam-&gt;addr, addr, sizeof(struct sockaddr_in) );
    memset( cparam-&gt;buf, 0, sizeof(cparam-&gt;buf) );
}
void client_handle( client_param *cparam )
{
    int i, ret;

    while ( 1 ) {
        memset( cparam-&gt;buf, 0, sizeof(cparam-&gt;buf) );
        ret = recv( cparam-&gt;sockfd, cparam-&gt;buf, sizeof(cparam-&gt;buf), 0 );
        if ( ret &lt; 0 ) {
            if ( errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK
                &amp;&amp; errno != EINTR ) {
                Epoll_del_fd( cparam-&gt;epollfd, cparam-&gt;sockfd );
            }
            close( cparam-&gt;sockfd );
            break;
        }
        else if ( 0 == ret ) {
            Epoll_del_fd( cparam-&gt;epollfd, cparam-&gt;sockfd );
            close( cparam-&gt;sockfd );
            break;
        }
        else {
            if ( ret &lt; 15 ) {
                close( cparam-&gt;sockfd );
                break;
            }
            //PRINTINFO( LEVEL0, &quot;child receive buf:\n%s&quot;, cparam-&gt;buf );
            fflush(stdout);
            char *p_get = strstr( cparam-&gt;buf, &quot;GET&quot; );
            if ( !p_get ) {
                close( cparam-&gt;sockfd );
                break;
            }
            char *p_http = strstr( cparam-&gt;buf, &quot;HTTP&quot; );
            if ( !p_http ) {
                close( cparam-&gt;sockfd );
                break;
            }

            cparam-&gt;buf[ret] = &apos;\0&apos;;

            //GET filename HTTP/1.1 .....
            char file_name[20] = {0};
            int file_name_len = p_http - p_get - 6;
            memcpy( file_name, p_get + 5, file_name_len );

            if ( access( file_name, F_OK ) == -1 ) {
                PRINTINFO( LEVEL3, &quot;file:(%s) dosen&apos;t exist!!&quot;, file_name );
                Epoll_del_fd( cparam-&gt;epollfd, cparam-&gt;sockfd );
                close( cparam-&gt;sockfd );
                break;
            }
            PRINTINFO( LEVEL0, &quot;file name:%s--&quot;, file_name );
            ret = fork();
            if ( ret == -1 ) {
                Epoll_del_fd( cparam-&gt;epollfd, cparam-&gt;sockfd );
                close( cparam-&gt;sockfd );
                break;
            }
            else if ( ret &gt; 0 ) {
                Epoll_del_fd( cparam-&gt;epollfd, cparam-&gt;sockfd );
                close( cparam-&gt;sockfd );
                break;
            }
            else {
                close( STDOUT_FILENO );
                //relocate the stdou to sockfd
                PRINTINFO( LEVEL0, &quot;sockfd:%d&quot;, cparam-&gt;sockfd );
                dup( cparam-&gt;sockfd );
                //printf(&quot;likun\n&quot;);
                execl( file_name, file_name, NULL );
                fflush(stdout);
                Epoll_del_fd( cparam-&gt;epollfd, cparam-&gt;sockfd );
                close( cparam-&gt;sockfd );
                exit( 0 );
            }
        }
    }
}
</code></pre><p><code>cgisrv.c</code>:</p>
<pre><code>#include &quot;myhshappool.h&quot;
#include &quot;client_handle.h&quot;
#include &quot;util.h&quot;
#include &quot;epoll_wrapper.h&quot;

//进程池最大数量
#define MAXPROCESSNUMBER            16
//每个进程支持客户连接任务
#define USERPERPROCESS              65535
//epool最大支持的监听事件数
#define MAXEPOLLEVENT               10000

processpool ppool;

int main()
{
    int listenfd = Socket_create( &quot;192.168.1.250&quot;, 8888 );

    init_process_pool( &amp;ppool, MAXPROCESSNUMBER,
        USERPERPROCESS, MAXEPOLLEVENT, 5, listenfd );

    run( &amp;ppool );

    close( listenfd );

    return 0;
}
</code></pre><p>贴一下makefile：</p>
<pre><code>CC = gcc
ROOTDIR = $(shell pwd)
OBJ = util.o myhshappool.o epoll_wrapper.o \
client_handle.o cgisrc.o
BIN = cgisrv.bin
CFLAG = -Wall -O2 -I./
LDFLAG += -c

$(BIN):${OBJ}
    $(CC) $(CFLAG) -o $@ $^

%:%.c
    $(CC) $(CFLAG) -o $@ $&lt; $(LDFLAG)

.PHONY:clean
clean:
    rm $(OBJ) $(BIN) -rf
</code></pre><p>还有cgi执行程序：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;string.h&gt;
/*
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;&lt;u&gt;&lt;font color=00ff00&gt;..&lt;/font&gt;&lt;/u&gt;&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;
*/
int main( int argc, char **argv )
{
    time_t tt = time(NULL);

    printf(&quot;&lt;!DOCTYPE html&gt;&quot;);
    printf(&quot;&lt;html&gt;&quot;);
    printf(&quot;&lt;head&gt;&quot;);
    printf(&quot;&lt;meta charset=\&quot;utf-8\&quot;&gt;&quot;);
    printf(&quot;&lt;title&gt;get now time&lt;/title&gt;&quot;);
    printf(&quot;&lt;/head&gt;&quot;);
    printf(&quot;&lt;body&gt;&quot;);
    printf(&quot;&lt;h1&gt;&lt;u&gt;&lt;font color=00ff00&gt;&quot;);
    printf(&quot;当前服务器时间:%s&quot;, ctime(&amp;tt));
    printf(&quot;&lt;/font&gt;&lt;/u&gt;&lt;/h1&gt;&quot;);
    printf(&quot;&lt;/body&gt;&quot;);
    printf(&quot;&lt;/html&gt;&quot;);

    return 0;
}
</code></pre><p>测试：代码编译了，即可执行cgisrv.bin，主进程处于监听客户端连接情况，打开浏览器输入: <code>http://xxx.xxx.xxx.xxx:8888/now.cgi，可以看到出现一行加下划线的绿字：当前服务器时间:Sat Sep 17 21:49:07 2016</code>。</p>
<p>ip、端口、进程池数、最大epoll监听事件数等在入口模块(cgisrv)可以改。</p>
<p>本例子写完，调试了几个地方，运行几个客户端发送get请求就没有做测试了，练手的玩具demo ^_^。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2018-06-19T02:02:56.131Z" itemprop="dateUpdated">2018-06-19 10:02:56</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="http://lkness">
            <img src="/img/head.jpg" alt="lkness">
            lkness
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://lkness/2018/06/15/009cgiserver/index/&title=《c半同步半异步进程池模型之cgi服务器》 — My Blog&pic=http://lkness/img/head.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://lkness/2018/06/15/009cgiserver/index/&title=《c半同步半异步进程池模型之cgi服务器》 — My Blog&source=学不见其长，但日有所增" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://lkness/2018/06/15/009cgiserver/index/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《c半同步半异步进程池模型之cgi服务器》 — My Blog&url=http://lkness/2018/06/15/009cgiserver/index/&via=http://lkness" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://lkness/2018/06/15/009cgiserver/index/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2018/06/15/010recu-insert-sort/index/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">递归插入排序-《算法导论》学习笔记三</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2018/06/15/008merge-sort/index/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">归并排序-《算法导论》学习笔记二</h4>
      </a>
    </div>
  
</nav>



    








<section class="comments" id="comments">
    <div id="gitment_thread"></div>
    <link rel="stylesheet" href="//unpkg.com/gitment/style/default.css">
    <script src="//unpkg.com/gitment/dist/gitment.browser.js"></script>
    <script>
        var gitment = new Gitment({
            id: "Fri Jun 15 2018 18:47:28 GMT+0800",
            owner: 'xlkness',
            repo: 'xlkness.github.io',
            oauth: {
                client_id: '53494e1af384ef691a2c',
                client_secret: '933d8900eed9ddfe9909a3cfdadcdc8ac5a7aefd',
            },
        })
        gitment.render('comments')
    </script>
</section>










</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        觉得好看可以打赏哦
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/weixin.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/weixin.png" data-alipay="/img/zhifubao.png">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>lkness &copy; 2015 - 2018</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://lkness/2018/06/15/009cgiserver/index/&title=《c半同步半异步进程池模型之cgi服务器》 — My Blog&pic=http://lkness/img/head.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://lkness/2018/06/15/009cgiserver/index/&title=《c半同步半异步进程池模型之cgi服务器》 — My Blog&source=学不见其长，但日有所增" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://lkness/2018/06/15/009cgiserver/index/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《c半同步半异步进程池模型之cgi服务器》 — My Blog&url=http://lkness/2018/06/15/009cgiserver/index/&via=http://lkness" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://lkness/2018/06/15/009cgiserver/index/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACNklEQVR42u3aQW7DMAwFUd//0i7QVQE3znzSDSpqtAocx9LzghFFHgce5/e4Xvk5rtfvn/bqzvvftoYMGTKWZZy34/povsT0t6/uv1+bDBky9mGkj7u/h/DSV/BmzTJkyJARkvhGkMwlQ4YMGWnA5d+SLR2fRYYMGTJIEsuP2MhGMH1Bj+XiMmTIWJCRFgY++fkP6xsyZMhYhHGGg5cz+UYwDbK/PF+GDBmjGffL4pGNBE0eRmtprQwZMqYyPhNqayWEIBmWIUPGaAZZXO06v4fPUvzfkCFDxghGf2J+PEfaNdJSgQwZMnZj1Foi+tvENJEOEloZMmQMZaTLSjd2tWYOGTJk7MzgG6+0MEmWWJv3TQlThgwZgxi1lohO2pkWA9CvZMiQsQ2jtiHrFCbTMgAKuDJkyBjKSI+9+FFaSiq2rMmQIWMDBn90LfnshF2SHsuQIWMfBjl6SwNluuksNp/JkCFjNOOpZq8TDF6EIIUEGTJk7MZIWyLQI3AFtZNIH3x6GTJkLMvoLJQH2WcbL+IzPBkyZIxgpOlr7Sit9vrQAZwMGTJGM2plRX5wn4bp9O+hVR2VIUPGIowzHCmDf9spi8qQIWM2gw9+QFa78lROKkOGjKmMTumRt0fwt8jbO2TIkLEbgwQ+fojPF9FJmGXIkCGDpIu11Je/guAoUIYMGTLw1jBtKeu0hbUCrgwZMhZkkEXEQbBWUwXbwbiQKUOGjMUZ/aaKWutYZ9EP1zdkyJDxfxlffJ4PLMEc4jsAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '';
            clearTimeout(titleTime);
        } else {
            document.title = '';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
